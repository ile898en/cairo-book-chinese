# 段 (Segments) 介绍

Cairo 确保分配的内存在写入后保持不可变，同时允许在运行时动态扩展内存段。所有这些都是通过将内存地址组织成 **段 (segments)** 来实现的。

将内存地址组织成段的过程如下：

1. 在运行时，它将分配的内存地址分组为具有唯一段标识符和偏移量的段，以指示属于每个段的内存地址的延续，即 `<segment_id>:<offset>`。我们标记给每个内存地址的这个临时值称为 **可重定位值 (relocatable value)**。

2. 在执行结束时，可重定位值被转换为单个连续的内存地址空间，并创建一个单独的 **重定位表 (relocation table)** 来为线性内存地址空间提供上下文。

## 段值

Cairo 的内存模型包含以下段：

- **程序段 (Program Segment)** = 存储 Cairo 程序的字节码。另一种说法是它存储 Cairo 程序的指令。程序计数器 `pc` 从此段的开头开始。
- **执行段 (Execution Segment)** = 存储执行 Cairo 程序时的任何数据（临时变量、函数调用帧和指针）。分配指针 `ap` 和帧指针 `fp` 从此段开始。
- **内置函数段 (Builtin Segment)** = 存储 Cairo 程序正在使用的内置函数。每个 Cairo 内置函数都有自己专用的段，根据程序中使用的内置函数动态分配。查看 [内置函数部分](ch204-00-builtins.md) 以了解有关各个内置函数的更多信息。
- **用户段 (User Segment)** = 存储程序输出、数组和动态分配的数据结构。

_除了程序段之外，每个段都有一个动态地址空间，这意味着分配的内存地址空间的长度在程序完成执行之前是未知的。程序段是一个例外，因为它用于存储 Cairo 程序的字节码，该字节码在执行期间具有固定大小。_

## 段布局

Cairo 内存的布局按以下顺序按段排序：

1. **Segment 0** = 程序段
2. **Segment 1** = 执行段
3. **Segment 2 到 x** = 内置函数段
4. **Segment x + 1 到 y** = 用户段

_内置函数段和用户段的数量是动态的，取决于程序的类型。_

# 重定位

为了理解如何在 Cairo 程序的整个执行过程中处理内存的整体过程，我们将看一个 Cairo Zero 程序的示例，以及它的段如何在运行时使用可重定位值定义，以及内存地址如何在执行结束时重定位到一个连续的内存地址空间。

**Cairo Zero 程序：**

```cairo
%builtins output

func main(output_ptr: felt*) -> (output_ptr: felt*) {

    // We are allocating three different values to segment 1.
    [ap] = 10, ap++;
    [ap] = 100, ap++;
    [ap] = [ap - 2] + [ap - 1], ap++;

    // We set value of output_ptr to the address of where the output will be stored.
    // This is part of the output builtin requirement.
    [ap] = output_ptr, ap++;

    // Asserts that output_ptr equals to 110.
    assert [output_ptr] = 110;

    // Returns the output_ptr + 1 as the next unused memory address.
    return (output_ptr=output_ptr + 1);
}
```

_输出内置函数允许将最终输出存储在新段中。_

Cairo Zero 程序存储三个值，即 `10`、`100` 和 `110`（`10` 和 `100` 相加），这些值存储在段 1 下的三个不同内存地址中。

使用输出内置函数，最终输出存储在段 2 中的一个新段中。

**可重定位值如下：**

```
Addr  Value
-----------

// Segment 0

0:0   5189976364521848832
0:1   10
0:2   5189976364521848832
0:3   100
0:4   5201798304953696256
0:5   5191102247248822272
0:6   5189976364521848832
0:7   110
0:8   4612389708016484351
0:9   5198983563776458752
0:10  1
0:11  2345108766317314046
⋮
// Segment 1

1:0   2:0
1:1   3:0
1:2   4:0
1:3   10
1:4   100
1:5   110
1:6   2:0
1:7   110
1:8   2:1
⋮
// Segment 2

2:0   110

```

一旦程序完成执行，在重定位表的帮助下，可重定位值将变成一个连续的内存地址空间，以便为线性内存地址空间提供上下文。

**从重定位值到一个连续的内存地址空间：**

```
Addr  Value
-----------
1     5189976364521848832
2     10
3     5189976364521848832
4     100
5     5201798304953696256
6     5191102247248822272
7     5189976364521848832
8     110
9     4612389708016484351
10    5198983563776458752
11    1
12    2345108766317314046
13    22
14    23
15    23
16    10
17    100
18    110
19    22
20    110
21    23
22    110
```

**重定位表：**

```
segment_id  starting_index
----------------------------
0            1
1            13
2            22
3            23
4            23
```

重定位表通过用自己的起始索引标记段标识符，为证明者提供新段从哪个索引开始的上下文。
