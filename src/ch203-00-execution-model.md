# 执行模型

Cairo VM 的 CPU 架构定义了 VM 如何处理指令并更改其状态。它直接类比于物理计算机中的中央处理器 (CPU)。在 Cairo VM 中，CPU 遵循冯·诺依曼架构的原则，即程序指令和数据都驻留在同一内存空间中。VM 的执行模型实现为一个重复循环，称为 **获取-解码-执行循环 (fetch-decode-execute cycle)**，它规定了机器如何从一个状态前进到下一个状态。

执行模型由其寄存器、唯一的指令集架构和 VM 的状态转换函数定义。

## 寄存器

在任何 CPU 架构中，寄存器都是小型的、高速的存储位置，用于保存处理时最急需的数据。Cairo VM 有三个专用寄存器，用于管理程序的流程和内存上下文。VM 在任何给定时刻的状态完全由这三个寄存器的值定义，这些值是经过证明的执行跟踪的一部分。

- **`pc` (程序计数器)** 保存要获取和执行的下一条指令的内存地址。在大多数指令之后，它会递增以指向下一条指令，但跳转和调用指令可以直接修改它以从不同的指令继续。
- **`ap` (分配指针)** 用作堆栈指针，通常指向下一个空闲（未写入）的内存单元。许多指令将 `ap` 增加 1，但这通常不是强制的。
- **`fp` (帧指针)** 为当前函数的执行上下文或“堆栈帧”提供稳定的参考点。当调用函数时，`fp` 设置为 `ap` 的当前值。这允许函数可靠地访问其参数及其返回地址，这些参数和返回地址位于相对于 `fp` 的固定负偏移量处，而不管使用 `ap` 在堆栈上分配了多少局部变量。

## 指令和操作码

Cairo **指令** 是单个步骤的完整计算单元，编码为 64 位 field 元素。这个单词包含三个 16 位有符号偏移量 (`off_dst`, `off_op0`, `off_op1`) 和 15 个不同的布尔标志，用于了解使用哪些寄存器进行寻址、执行什么算术运算以及如何为下一个状态更新 `pc`、`ap` 和 `fp` 寄存器。

这三个偏移量确定指令相对于寄存器读取/写入哪些内存单元。15 个标志编码要执行的操作以及如何更新寄存器。例如，标志组包括 `dst_reg`（是将结果写入 `fp`、`ap` 还是 `pc`）、`op0_reg`/`op1_reg`（操作数是来自 `fp`、`ap` 还是立即数）、算术/逻辑运算以及跳转控制。

虽然 Cairo VM 中有许多不同的指令，但 VM 本身仅支持三个操作码：

1.  **`CALL`**: 启动函数调用，将当前上下文（`fp` 和返回 `pc`）保存到堆栈。
2.  **`RET`**: 执行函数返回，从堆栈恢复调用者的上下文。
3.  **`ASSERT_EQ`**: 强制执行相等约束。

## Cairo 汇编 (CASM)

CASM 是 Cairo 的人类可读汇编语言。它是机器指令的直接文本表示。开发人员使用高级 Cairo 语言编写逻辑，编译器的最后一步是将此逻辑转换为 CASM 指令序列。但是，也可以手写 CASM 指令。每一行有效的 CASM，例如 `[fp + 1] = [ap - 2] + 5` 或 `jmp rel 17 if [ap] != 0`，都对应于特定的指令。

## 状态转换

Cairo VM 在任何步骤 \(i\) 的状态完全由元组 \((pc_i, ap_i, fp_i)\) 捕获。**状态转换函数** 是一组确定性的规则，它根据当前状态和从内存中获取的指令计算下一个状态 \((pc_{i+1}, ap_{i+1}, fp_{i+1})\)。此过程完美地反映了物理 CPU 的经典获取-解码-执行循环。

整个循环，从获取指令到断言其正确性并更新寄存器，是 Cairo VM 中的单个原子步骤。此过程是编码到 Cairo AIR 的多项式约束中的一部分，保证程序执行的每一步都遵守 VM 的规则并且可以被证明。

从概念上讲，每个步骤检查一条指令并将其语义强制为代数约束。例如，典型指令将从地址 `pc + off_op0` 和 `pc + off_op1`（相对于寄存器）处的内存加载值，计算结果（加、乘、减），然后将其写入地址 `pc + off_dst` 处的内存。它还将设置下一个 `pc`，可能会增加 `ap`，并保持 `fp` 不变或在函数调用返回时恢复它。

这些规则是完全确定性的：给定当前状态和内存，Cairo VM 恰好有一个有效的下一个状态。关键点在于，对于每条指令，AIR 中都存在一组必须满足的代数约束。如果在任何步骤无法满足约束（例如，VM 执行非法状态转换），则无法证明执行。

相反，如果所有步骤都通过，那么就有可能从该执行中生成证明。
