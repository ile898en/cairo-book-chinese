<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Cairo Programming Language (Chinese)</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-d54ab8fc.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-725ed061.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The Cairo Programming Language (Chinese)</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/starkware-libs/cairo-book" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="cairo-书籍-the-cairo-book"><a class="header" href="#cairo-书籍-the-cairo-book">Cairo 书籍 (The Cairo Book)</a></h1>
<p><em>由 Cairo 社区及其 <a href="https://github.com/cairo-book/cairo-book.github.io">贡献者</a> 编写。特别感谢 <a href="https://starkware.co/">StarkWare</a> 通过 <a href="https://www.onlydust.xyz/">OnlyDust</a> 和 <a href="https://voyager.online/">Voyager</a> 支持本书的创作。</em></p>
<p>本文档版本假设你使用的是 <a href="https://github.com/starkware-libs/cairo">Cairo</a> <a href="https://github.com/starkware-libs/cairo/releases">版本 2.13.1</a> 和 <a href="https://foundry-rs.github.io/starknet-foundry/index.html">Starknet Foundry</a> <a href="https://github.com/foundry-rs/starknet-foundry/releases">版本 0.51.1</a>。请参阅第 {{#chap getting-started}} 章的 <a href="#安装">安装</a> 部分以安装或更新 Cairo 和 Starknet Foundry。</p>
<p>这本书是开源的。发现错别字或想做贡献？查看本书的 <a href="https://github.com/cairo-book/cairo-book">GitHub 仓库</a>。</p>
<p>精通 Cairo 的其他资源：</p>
<ul>
<li>
<p><a href="https://www.cairo-lang.org/cairovm/">Cairo Playground</a>：基于浏览器的 Cairo 游乐场，无需任何设置即可通过编写、编译、调试和证明 Cairo 代码来探索和试验 Cairo。</p>
<blockquote>
<p>注意：你可以使用 Cairo Playground 来试验本书的代码片段，并查看它们如何编译成 Sierra（中间表示）和 Casm（Cairo 汇编）。</p>
</blockquote>
</li>
<li>
<p><a href="https://docs.cairo-lang.org/core?_=60">Cairo 核心库文档</a>：Cairo 核心库的文档，核心库是内置于语言中的一组标准类型、trait 和实用程序，提供了 Cairo 生态系统中使用的基本构建块，并在每个 Cairo 项目中自动可用。</p>
</li>
<li>
<p><a href="https://scarbs.xyz/">Cairo 包注册表</a>：Cairo 不断增长的可重用库集合的主机，包括 <a href="https://github.com/keep-starknet-strange/alexandria">Alexandria</a>、<a href="https://docs.openzeppelin.com/contracts-cairo/1.0.0/">Open Zeppelin Contracts for Cairo</a>，所有这些都可以通过 Scarb 轻松集成，从而简化开发和依赖项管理。</p>
</li>
<li>
<p><a href="https://docs.swmansion.com/scarb/docs.html">Scarb 文档</a>：Cairo 包管理器和构建工具的官方文档，涵盖如何创建和管理包、使用依赖项、运行构建和配置项目。</p>
</li>
<li>
<p><a href="https://eprint.iacr.org/2021/1063.pdf">Cairo 白皮书</a>：StarkWare 介绍 Cairo 的原始论文，解释了 Cairo 作为一种编写可证明程序的语言，详细介绍了其架构，并展示了它是如何在不依赖可信设置的情况下实现可扩展、可验证计算的。</p>
</li>
</ul>
<p>如果你有任何问题、反馈或意见，可以通过 <a href="https://github.com/cairo-book/cairo-book/issues">Github Issues</a> 联系，或直接联系 <a href="https://relens.ai/blog/author/eni">维护者</a>。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="前言"><a class="header" href="#前言">前言</a></h1>
<p>零知识证明（Zero-knowledge proofs）已成为区块链领域的一项变革性技术，为隐私和可扩展性挑战提供了解决方案。其中，STARKs（可扩展的透明知识论证，Scalable Transparent ARguments of Knowledge）作为一项特别强大的创新脱颖而出。与传统的证明系统不同，STARKs 仅依赖于抗碰撞的哈希函数，使其具有后量子安全性，并消除了对可信设置（trusted setups）的需求。</p>
<p>然而，编写能够生成加密证明的通用程序历来是一个巨大的挑战。开发者需要深厚的密码学专业知识和复杂的数学概念才能创建可验证的计算，这使得主流采用变得不切实际。</p>
<p>这就是 Cairo 发挥作用的地方。作为一种专门为创建可证明程序而设计的通用编程语言，Cairo 抽象了底层的密码学复杂性，同时保持了 STARKs 的全部威力。Cairo 深受 Rust 的启发，旨在帮助你创建可证明的程序，而无需了解其底层架构的具体知识，让你可以专注于程序逻辑本身。</p>
<p>想要在 Starknet 上部署合约的区块链开发者将使用 Cairo 编程语言来编写他们的智能合约。这允许 Starknet OS 为交易生成执行轨迹（trace），由证明者进行证明，然后在更新 Starknet 的状态根之前在以太坊 L1 上进行验证。</p>
<p>然而，Cairo 不仅仅适用于区块链开发者。作为一种通用编程语言，它可用于任何受益于“在一台计算机上证明并在其他机器上验证”的计算。由 Rust 虚拟机和下一代证明者驱动，Cairo 程序的执行和证明生成速度极快——使 Cairo 成为构建可证明应用程序的最佳工具。</p>
<p>本书专为具备基本编程概念理解的开发者设计。它是一本友好且平易近人的读物，旨在帮助你提升 Cairo 知识，同时也帮助你发展通用的编程技能。所以，尽情投入，准备学习关于 Cairo 的一切吧！</p>
<h2 id="致谢"><a class="header" href="#致谢">致谢</a></h2>
<p>如果没有 Cairo 社区的帮助，本书就不可能完成。我们要感谢每一位为本书做出贡献的贡献者！</p>
<p>我们要感谢 Rust 社区提供的 <a href="https://doc.rust-lang.org/book/">Rust Book</a>，它是本书巨大的灵感来源。许多例子和解释都从 Rust Book 改编而来，以适应 Cairo 编程语言，因为这两种语言有许多相似之处。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="简介"><a class="header" href="#简介">简介</a></h1>
<h2 id="什么是-cairo"><a class="header" href="#什么是-cairo">什么是 Cairo？</a></h2>
<p>Cairo 是一门编程语言，旨在利用数学证明的力量来实现计算完整性（Computational Integrity）。正如 C.S. Lewis 将正直（integrity）定义为“即使在没人注视时也做正确的事”，Cairo 使得程序能够证明它们执行了正确的计算，即使是在不可信的机器上执行时也是如此。</p>
<p>这门语言建立在 STARK 技术之上，这是一种 PCP（概率可检测证明，Probabilistically Checkable Proofs）的现代演进，它将计算主张转化为约束系统。Cairo 的最终目的是生成这些可以被高效且绝对确定地验证的数学证明。</p>
<h2 id="你能用它做什么"><a class="header" href="#你能用它做什么">你能用它做什么？</a></h2>
<p>Cairo 下开启了我们对可信计算思考方式的范式转变。它目前的主要应用是 Starknet，这是一个以太坊的 Layer 2 扩容解决方案，旨在解决区块链的基本挑战之一：在不牺牲安全性的前提下实现可扩展性。</p>
<p>在传统的区块链模型中，每个参与者都必须验证每一次计算。Starknet 通过使用 Cairo 的证明系统改变了这一点：计算由证明者（Prover）在链下执行并生成 STARK 证明，然后由以太坊智能合约进行验证。这种验证所需的计算能力远低于重新执行计算所需的计算能力，从而在保持安全性的同时实现了巨大的可扩展性。</p>
<p>然而，Cairo 的潜力不仅仅局限于区块链。任何需要高效验证计算完整性的场景都可以从 Cairo 的可验证计算能力中受益。</p>
<h2 id="本书的读者对象"><a class="header" href="#本书的读者对象">本书的读者对象</a></h2>
<p>本书主要面向三类读者，每类读者都有自己的学习路径：</p>
<ol>
<li>
<p><strong>通用开发者</strong>：如果你对 Cairo 在区块链之外的可验证计算能力感兴趣，你应该专注于章节 {{#chap getting-started}}-{{#chap advanced-cairo-features}}。这些章节涵盖了核心语言特性和编程概念，而没有深入探讨智能合约的细节。</p>
</li>
<li>
<p><strong>新的智能合约开发者</strong>：如果你对 Cairo 和智能合约都是新手，我们要建议从头到尾阅读本书。这将为你打下语言基础和智能合约开发原则的坚实基础。</p>
</li>
<li>
<p><strong>有经验的智能合约开发者</strong>：如果你已经熟悉其他语言（或 Rust）的智能合约开发，你可能希望遵循这条专注的路径：</p>
<ul>
<li>章节 {{#chap getting-started}}-{{#chap common-collections}} 用于了解 Cairo 基础</li>
<li>章节 {{#chap generic-types-and-traits}} 用于了解 Cairo 的 Trait 和泛型系统</li>
<li>跳到章节 {{#chap building-starknet-smart-contracts}} 开始智能合约开发</li>
<li>根据需要参考其他章节</li>
</ul>
</li>
</ol>
<p>无论你的背景如何，本书假设你具备基本的编程知识，如变量、函数和常见的数据结构。虽然有 Rust 经验会有所帮助（因为 Cairo 有许多相似之处），但这并非必需。</p>
<h2 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h2>
<ul>
<li>Cairo CPU 架构: <a href="https://eprint.iacr.org/2021/1063">https://eprint.iacr.org/2021/1063</a></li>
<li>Cairo, Sierra 和 Casm: <a href="https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5">https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5</a></li>
<li>非确定性状态: <a href="https://twitter.com/PapiniShahar/status/1638203716535713798">https://twitter.com/PapiniShahar/status/1638203716535713798</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="入门"><a class="header" href="#入门">入门</a></h1>
<p>让我们开始你的 Cairo 之旅吧！虽然有很多东西要学，但每一段旅程都有起点。在本章中，我们将讨论：</p>
<ul>
<li>在 Linux、macOS 和 Windows 上安装 Scarb，也就是 Cairo 的构建工具链和包管理器。</li>
<li>安装 Starknet Foundry，这是创建 Cairo 项目时的默认测试运行器（test runner）。</li>
<li>编写一个打印 <code>Hello, world!</code> 的程序。</li>
<li>使用基本的 Scarb 命令来创建项目和执行程序。</li>
</ul>
<h2 id="获取帮助"><a class="header" href="#获取帮助">获取帮助</a></h2>
<p>如果你有任何关于 Starknet 或 Cairo 的问题，可以在 <a href="https://discord.gg/starknet-community">Starknet Discord 服务器</a> 中提问。社区非常友好，总是乐于助人。</p>
<h2 id="与-starknet-ai-agent-交互"><a class="header" href="#与-starknet-ai-agent-交互">与 Starknet AI Agent 交互</a></h2>
<p>Starknet 提供了自己的 AI Agent，旨在协助解决 Cairo 和 Starknet 相关的问题。这个 AI Agent 接受过 Cairo Book 和 Starknet 文档的训练，使用检索增强生成（RAG）技术来高效检索信息并提供准确的帮助。</p>
<p>你可以在 <a href="https://agent.starknet.id/">Starknet Agent</a> 网站上找到 Starknet Agent。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="安装"><a class="header" href="#安装">安装</a></h1>
<p>第一步是安装 Cairo。我们将通过 <a href="https://github.com/software-mansion/starkup">starkup</a> 下载 Cairo，这是一个用于管理 Cairo 版本和相关工具的命令行工具。下载过程中你需要保持网络连接。</p>
<p>接下来的步骤将通过名为 <a href="https://docs.swmansion.com/scarb/docs">Scarb</a> 的二进制文件安装 Cairo 编译器的最新稳定版。Scarb 将 Cairo 编译器和 Cairo 语言服务器捆绑在一个易于安装的包中，这样你就可以立即开始编写 Cairo 代码了。</p>
<p>Scarb 也是 Cairo 的包管理器，它的灵感很大程度上来自于 <a href="https://doc.rust-lang.org/cargo/">Cargo</a>——Rust 的构建系统和包管理器。</p>
<p>Scarb 为你处理许多任务，例如构建你的代码（无论是纯 Cairo 代码还是 Starknet 合约）、下载你的代码依赖的库、构建这些库，并为 VSCode Cairo 1 扩展提供 LSP 支持。</p>
<p>随着你编写更复杂的 Cairo 程序，你可能会添加依赖项，如果你使用 Scarb 启动项目，管理外部代码和依赖项将变得容易得多。</p>
<p><a href="https://foundry-rs.github.io/starknet-foundry/index.html">Starknet Foundry</a> 是用于 Cairo 程序和 Starknet 智能合约开发的工具链。它支持许多功能，包括编写和运行具有高级特性的测试、部署合约、与 Starknet 网络交互等等。</p>
<p>让我们从安装 starkup 开始，它将帮助我们管理 Cairo、Scarb 和 Starknet Foundry。</p>
<h2 id="在-linux-或-macos-上安装-starkup"><a class="header" href="#在-linux-或-macos-上安装-starkup">在 Linux 或 macOS 上安装 <code>starkup</code></a></h2>
<p>如果你使用的是 Linux 或 macOS，请打开终端并输入以下命令：</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.starkup.dev | sh
</code></pre>
<p>该命令会下载一个脚本并开始安装 starkup 工具，它会安装最新稳定版的 Cairo 及相关工具。系统可能会提示你输入密码。如果安装成功，将出现以下行：</p>
<pre><code class="language-bash">starkup: Installation complete.
</code></pre>
<p>安装后，starkup 会自动安装最新稳定版的 Cairo、Scarb 和 Starknet Foundry。你可以通过在新的终端会话中运行以下命令来验证安装：</p>
<pre><code class="language-bash">$ scarb --version
scarb 2.13.1 (639d0a65e 2025-08-04)
cairo: 2.13.1 (https://crates.io/crates/cairo-lang-compiler/2.13.1)
sierra: 1.7.0

$ snforge --version
snforge 0.51.1
</code></pre>
<p>我们将在 <a href="#如何编写测试">第 {{#chap testing-cairo-programs}} 章</a>（Cairo 程序测试）以及 <a href="#testing-smart-contracts-with-starknet-foundry">第 {{#chap starknet-smart-contracts-security}} 章</a>（讨论 Starknet 智能合约测试和安全性）中更详细地描述 Starknet Foundry。</p>
<h2 id="安装-vscode-扩展"><a class="header" href="#安装-vscode-扩展">安装 VSCode 扩展</a></h2>
<p>Cairo 有一个 VSCode 扩展，提供语法高亮、代码补全和其他有用的功能。你可以从 <a href="https://marketplace.visualstudio.com/items?itemName=starkware.cairo1">VSCode Marketplace</a> 安装它。安装后，进入扩展设置，确保勾选 <code>Enable Language Server</code> 和 <code>Enable Scarb</code> 选项。</p>
<p>{{#quiz ../quizzes/ch01-01-installation.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="hello-world"><a class="header" href="#hello-world">Hello, World</a></h1>
<p>既然你已经通过 Scarb 安装了 Cairo，是时候编写你的第一个 Cairo 程序了。学习一门新语言的传统是写一个小程序，把文本 <code>Hello, world!</code> 输出到屏幕上，我们也照做！</p>
<blockquote>
<p>注意：本书假设你对命令行有基本的了解。Cairo 对你的编辑器或工具或代码的位置没有特殊要求，所以如果你喜欢使用集成开发环境 (IDE) 而不是命令行，请随意使用你喜欢的 IDE。Cairo 团队开发了一个 Cairo 语言的 VSCode 扩展，你可以用它来获得语言服务器的功能和代码高亮。详见 <a href="#附录-f---有用的开发工具">附录 F</a>。</p>
</blockquote>
<h2 id="创建项目目录"><a class="header" href="#创建项目目录">创建项目目录</a></h2>
<p>首先创建一个目录来存储你的 Cairo 代码。Cairo 不在乎你的代码在哪里，但为了本书的练习和项目，我们建议在你的主目录中创建一个 <em>cairo_projects</em> 目录，并将所有项目都放在那里。</p>
<p>打开终端并输入以下命令来创建 <em>cairo_projects</em> 目录。</p>
<p>对于 Linux, macOS 和 Windows PowerShell，输入：</p>
<pre><code class="language-shell">mkdir ~/cairo_projects
cd ~/cairo_projects
</code></pre>
<p>对于 Windows CMD，输入：</p>
<pre><code class="language-cmd">&gt; mkdir "%USERPROFILE%\cairo_projects"
&gt; cd /d "%USERPROFILE%\cairo_projects"
</code></pre>
<blockquote>
<p>注意：从现在开始，对于书中展示的每个例子，我们假设你将在一个 Scarb 项目目录中工作。如果你不使用 Scarb，并尝试从不同的目录运行示例，你可能需要相应地调整命令或创建一个 Scarb 项目。</p>
</blockquote>
<h2 id="使用-scarb-创建项目"><a class="header" href="#使用-scarb-创建项目">使用 Scarb 创建项目</a></h2>
<p>让我们使用 Scarb 创建一个新项目。</p>
<p>导航到你的 <em>cairo_projects</em> 目录（或者你决定存储代码的任何地方）。然后运行：</p>
<pre><code class="language-bash">scarb new hello_world
</code></pre>
<p>Scarb 会询问你想要添加哪些依赖。你会看到两个选项：</p>
<pre><code class="language-text">? Which test runner do you want to set up? ›
❯ Starknet Foundry (default)
  Cairo Test
</code></pre>
<p>一般来说，我们首选使用第一个 <code>❯ Starknet Foundry (default)</code>。</p>
<p>这将创建一个名为 <em>hello_world</em> 的新目录和项目。我们将项目命名为 <em>hello_world</em>，Scarb 也在同名目录中创建了文件。</p>
<p>进入 <em>hello_world</em> 目录（<code>cd hello_world</code>）。你会看到 Scarb 为我们生成了三个文件和两个目录：一个 <em>Scarb.toml</em> 文件，一个包含 <em>lib.cairo</em> 文件的 <em>src</em> 目录，以及一个包含 <em>test_contract.cairo</em> 文件的 <em>tests</em> 目录。目前，我们可以删除这个 <em>tests</em> 目录。</p>
<p>它还初始化了一个新的 Git 仓库以及一个 <code>.gitignore</code> 文件。</p>
<blockquote>
<p>注意：Git 是一个常见的版本控制系统。你可以通过使用 <code>--no-vcs</code> 标志来停止使用版本控制系统。运行 <code>scarb new --help</code> 查看可用选项。</p>
</blockquote>
<p>在你的文本编辑器中打开 <em>Scarb.toml</em>。它应该类似于清单 {{#ref scarb-content}} 中的代码。</p>
<p><span class="filename">文件名: Scarb.toml</span></p>
<pre><code class="language-toml">[package]
name = "hello_world"
version = "0.1.0"
edition = "2024_07"

# See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html

[dependencies]
starknet = "2.13.1"

[dev-dependencies]
snforge_std = "0.51.1"
assert_macros = "2.13.1"

[[target.starknet-contract]]
sierra = true

[scripts]
test = "snforge test"

# ...
</code></pre>
<p>{{#label scarb-content}} <span class="caption">清单 {{#ref scarb-content}}:
由 <code>scarb new</code> 生成的 <em>Scarb.toml</em> 内容</span></p>
<p>这个文件使用 <a href="https://toml.io/">TOML</a> (Tom’s Obvious, Minimal Language) 格式，这是 Scarb 的配置格式。</p>
<p>第一行 <code>[package]</code> 是一个部分标题，表示接下来的语句是在配置一个包。随着我们向文件添加更多信息，我们将添加其他部分。</p>
<p>接下来的三行设置了 Scarb 编译你的程序所需的配置信息：包的名称、要使用的 Scarb 版本以及要使用的预设 (prelude) 版本。预设是自动导入到每个 Cairo 程序中的最常用项目的集合。你可以在 <a href="#附录-d---cairo-prelude">附录 D</a> 中了解更多关于预设的信息。</p>
<p><code>[dependencies]</code> 部分是一个供你去列出任何项目依赖项的区域。在 Cairo 中，代码包被称为 crate。在这个项目中我们需要任何其他 crate。</p>
<p><code>[dev-dependencies]</code> 部分是关于开发所需的依赖项，但对于项目的实际生产构建是不需要的。<code>snforge_std</code> 和 <code>assert_macros</code> 就是这种依赖项的两个例子。如果你想在不使用 Starknet Foundry 的情况下测试你的项目，你可以使用 <code>cairo_test</code>。</p>
<p><code>[[target.starknet-contract]]</code> 部分允许构建 Starknet 智能合约。我们可以暂时删除它。</p>
<p><code>[script]</code> 部分允许定义自定义脚本。默认情况下，有一个使用 <code>snforge</code> 运行测试的脚本 <code>scarb test</code>。我们也可以暂时删除它。</p>
<p>Starknet Foundry 还有更多选项，请查看 <a href="https://foundry-rs.github.io/starknet-foundry/appendix/scarb-toml.html">Starknet Foundry 文档</a> 了解更多信息。</p>
<p>默认情况下，使用 Starknet Foundry 会添加 <code>starknet</code> 依赖项和 <code>[[target.starknet-contract]]</code> 部分，以便你可以开箱即用地为 Starknet 构建合约。我们将从纯 Cairo 程序开始，所以你可以编辑你的 <em>Scarb.toml</em> 文件如下：</p>
<p><span class="filename">文件名: Scarb.toml</span></p>
<pre><code class="language-toml">[package]
name = "hello_world"
version = "0.1.0"
edition = "2024_07"

[cairo]
enable-gas = false

[dependencies]
cairo_execute = "2.13.1"


[[target.executable]]
name = "hello_world_main"
function = "hello_world::hello_world::main"
</code></pre>
<p>{{#label modified-scarb-content}} <span class="caption">清单
{{#ref modified-scarb-content}}: 修改后的 <em>Scarb.toml</em> 内容</span></p>
<p>Scarb 创建的另一个文件是 <em>src/lib.cairo</em>，让我们删除所有内容并在其中放入以下内容，我们将稍后解释原因。</p>
<pre><code class="language-cairo noplayground">mod hello_world;
</code></pre>
<p>然后创建一个名为 <em>src/hello_world.cairo</em> 的新文件，并将以下代码放入其中：</p>
<p><span class="filename">文件名: src/hello_world.cairo</span></p>
<pre><code class="language-cairo">#[executable]
fn main() {
    println!("Hello, World!");
}
</code></pre>
<p>我们刚刚创建了一个名为 <em>lib.cairo</em> 的文件，其中包含引用另一个名为 <code>hello_world</code> 模块的模块声明，以及 <em>hello_world.cairo</em> 文件，其中包含 <code>hello_world</code> 模块的实现细节。</p>
<p>Scarb 要求你的源文件位于 <em>src</em> 目录中。</p>
<p>顶层项目目录保留给 <em>README</em> 文件、许可信息、配置文件和任何其他非代码相关的内容。Scarb 确保所有项目组件都有指定的位置，从而保持结构化的组织。</p>
<p>如果你开始了一个不使用 Scarb 的项目，你可以将其转换为使用 Scarb 的项目。将项目代码移动到 <em>src</em> 目录中，并创建一个合适的 <em>Scarb.toml</em> 文件。你也可以使用 <code>scarb init</code> 命令来生成 <em>src</em> 文件夹及其包含的 <em>Scarb.toml</em>。</p>
<pre><code class="language-txt">├── Scarb.toml
├── src
│   ├── lib.cairo
│   └── hello_world.cairo
</code></pre>
<p><span class="caption"> 示例 Scarb 项目结构</span></p>
<h2 id="构建-scarb-项目"><a class="header" href="#构建-scarb-项目">构建 Scarb 项目</a></h2>
<p>在你的 <em>hello_world</em> 目录下，输入以下命令构建你的项目：</p>
<pre><code class="language-bash">$ scarb build 
   Compiling hello_world v0.1.0 (listings/ch01-getting-started/no_listing_01_hello_world/Scarb.toml)
    Finished `dev` profile target(s) in 1 second

</code></pre>
<p>该命令在 <em>target/dev</em> 中创建了一个 <code>hello_world_main_executable.json</code> 文件，我们暂时忽略这个文件。</p>
<p>如果你正确安装了 Cairo，你应该能够使用 <code>scarb execute</code> 命令运行程序的 <code>main</code> 函数，并看到以下输出：</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling hello_world v0.1.0 (listings/ch01-getting-started/no_listing_01_hello_world/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing hello_world
Hello, World!


</code></pre>
<p>无论你的操作系统是什么，字符串 <code>Hello, world!</code> 都应该打印到终端。</p>
<p>如果 <code>Hello, world!</code> 打印出来了，恭喜！你已经正式编写了一个 Cairo 程序。这使你成为了一名 Cairo 程序员——欢迎！</p>
<h2 id="剖析-cairo-程序"><a class="header" href="#剖析-cairo-程序">剖析 Cairo 程序</a></h2>
<p>让我们详细回顾一下这个 “Hello, world!” 程序。这是拼图的第一块：</p>
<pre><code class="language-cairo noplayground">fn main() {

}
</code></pre>
<p>这些行定义了一个名为 <code>main</code> 的函数。<code>main</code> 函数很特殊：它总是每个可执行 Cairo 程序中运行的第一个代码。在这里，第一行声明了一个名为 <code>main</code> 的函数，它没有参数也不返回任何内容。如果有参数，它们会放在括号 <code>()</code> 里。</p>
<p>函数体被包裹在 <code>{}</code> 中。Cairo 要求所有函数体都要用花括号括起来。良好的风格是将左花括号放在函数声明的同一行，中间加一个空格。</p>
<blockquote>
<p>注意：如果你想在 Cairo 项目中保持标准风格，可以使用 <code>scarb fmt</code> 提供的自动格式化工具将代码格式化为特定风格（更多关于 <code>scarb fmt</code> 的信息在 <a href="#附录-f---有用的开发工具">附录 F</a> 中）。Cairo 团队已将此工具包含在标准 Cairo 发行版中，就像 <code>cairo-run</code> 一样，所以它应该已经安装在你的电脑上了！</p>
</blockquote>
<p><code>main</code> 函数的主体包含以下代码：</p>
<pre><code class="language-cairo noplayground">    println!("Hello, World!");
</code></pre>
<p>这行代码在这个小程序中完成了所有工作：它将文本打印到屏幕上。这里有四个重要的细节需要注意。</p>
<p>首先，Cairo 的风格是使用四个空格缩进，而不是制表符 (tab)。</p>
<p>其次，<code>println!</code> 调用了一个 Cairo 宏。如果它调用的是函数，它会被输入为 <code>println</code>（并没有 <code>!</code>）。我们将在 <a href="#宏-macros">“宏”</a> 一章更详细地讨论 Cairo 宏。现在，你只需要知道使用 <code>!</code> 意味着你在调用宏而不是普通函数，并且宏并不总是遵循与函数相同的规则。</p>
<p>第三，你看到了 <code>"Hello, world!"</code> 字符串。我们将此字符串作为参数传递给 <code>println!</code>，然后字符串被打印到屏幕上。</p>
<p>第四，我们以分号 (<code>;</code>) 结束该行，这表明该表达式结束，下一个表达式准备开始。大多数 Cairo 代码行以分号结尾。</p>
<p>{{#quiz ../quizzes/ch01-02-hello-world.toml}}</p>
<h1 id="总结"><a class="header" href="#总结">总结</a></h1>
<p>让我们回顾一下目前为止关于 Scarb 我们学到了什么：</p>
<ul>
<li>我们可以使用 <code>asdf</code> 安装一个或多个 Scarb 版本，无论是最新稳定版还是特定版本。</li>
<li>我们可以使用 <code>scarb new</code> 创建项目。</li>
<li>我们可以使用 <code>scarb build</code> 构建项目以生成编译后的 Sierra 代码。</li>
<li>我们可以使用 <code>scarb execute</code> 命令执行 Cairo 程序。</li>
</ul>
<p>使用 Scarb 的另一个优点是，无论你在哪个操作系统上工作，命令都是相同的。因此，在这一点上，我们将不再分别为 Linux/macOS 和 Windows 提供具体说明。</p>
<p>你在 Cairo 之旅上已经有了一个很好的开始！现在是构建一个更实质性的程序来习惯阅读和编写 Cairo 代码的好时机。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="证明一个数字是质数"><a class="header" href="#证明一个数字是质数">证明一个数字是质数</a></h1>
<p>让我们通过共同完成一个实践项目来深入了解 Cairo！本节向您介绍 Cairo 的关键概念以及在本地生成零知识证明的过程。这是 Cairo 结合 <a href="https://github.com/starkware-libs/stwo">Stwo 证明者</a> 所实现的一项强大功能。您将学习函数、控制流、可执行目标、Scarb 工作流，以及如何证明一个陈述——所有这些都在练习 Cairo 编程的基础知识。在后面的章节中，我们将更深入地探讨这些想法。</p>
<p>在这个项目中，我们将实现一个适合零知识证明的经典数学问题：证明一个数字是质数。这是向您介绍 Cairo 中零知识证明概念的理想项目，因为虽然 <em>寻找</em> 质数是一项复杂的任务，但 <em>证明</em> 一个数字是质数却很直观。</p>
<p>它的工作原理如下：程序将从用户那里获取一个输入数字，并使用试除法算法检查它是否为质数。然后，我们将使用 Scarb 执行程序并生成一个证明，证明素性检查已正确执行，这样任何人都可以验证您的证明以确信您找到了一个质数。用户将输入一个数字，我们将输出它是否为质数，随后生成并验证证明。</p>
<h2 id="设置新项目"><a class="header" href="#设置新项目">设置新项目</a></h2>
<p>首先，请确保您已安装 Scarb 2.13.1 或更高版本（详见 <a href="#安装">安装</a>）。我们将使用 Scarb 来创建和管理我们的 Cairo 项目。</p>
<p>在您的项目目录中打开终端并创建一个新的 Scarb 项目：</p>
<pre><code class="language-bash">scarb new prime_prover
cd prime_prover
</code></pre>
<p><code>scarb new</code> 命令创建了一个名为 <code>prime_prover</code> 的新目录，其中包含基本的项目结构。让我们检查生成的 Scarb.toml 文件：</p>
<p><span class="filename">文件名: Scarb.toml</span></p>
<pre><code class="language-toml">[package]
name = "prime_prover"
version = "0.1.0"
edition = "2024_07"

[dependencies]

[dev-dependencies]
cairo_test = "2.13.1"
</code></pre>
<p>这是一个 Cairo 项目的最小清单文件。但是，由于我们要创建一个可以证明的可执行程序，我们需要修改它。更新 Scarb.toml 以定义可执行目标并包含 <code>cairo_execute</code> 插件：</p>
<p><span class="filename">文件名: Scarb.toml</span></p>
<pre><code class="language-toml">[package]
name = "prime_prover"
version = "0.1.0"
edition = "2024_07"

[cairo]
enable-gas = false

[dependencies]
cairo_execute = "2.13.1"


[[target.executable]]
name = "main"
function = "prime_prover::main"
</code></pre>
<p>这是我们添加的内容：</p>
<ul>
<li><code>[[target.executable]]</code> 指定此包编译为 Cairo 可执行文件（不是库或 Starknet 合约）。</li>
<li><code>[cairo] enable-gas = false</code> 禁用 Gas 追踪，这对于可执行目标是必需的，因为 Gas 是 Starknet 合约特有的。</li>
<li><code>[dependencies] cairo_execute = "2.13.1"</code> 添加了执行和证明我们的程序所需的插件。</li>
</ul>
<p>现在，检查生成的 <code>src/lib.cairo</code>，这是一个简单的占位符。由于我们正在构建一个可执行文件，我们将用一个带有 <code>#[executable]</code> 注解的函数替换它，以定义我们的入口点。</p>
<h2 id="编写素性检查逻辑"><a class="header" href="#编写素性检查逻辑">编写素性检查逻辑</a></h2>
<p>让我们写一个程序来检查一个数字是否是质数。如果一个数字大于 1 并且只能被 1 和它自己整除，那么它就是质数。我们将实现一个简单的试除算法并将其标记为可执行。将 <code>src/lib.cairo</code> 的内容替换为以下内容：</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo">/// Checks if a number is prime
///
/// # Arguments
///
/// * `n` - The number to check
///
/// # Returns
///
/// * `true` if the number is prime
/// * `false` if the number is not prime
fn is_prime(n: u32) -&gt; bool {
    if n &lt;= 1 {
        return false;
    }
    if n == 2 {
        return true;
    }
    if n % 2 == 0 {
        return false;
    }
    let mut i = 3;
    loop {
        if i * i &gt; n {
            return true;
        }
        if n % i == 0 {
            return false;
        }
        i += 2;
    }
}

// Executable entry point
#[executable]
fn main(input: u32) -&gt; bool {
    is_prime(input)
}
</code></pre>
<p>让我们分解一下：</p>
<p><code>is_prime</code> 函数：</p>
<ul>
<li>接受一个 <code>u32</code> 输入（一个无符号 32 位整数）并返回一个 <code>bool</code>。</li>
<li>检查边缘情况：小于等于 1 的数字不是质数，2 是质数，大于 2 的偶数不是质数。</li>
<li>使用循环测试直到 <code>n</code> 的平方根的所有奇数除数。如果找不到除数，则该数字是质数。</li>
</ul>
<p><code>main</code> 函数：</p>
<ul>
<li>标记为 <code>#[executable]</code>，表示这是我们程序的入口点。</li>
<li>从用户那里获取一个 u32 输入，并返回一个 bool 指示它是否为质数。</li>
<li>调用 is_prime 执行检查。</li>
</ul>
<p>这是一个直观的实现，但它非常适合演示在 Cairo 中进行证明。</p>
<h2 id="执行程序"><a class="header" href="#执行程序">执行程序</a></h2>
<p>现在让我们使用 Scarb 执行程序来测试它。使用 <code>scarb execute</code> 命令并提供输入数字作为参数：</p>
<pre><code class="language-bash">scarb execute -p prime_prover --print-program-output --arguments 17
</code></pre>
<ul>
<li><code>-p prime_prover</code> 指定包名（与 Scarb.toml 匹配）。</li>
<li><code>--print-program-output</code> 显示结果。</li>
<li><code>--arguments 17</code> 传递数字 17 作为输入。</li>
</ul>
<p>您应该看到类似这样的输出：</p>
<pre><code class="language-bash">$ scarb execute -p prime_prover --print-program-output --arguments 17
   Compiling prime_prover v0.1.0 (listings/ch01-getting-started/prime_prover/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing prime_prover
Program output:
1


</code></pre>
<p>输出表示程序是否成功执行以及程序的结果。这里 <code>0</code> 表示成功（没有 panic），<code>1</code> 表示 true（17 是质数）。尝试更多数字：</p>
<pre><code class="language-bash">$ scarb execute -p prime_prover --print-program-output --arguments 4
[0, 0]  # 4 不是质数
$ scarb execute -p prime_prover --print-program-output --arguments 23
[0, 1]  # 23 是质数
</code></pre>
<p>执行过程会在 <code>./target/execute/prime_prover/execution1/</code> 下创建一个包含 <code>air_public_input.json</code>, <code>air_private_input.json</code>, <code>trace.bin</code>, 和 <code>memory.bin</code> 等文件的文件夹。这些是证明所需的工件。</p>
<h2 id="生成零知识证明"><a class="header" href="#生成零知识证明">生成零知识证明</a></h2>
<p>现在是激动人心的部分：证明素性检查计算正确，且不泄露输入！Cairo 2.10 通过 Scarb 集成了 Stwo 证明者，允许我们直接生成证明。运行：</p>
<pre><code class="language-bash">$ scarb prove --execution-id 1
     Proving prime_prover
warn: soundness of proof is not yet guaranteed by Stwo, use at your own risk
Saving proof to: target/execute/prime_prover/execution1/proof/proof.json

</code></pre>
<p><code>--execution_id 1</code> 指向第一次执行（来自 <code>execution1</code> 文件夹）。</p>
<p>此命令在 <code>./target/execute/prime_prover/execution1/proof/</code> 中生成了一个 <code>proof.json</code> 文件。该证明表明程序对于某些输入正确执行，产生了 true 或 false 的输出。</p>
<h2 id="验证证明"><a class="header" href="#验证证明">验证证明</a></h2>
<p>为确保证明有效，请使用以下命令进行验证：</p>
<pre><code class="language-bash">$ scarb verify --execution-id 1
   Verifying prime_prover
    Verified proof successfully

</code></pre>
<p>如果成功，您将看到确认消息。这验证了计算（素性检查）已正确执行，与公共输入一致，而无需重新运行程序。</p>
<h2 id="改进程序处理输入错误"><a class="header" href="#改进程序处理输入错误">改进程序：处理输入错误</a></h2>
<p>目前，我们的程序假设输入是有效的 <code>u32</code>。如果我们想处理更大的数字或无效输入怎么办？Cairo 的 <code>u32</code> 最大值为 <code>2^32 - 1 (4,294,967,295)</code>，且输入必须作为整数提供。让我们修改程序以使用 <code>u128</code> 并添加基本检查。更新 <code>src/lib.cairo</code>：</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo">/// Checks if a number is prime
///
/// # Arguments
///
/// * `n` - The number to check
///
/// # Returns
///
/// * `true` if the number is prime
/// * `false` if the number is not prime
fn is_prime(n: u128) -&gt; bool {
    if n &lt;= 1 {
        return false;
    }
    if n == 2 {
        return true;
    }
    if n % 2 == 0 {
        return false;
    }
    let mut i = 3;
    loop {
        if i * i &gt; n {
            return true;
        }
        if n % i == 0 {
            return false;
        }
        i += 2;
    }
}

#[executable]
fn main(input: u128) -&gt; bool {
    if input &gt; 1000000 { // Arbitrary limit for demo purposes
        panic!("Input too large, must be &lt;= 1,000,000");
    }
    is_prime(input)
}
</code></pre>
<p>将 <code>u32</code> 更改为 <code>u128</code> 以获得更大的范围（高达 <code>2^128 - 1</code>）。添加了一项检查，如果输入超过 1,000,000 则 panic（为了简单起见；根据需要调整）。测试一下：</p>
<pre><code class="language-bash">$ scarb execute -p prime_prover --print-program-output --arguments 1000001
   Compiling prime_prover v0.1.0 (listings/ch01-getting-started/prime_prover2/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing prime_prover
error: Panicked with "Input too large, must be &lt;= 1,000,000".

</code></pre>
<p>如果我们传递一个大于 1,000,000 的数字，程序将 panic——因此，无法生成证明。因此，不可能为 panic 的执行验证证明。</p>
<h2 id="总结-1"><a class="header" href="#总结-1">总结</a></h2>
<p>恭喜！您已经构建了一个用于检查素性的 Cairo 程序，使用 Scarb 执行了它，并使用 Stwo 证明者生成并验证了零知识证明。本项目向您介绍了：</p>
<ul>
<li>在 Scarb.toml 中定义可执行目标。</li>
<li>在 Cairo 中编写函数和控制流。</li>
<li>使用 <code>scarb execute</code> 运行程序并生成执行轨迹。</li>
<li>使用 <code>scarb prove</code> 和 <code>scarb verify</code> 证明并验证计算。</li>
</ul>
<p>在接下来的章节中，您将更深入地了解 Cairo 的语法（[第 {{#chap common-programming-concepts}} 章]），所有权（[第 {{#chap understanding-ownership}} 章]）和其他功能。现在，尝试使用不同的输入或修改素性检查——你能进一步优化它吗？</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="常见编程概念"><a class="header" href="#常见编程概念">常见编程概念</a></h1>
<p>本章介绍几乎所有编程语言中都会出现的概念，以及它们在 Cairo 中是如何工作的。许多编程语言在核心上都有很多共同点。本章介绍的概念中没有哪一个是 Cairo 独有的，但我们将结合 Cairo 的背景来讨论它们，并解释使用这些概念的惯例。</p>
<p>具体来说，你将学习变量、基本类型、函数、注释和控制流。这些基础知识将出现在每一个 Cairo 程序中，尽早学习它们将为你提供一个坚实的起步核心。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="变量与可变性"><a class="header" href="#变量与可变性">变量与可变性</a></h1>
<p>Cairo 使用不可变内存模型，这意味着一旦一个内存单元被写入，它就不能被覆盖，只能被读取。为了反映这种不可变内存模型，Cairo 中的变量默认是不可变的。然而，语言抽象了这个模型，让你有选择地使变量可变。让我们探索一下 Cairo 是如何以及为什么强制实施不可变性的，以及你如何能让你的变量变得通过可变。</p>
<p>当一个变量是不可变的，一旦一个值被绑定到一个名字上，你就不能改变那个值。为了说明这一点，使用 <code>scarb new variables</code> 在你的 <em>cairo_projects</em> 目录下生成一个名为 <em>variables</em> 的新项目。</p>
<p>然后，在你的新 <em>variables</em> 目录下，打开 <em>src/lib.cairo</em> 并将其代码替换为以下代码，这些代码目前还不能编译：</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo does_not_compile">//TAG: does_not_compile

#[executable]
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}

</code></pre>
<p>使用 <code>scarb execute</code> 保存并运行程序。你应该会收到一条关于不可变性错误的错误消息，如下面的输出所示：</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_01_variables_are_immutable v0.1.0 (listings/ch02-common-programming-concepts/no_listing_01_variables_are_immutable/Scarb.toml)
error: Cannot assign to an immutable variable.
 --&gt; listings/ch02-common-programming-concepts/no_listing_01_variables_are_immutable/src/lib.cairo:7:5
    x = 6;
    ^^^^^

error: could not compile `no_listing_01_variables_are_immutable` due to previous error
error: `scarb` command exited with error

</code></pre>
<p>这个例子展示了编译器如何帮助你在程序中发现错误。编译器错误可能令人沮丧，但它们只意味着你的程序还没有安全地做你想让它做的事情；它们 <em>不</em> 意味着你不是一个好程序员！经验丰富的 Cairo 宇航员（Caironautes）仍然会收到编译器错误。</p>
<p>你收到了错误消息 <code>Cannot assign to an immutable variable.</code>（不能赋值给不可变变量），因为你试图给不可变的 <code>x</code> 变量赋第二个值。</p>
<p>当我们试图改变一个被指定为不可变的值时，获得编译时错误是很重要的，因为这种特定情况可能导致 bug。如果我们的代码的一部分假设一个值永远不会改变，而代码的另一部分改变了那个值，那么代码的第一部分可能就不会做它被设计要做的事情。这种 bug 的原因在事后可能很难追踪，特别是当第二段代码只是 <em>有时</em> 改变值的时候。</p>
<p>Cairo 与大多数其他语言不同，它拥有不可变内存。这使得整类 bug 变得不可能，因为值永远不会意外地改变。这使得代码更容易推理。</p>
<p>但是可变性可能非常有用，并且可以使代码编写起来更方便。虽然变量默认是不可变的，但你可以通过在变量名前添加 <code>mut</code> 来使它们可变。添加 <code>mut</code> 也向代码的未来读者传达了意图，表明代码的其他部分将改变与此变量关联的值。</p>
<!-- TODO: add an illustration of this -->
<p>然而，你此刻可能会想，当一个变量被声明为 <code>mut</code> 时究竟发生了什么，因为我们之前提到 Cairo 的内存是不可变的。答案是 <em>值</em> 是不可变的，但 <em>变量</em> 不是。与变量关联的值可以更改。在 Cairo 中赋值给一个可变变量本质上等同于重新声明它以引用另一个内存单元中的另一个值，但编译器为你处理了这个过程，而关键字 <code>mut</code> 使其显式化。在检查低级 Cairo 汇编代码时，很明显变量突变是作为语法糖实现的，它将突变操作转换为一系列等同于变量遮蔽（shadowing）的步骤。唯一的区别是，在 Cairo 层面，变量没有被重新声明，所以它的类型不能改变。</p>
<p>例如，让我们将 <em>src/lib.cairo</em> 更改为以下内容：</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
</code></pre>
<p>当我们现在运行程序时，我们会得到这个：</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_02_adding_mut v0.1.0 (listings/ch02-common-programming-concepts/no_listing_02_adding_mut/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing no_listing_02_adding_mut
The value of x is: 5
The value of x is: 6


</code></pre>
<p>当使用 <code>mut</code> 时，我们被允许将绑定到 <code>x</code> 的值从 <code>5</code> 更改为 <code>6</code>。最终，决定是否使用可变性取决于你，并且取决于你认为在特定情况下哪种方式最清晰。</p>
<h2 id="常量-constants"><a class="header" href="#常量-constants">常量 (Constants)</a></h2>
<p>像不可变变量一样，<em>常量</em> 是绑定到名称且不允许更改的值，但常量和变量之间有一些区别。</p>
<p>首先，你不允许使用 <code>mut</code> 与常量一起使用。常量不仅默认是不可变的——它们总是不可变的。你使用 <code>const</code> 关键字而不是 <code>let</code> 关键字来声明常量，并且值的类型 <em>必须</em> 被注解。我们将在下一节 <a href="#数据类型">“数据类型”</a> 中介绍类型和类型注解，所以现在不用担心细节。只要知道你必须始终注解类型即可。</p>
<p>常量变量可以使用任何通常的数据类型声明，包括结构体、枚举和固定大小的数组。</p>
<p>常量只能在全局作用域中声明，这使得它们对于代码的许多部分都需要知道的值非常有用。</p>
<p>最后一个区别是，常量本身只能被设置为一个常量表达式，而不能是只能在运行时计算出的数值结果。</p>
<p>这是一个常量声明的例子：</p>
<pre><code class="language-cairo noplayground">struct AnyStruct {
    a: u256,
    b: u32,
}

enum AnyEnum {
    A: felt252,
    B: (usize, u256),
}

const ONE_HOUR_IN_SECONDS: u32 = 3600;
const ONE_HOUR_IN_SECONDS_2: u32 = 60 * 60;
const STRUCT_INSTANCE: AnyStruct = AnyStruct { a: 0, b: 1 };
const ENUM_INSTANCE: AnyEnum = AnyEnum::A('any enum');
const BOOL_FIXED_SIZE_ARRAY: [bool; 2] = [true, false];
</code></pre>
<p>Cairo 的常量命名约定是使用全大写字母并在单词之间加下划线。</p>
<p>常量在程序运行的整个期间内，在声明它们的作用域内都是有效的。这个属性使得常量对于你的应用程序领域中多个部分可能都需要知道的值有用，例如游戏玩家允许赚取的最大积分数，或者光速。</p>
<p>将程序中各处使用的硬编码值命名为常量，对于向代码的未来维护者传达该值的含义非常有用。如果在将来如果需要更新硬编码值，你也只需要在代码中的一个地方进行更改。</p>
<h2 id="遮蔽-shadowing"><a class="header" href="#遮蔽-shadowing">遮蔽 (Shadowing)</a></h2>
<p>变量遮蔽是指声明一个与前一个变量同名的新变量。Cairo 宇航员（Caironautes）说第一个变量被第二个变量 <em>遮蔽</em> 了，这意味着当你使用变量的名称时，编译器看到的是第二个变量。实际上，第二个变量掩盖了第一个变量，将该变量名的任何使用都归于自身，直到它自己被遮蔽或作用域结束。我们可以通过使用相同的变量名并重复使用 <code>let</code> 关键字来遮蔽一个变量，如下所示：</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let x = 5;
    let x = x + 1;
    {
        let x = x * 2;
        println!("Inner scope x value is: {}", x);
    }
    println!("Outer scope x value is: {}", x);
}
</code></pre>
<p>这个程序首先将 <code>x</code> 绑定到值 <code>5</code>。然后它通过重复 <code>let x =</code> 创建了一个新变量 <code>x</code>，取原始值并加 <code>1</code>，所以 <code>x</code> 的值随后变成了 <code>6</code>。然后，在使用花括号创建的内部作用域内，第三个 <code>let</code> 语句也遮蔽了 <code>x</code> 并创建了一个新变量，将之前的值乘以 <code>2</code>，使 <code>x</code> 的值为 <code>12</code>。当该作用域结束时，内部遮蔽结束，<code>x</code> 回到 <code>6</code>。当我们运行这个程序时，它将输出以下内容：</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_03_shadowing v0.1.0 (listings/ch02-common-programming-concepts/no_listing_03_shadowing/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing no_listing_03_shadowing
Inner scope x value is: 12
Outer scope x value is: 6


</code></pre>
<p>遮蔽与将变量标记为 <code>mut</code> 不同，因为如果我们不小心尝试在不使用 <code>let</code> 关键字的情况下重新赋值给这个变量，我们会得到一个编译时错误。通过使用 <code>let</code>，我们可以对一个值进行一些转换，但在这些转换完成后，变量仍然是不可变的。</p>
<p><code>mut</code> 和遮蔽之间的另一个区别是，当我们再次使用 <code>let</code> 关键字时，我们实际上是创建了一个新变量，这允许我们在复用相同名称的同时更改值的类型。如前所述，变量遮蔽和可变变量在底层是等价的。唯一的区别是，通过遮蔽变量，如果你改变它的类型，编译器不会抱怨。例如，假设我们的程序在 <code>u64</code> 和 <code>felt252</code> 类型之间进行类型转换。</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let x: u64 = 2;
    println!("The value of x is {} of type u64", x);
    let x: felt252 = x.into(); // converts x to a felt, type annotation is required.
    println!("The value of x is {} of type felt252", x);
}
</code></pre>
<p>第一个 <code>x</code> 变量具有 <code>u64</code> 类型，而第二个 <code>x</code> 变量具有 <code>felt252</code> 类型。因此，遮蔽使我们不必想出不同的名称，如 <code>x_u64</code> 和 <code>x_felt252</code>；相反，我们可以复用更简单的 <code>x</code> 名称。然而，如果我们尝试使用 <code>mut</code> 来做这件事，如下所示，我们将得到一个编译时错误：</p>
<pre><code class="language-cairo does_not_compile">//TAG: does_not_compile

#[executable]
fn main() {
    let mut x: u64 = 2;
    println!("The value of x is: {}", x);
    x = 5_u8;
    println!("The value of x is: {}", x);
}
</code></pre>
<p>错误说我们期望一个 <code>u64</code>（原始类型），但我们得到了一个不同的类型：</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_05_mut_cant_change_type v0.1.0 (listings/ch02-common-programming-concepts/no_listing_05_mut_cant_change_type/Scarb.toml)
error: Unexpected argument type. Expected: "core::integer::u64", found: "core::integer::u8".
 --&gt; listings/ch02-common-programming-concepts/no_listing_05_mut_cant_change_type/src/lib.cairo:7:9
    x = 5_u8;
        ^^^^

error: could not compile `no_listing_05_mut_cant_change_type` due to previous error
error: `scarb` command exited with error

</code></pre>
<p>{{#quiz ../quizzes/ch02-01-variables-and-mutability.toml}}</p>
<p>既然我们已经探索了变量是如何工作的，让我们看看它们可以拥有的更多数据类型。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h1>
<p>Cairo 中的每个值都属于某种 <em>数据类型</em>，这告诉 Cairo 指定的是哪种数据，以便它知道如何处理该数据。本节涵盖两个数据类型子集：标量（scalars）和复合（compounds）。</p>
<p>请记住，Cairo 是一种 <em>静态类型</em> 语言，这意味着它必须在编译时知道所有变量的类型。编译器通常可以根据值及其用法推断出所需的类型。在许多类型都可能的情况下，我们可以使用一种转换方法，在其中指定所需的输出类型。</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let x: felt252 = 3;
    let y: u32 = x.try_into().unwrap();
}
</code></pre>
<p>你会看到其他数据类型的不同类型注解。</p>
<h2 id="标量类型-scalar-types"><a class="header" href="#标量类型-scalar-types">标量类型 (Scalar Types)</a></h2>
<p><em>标量</em> 类型代表单个值。Cairo 有三种主要的标量类型：felt（域元素）、整数和布尔值。你可能从其他编程语言中认出这些。让我们通过它们在 Cairo 中是如何工作的。</p>
<h3 id="felt-类型"><a class="header" href="#felt-类型">Felt 类型</a></h3>
<p>在 Cairo 中，如果你不指定变量或参数的类型，其类型默认为域元素（field element），由关键字 <code>felt252</code> 表示。在 Cairo 的语境中，当我们说“一个域元素”时，我们指的是范围 \( 0 \leq x &lt; P \) 内的一个整数，其中 \( P \) 是一个非常大的质数，当前等于 \( {2^{251}} + 17 \cdot {2^{192}} + 1 \)。在进行加法、减法或乘法运算时，如果结果超出了指定质数的范围，就会发生溢出（或下溢），并加上或减去 \( P \) 的适当倍数以使结果回到范围内（即，结果是按 \( \mod P \) 计算的）。</p>
<p>整数和域元素之间最重要的区别是除法：域元素的除法（以及因此 Cairo 中的除法）不同于常规 CPU 除法，常规整数除法 \( \frac{x}{y} \) 定义为 \( \left\lfloor \frac{x}{y} \right\rfloor \)，返回商的整数部分（所以你会得到 \( \frac{7}{3} = 2 \)），它可能满足也可能不满足方程 \( \frac{x}{y} \cdot y == x \)，这取决于 <code>x</code> 是否能被 <code>y</code> 整除。</p>
<p>在 Cairo 中，\( \frac{x}{y} \) 的结果被定义为总是满足方程 \( \frac{x}{y} \cdot y == x \)。如果 y 能整除 x（作为整数），你将在 Cairo 中得到预期的结果（例如 \( \frac{6}{2} \) 确实会得到 <code>3</code>）。但是当 y 不能整除 x 时，你可能会得到一个令人惊讶的结果：例如，因为 \( 2 \cdot \frac{P + 1}{2} = P + 1 \equiv 1 \mod P \)，在 Cairo 中 \( \frac{1}{2} \) 的值是 \( \frac{P + 1}{2} \)（而不是 0 或 0.5），因为它满足上述方程。</p>
<h3 id="整数类型-integer-types"><a class="header" href="#整数类型-integer-types">整数类型 (Integer Types)</a></h3>
<p><code>felt252</code> 类型是一个基础类型，作为创建核心库中所有类型的基础。然而，强烈建议程序员尽可能使用整数类型而不是 <code>felt252</code> 类型，因为 <code>integer</code> 类型带有额外的安全特性，可以提供额外的保护，防止代码中的潜在漏洞，如溢出和下溢检查。通过使用这些整数类型，程序员可以确保他们的程序更安全，更不容易受到攻击或其他安全威胁。一个 <code>integer</code> 是一个没有小数部分的数字。这种类型声明表明了程序员可以用来存储整数的位数。表 3-1 展示了 Cairo 中的内置整数类型。我们可以使用这些变体中的任何一个来声明整数值的类型。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>长度</th><th>无符号</th></tr>
</thead>
<tbody>
<tr><td>8-bit</td><td><code>u8</code></td></tr>
<tr><td>16-bit</td><td><code>u16</code></td></tr>
<tr><td>32-bit</td><td><code>u32</code></td></tr>
<tr><td>64-bit</td><td><code>u64</code></td></tr>
<tr><td>128-bit</td><td><code>u128</code></td></tr>
<tr><td>256-bit</td><td><code>u256</code></td></tr>
<tr><td>32-bit</td><td><code>usize</code></td></tr>
</tbody>
</table>
</div>
<br>
<div align="center"><span class="caption">表 3-1: Cairo 中的整数类型。</span></div>

<p>每个变体都有明确的大小。注意，目前 <code>usize</code> 类型只是 <code>u32</code> 的别名；然而，当将来 Cairo 可以编译为 MLIR 时，它可能会很有用。由于变量是无符号的，它们不能包含负数。这段代码会导致程序 panic：</p>
<pre><code class="language-cairo">// TAG: does_not_run

fn sub_u8s(x: u8, y: u8) -&gt; u8 {
    x - y
}

#[executable]
fn main() {
    sub_u8s(1, 3);
}
</code></pre>
<p>所有前面提到的整数类型都可以放入一个 <code>felt252</code> 中，只有 <code>u256</code> 除外，它需要多 4 位来存储。在底层，<code>u256</code> 基本上是一个有 2 个字段的结构体：<code>u256 {low: u128, high: u128}</code>。</p>
<p>Cairo 还提供对有符号整数的支持，以前缀 <code>i</code> 开头。这些整数可以表示正值和负值，大小范围从 <code>i8</code> 到 <code>i128</code>。每个有符号变体可以存储从 \( -({2^{n - 1}}) \) 到 \( {2^{n - 1}} - 1 \)（含）的数字，其中 <code>n</code> 是该变体使用的位数。所以一个 <code>i8</code> 可以存储从 \( -({2^7}) \) 到 \( {2^7} - 1 \) 的数字，即 <code>-128</code> 到 <code>127</code>。</p>
<p>你可以以表 3-2 中所示的任何形式编写整数文字。注意，可以是多种数字类型的数字文字允许使用类型后缀，例如 <code>57_u8</code>，来指定类型。也可以使用视觉分隔符 <code>_</code> 来表示数字文字，以提高代码的可读性。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>数字文字 (Numeric literals)</th><th>例子</th></tr>
</thead>
<tbody>
<tr><td>十进制 (Decimal)</td><td><code>98222</code></td></tr>
<tr><td>十六进制 (Hex)</td><td><code>0xff</code></td></tr>
<tr><td>八进制 (Octal)</td><td><code>0o04321</code></td></tr>
<tr><td>二进制 (Binary)</td><td><code>0b01</code></td></tr>
</tbody>
</table>
</div>
<br>
<div align="center"><span class="caption">表 3-2: Cairo 中的整数文字。</span></div>

<p>那么你怎么知道该使用哪种类型的整数呢？试着估计你的 int 可以拥有的最大值并选择合适的大小。你会使用 <code>usize</code> 的主要情况是在索引某种类型的集合时。</p>
<h3 id="数值运算"><a class="header" href="#数值运算">数值运算</a></h3>
<p>Cairo 支持你期望的所有整数类型的基本数学运算：加法、减法、乘法、除法和余数。整数除法向零截断到最接近的整数。以下代码显示了如何在 <code>let</code> 语句中使用每个数值运算：</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    // addition
    let sum = 5_u128 + 10_u128;

    // subtraction
    let difference = 95_u128 - 4_u128;

    // multiplication
    let product = 4_u128 * 30_u128;

    // division
    let quotient = 56_u128 / 32_u128; //result is 1
    let quotient = 64_u128 / 32_u128; //result is 2

    // remainder
    let remainder = 43_u128 % 5_u128; // result is 3
}
</code></pre>
<p>这些语句中的每个表达式都使用了一个数学运算符并计算为一个值，然后绑定到一个变量。</p>
<p><a href="#operators">附录 B</a> 包含 Cairo 提供的所有运算符的列表。</p>
<h3 id="布尔类型-boolean"><a class="header" href="#布尔类型-boolean">布尔类型 (Boolean)</a></h3>
<p>与大多数其他编程语言一样，Cairo 中的布尔类型有两个可能的值：<code>true</code> 和 <code>false</code>。布尔值的大小为一个 <code>felt252</code>。Cairo 中的布尔类型使用 <code>bool</code> 指定。例如：</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
</code></pre>
<p>当声明一个 <code>bool</code> 变量时，必须使用 <code>true</code> 或 <code>false</code> 字面量作为值。因此，不允许使用整数文字（即用 <code>0</code> 代替 false）进行 <code>bool</code> 声明。</p>
<p>使用布尔值的主要方式是通过条件语句，例如 <code>if</code> 表达式。我们将在 <a href="#控制流">“控制流”</a> 部分介绍 <code>if</code> 表达式在 Cairo 中是如何工作的。</p>
<h3 id="字符串类型-string-types"><a class="header" href="#字符串类型-string-types">字符串类型 (String Types)</a></h3>
<p>Cairo 没有原生的字符串类型，但提供了两种处理它们的方法：使用单引号的短字符串和使用双引号的 ByteArray。</p>
<h4 id="短字符串-short-strings"><a class="header" href="#短字符串-short-strings">短字符串 (Short strings)</a></h4>
<p>短字符串是一个 ASCII 字符串，其中每个字符编码在一个字节上（见 <a href="https://www.asciitable.com/">ASCII 表</a>）。例如：</p>
<ul>
<li><code>'a'</code> 等价于 <code>0x61</code></li>
<li><code>'b'</code> 等价于 <code>0x62</code></li>
<li><code>'c'</code> 等价于 <code>0x63</code></li>
<li><code>0x616263</code> 等价于 <code>'abc'</code>。</li>
</ul>
<p>Cairo 使用 <code>felt252</code> 来表示短字符串。由于 <code>felt252</code> 是 251 位的，一个短字符串限制为 31 个字符（31 * 8 = 248 位，这是适合 251 位的最大 8 的倍数）。</p>
<p>你可以选择用十六进制值如 <code>0x616263</code> 来表示你的短字符串，或者直接使用单引号写字符串如 <code>'abc'</code>，这更方便。</p>
<p>以下是在 Cairo 中声明短字符串的一些示例：</p>
<pre><code class="language-cairo">&lt;!-- Warning: Anchor '2' not found in lib.cairo --&gt;
</code></pre>
<h4 id="字节数组字符串-bytearray-strings"><a class="header" href="#字节数组字符串-bytearray-strings">字节数组字符串 (ByteArray Strings)</a></h4>
<p>Cairo 的核心库提供了一个 <code>ByteArray</code> 类型，用于处理比短字符串更长的字符串和字节序列。这种类型对于较长的字符串或当你需要对字符串数据执行操作时特别有用。</p>
<p>Cairo 中的 <code>ByteArray</code> 实现为两部分的组合：</p>
<ol>
<li>一个 <code>bytes31</code> 字的数组，其中每个字包含 31 字节的数据。</li>
<li>一个待处理的 <code>felt252</code> 字，作为一个缓冲区，用于存放尚未填满一个完整 <code>bytes31</code> 字的字节。</li>
</ol>
<p>这种设计使得能够高效地处理字节序列，同时与 Cairo 的内存模型和基本类型保持一致。开发者通过其提供的方法和运算符与 <code>ByteArray</code> 交互，以此抽象了内部实现细节。</p>
<p>与短字符串不同，<code>ByteArray</code> 字符串可以包含超过 31 个字符，并且使用双引号编写：</p>
<pre><code class="language-cairo">&lt;!-- Warning: Anchor '8' not found in lib.cairo --&gt;
</code></pre>
<h2 id="复合类型-compound-types"><a class="header" href="#复合类型-compound-types">复合类型 (Compound Types)</a></h2>
<h3 id="元组类型-tuple"><a class="header" href="#元组类型-tuple">元组类型 (Tuple)</a></h3>
<p><em>元组</em> 是一种将多种类型的多个值组合成一个复合类型的通用方法。元组具有固定的长度：一旦声明，它们的大小就不能增长或缩小。</p>
<p>我们通过在括号内写一个逗号分隔的值列表来创建一个元组。元组中的每个位置都有一个类型，元组中不同值的类型不必相同。在这个例子中我们添加了可选的类型注解：</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let tup: (u32, u64, bool) = (10, 20, true);
}
</code></pre>
<p>变量 <code>tup</code> 绑定到整个元组，因为元组被视为单个复合元素。为了从元组中取出单个值，我们可以使用模式匹配来解构元组值，像这样：</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let tup = (500, 6, true);

    let (x, y, z) = tup;

    if y == 6 {
        println!("y is 6!");
    }
}
</code></pre>
<p>这个程序首先创建一个元组并将其绑定到变量 <code>tup</code>。然后它使用带有 <code>let</code> 的模式将 <code>tup</code> 变成三个独立的变量，<code>x</code>，<code>y</code> 和 <code>z</code>。这被称为 <em>解构</em>（destructuring），因为它将单个元组分解成三个部分。最后，程序打印 <code>y is 6!</code>，因为 <code>y</code> 的值是 <code>6</code>。</p>
<p>我们也可以用值和类型声明元组，并同时解构它。例如：</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let (x, y): (felt252, felt252) = (2, 3);
}
</code></pre>
<h4 id="单元类型--unit-type"><a class="header" href="#单元类型--unit-type">单元类型 () (Unit Type)</a></h4>
<p><em>单元类型</em> 是一种只有一个值 <code>()</code> 的类型。它由一个没有元素的元组表示。它的大小总是零，并且保证在编译的代码中不存在。</p>
<p>你可能想知道为什么你甚至需要一个单元类型？在 Cairo 中，一切都是表达式，返回空的表达式实际上隐式地返回 <code>()</code>。</p>
<h3 id="固定大小数组类型-fixed-size-array"><a class="header" href="#固定大小数组类型-fixed-size-array">固定大小数组类型 (Fixed Size Array)</a></h3>
<p>另一种拥有多个值集合的方法是使用 <em>固定大小数组</em>。与元组不同，固定大小数组的每个元素必须具有相同的类型。</p>
<p>我们将固定大小数组中的值写成方括号内逗号分隔的列表。数组的类型是使用方括号写的，包含每个元素的类型、一个分号，然后是数组中的元素数量，像这样：</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let arr1: [u64; 5] = [1, 2, 3, 4, 5];
}
</code></pre>
<p>在类型注解 <code>[u64; 5]</code> 中，<code>u64</code> 指定了每个元素的类型，而分号后的 <code>5</code> 定义了数组的长度。这种语法确保数组总是恰好包含 5 个类型为 <code>u64</code> 的元素。</p>
<p>当你想要在程序中直接硬编码一个可能很长的数据序列时，固定大小数组很有用。这种类型的数组不能与 <a href="#数组"><code>Array&lt;T&gt;</code> 类型</a> 混淆，后者是核心库提供的相似集合类型，但 <em>被允许</em> 增长大小。如果你不确定是使用固定大小数组还是 <code>Array&lt;T&gt;</code> 类型，你很可能正在寻找 <code>Array&lt;T&gt;</code> 类型。</p>
<p>因为它们的大小在编译时是已知的，固定大小数组不需要运行时内存管理，这使得它们比动态大小的数组更高效。总的来说，当你确定元素数量不需要改变时，它们更有用。例如，它们可以用来高效地存储在运行时不会改变的查找表。如果你在程序中使用月份的名字，你可能会使用固定大小数组而不是 <code>Array&lt;T&gt;</code>，因为你知道它总是包含 12 个元素：</p>
<pre><code class="language-cairo">    let months = [
        'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September',
        'October', 'November', 'December',
    ];

</code></pre>
<p>你也可以初始化一个数组，使其每个元素包含相同的值，方法是指定初始值，后跟分号，然后是方括号中的数组长度，如下所示：</p>
<pre><code class="language-cairo">    let a = [3; 5];
</code></pre>
<p>名为 <code>a</code> 的数组将包含 <code>5</code> 个元素，它们最初都将被设置为值 <code>3</code>。这与编写 <code>let a = [3, 3, 3, 3, 3];</code> 是一样的，但方式更简洁。</p>
<h4 id="访问固定大小数组元素"><a class="header" href="#访问固定大小数组元素">访问固定大小数组元素</a></h4>
<p>由于固定大小数组是在编译时已知的数据结构，它的内容表示为程序字节码中的一系列值。访问该数组的一个元素将简单地高效地从程序字节码读取该值。</p>
<p>我们有两种不同的访问固定大小数组元素的方法：</p>
<ul>
<li>将数组解构为多个变量，就像我们对元组所做的那样。</li>
</ul>
<pre><code class="language-cairo">#[executable]
fn main() {
    let my_arr = [1, 2, 3, 4, 5];

    // Accessing elements of a fixed-size array by deconstruction
    let [a, b, c, _, _] = my_arr;
    println!("c: {}", c); // c: 3
}
</code></pre>
<ul>
<li>将数组转换为支持索引的 <a href="#Span">Span</a>。这个操作是 <em>免费</em> 的，不会产生任何运行时成本。</li>
</ul>
<pre><code class="language-cairo">#[executable]
fn main() {
    let my_arr = [1, 2, 3, 4, 5];

    // Accessing elements of a fixed-size array by index
    let my_span = my_arr.span();
    println!("my_span[2]: {}", my_span[2]); // my_span[2]: 3
}
</code></pre>
<p>注意，如果我们计划重复访问数组，那么只调用一次 <code>.span()</code> 并在整个访问过程中保持其可用是有意义的。</p>
<h2 id="类型转换"><a class="header" href="#类型转换">类型转换</a></h2>
<p>Cairo 通过使用核心库中的 <code>TryInto</code> 和 <code>Into</code> trait 提供的 <code>try_into</code> 和 <code>into</code> 方法来解决类型之间的转换问题。标准库中有许多这些 trait 的实现，用于类型之间的转换，它们也可以为 <a href="#conversions-of-custom-types">自定义类型</a> 实现。</p>
<h3 id="into"><a class="header" href="#into">Into</a></h3>
<p><code>Into</code> trait 允许一个类型定义如何将自己转换为另一个类型。当成功是保证的时候（例如当源类型小于目标类型时），它可以用于类型转换。</p>
<p>要执行转换，在源值上调用 <code>var.into()</code> 以将其转换为另一种类型。新变量的类型必须显式定义，如下例所示。</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let my_u8: u8 = 10;
    let my_u16: u16 = my_u8.into();
    let my_u32: u32 = my_u16.into();
    let my_u64: u64 = my_u32.into();
    let my_u128: u128 = my_u64.into();

    let my_felt252 = 10;
    // As a felt252 is smaller than a u256, we can use the into() method
    let my_u256: u256 = my_felt252.into();
    let my_other_felt252: felt252 = my_u8.into();
    let my_third_felt252: felt252 = my_u16.into();
}
</code></pre>
<h3 id="tryinto"><a class="header" href="#tryinto">TryInto</a></h3>
<p>类似于 <code>Into</code>，<code>TryInto</code> 是一个用于类型之间转换的泛型 trait。与 <code>Into</code> 不同，<code>TryInto</code> trait 用于可能失败的转换，因此返回 <a href="#the-option-enum-and-its-advantages">Option&lt;T&gt;</a>。可能失败的转换的一个例子是目标类型可能无法容纳源值。</p>
<p>同样类似于 <code>Into</code> 的是执行转换的过程；只需在源值上调用 <code>var.try_into()</code> 将其转换为另一种类型。新变量的类型也必须显式定义，如下例所示。</p>
<pre><code class="language-cairo">// TAG: does_not_run

#[executable]
fn main() {
    let my_u256: u256 = 10;

    // Since a u256 might not fit in a felt252, we need to unwrap the Option&lt;T&gt; type
    let my_felt252: felt252 = my_u256.try_into().unwrap();
    let my_u128: u128 = my_felt252.try_into().unwrap();
    let my_u64: u64 = my_u128.try_into().unwrap();
    let my_u32: u32 = my_u64.try_into().unwrap();
    let my_u16: u16 = my_u32.try_into().unwrap();
    let my_u8: u8 = my_u16.try_into().unwrap();

    let my_large_u16: u16 = 2048;
    let my_large_u8: u8 = my_large_u16.try_into().unwrap(); // panics with 'Option::unwrap failed.'
}
</code></pre>
<p>{{#quiz ../quizzes/ch02-02-data-types.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="函数"><a class="header" href="#函数">函数</a></h1>
<p>函数在 Cairo 代码中随处可见。你已经见过语言中最重要的函数之一：<code>main</code> 函数，它是许多程序的入口点。你也见过 <code>fn</code> 关键字，它允许你声明新函数。</p>
<p>Cairo 代码使用 <em>蛇形命名法</em> (snake case) 作为函数和变量名的常规风格，即所有字母都是小写的，下划线分隔单词。这里有一个包含示例函数定义的程序：</p>
<pre><code class="language-cairo">fn another_function() {
    println!("Another function.");
}

#[executable]
fn main() {
    println!("Hello, world!");
    another_function();
}
</code></pre>
<p>我们在 Cairo 中定义函数是通过输入 <code>fn</code> 加上函数名和一组括号来进行的。花括号告诉编译器函数体在哪里开始和结束。</p>
<p>我们可以调用我们定义的任何函数，方法是输入其名称后跟一组括号。因为 <code>another_function</code> 在程序中被定义了，它可以从 <code>main</code> 函数内部被调用。注意我们在源代码中是在 <code>main</code> 函数 <em>之前</em> 定义 <code>another_function</code> 的；我们也可以在之后定义它。Cairo 不在乎你在哪里定义你的函数，只要它们定义在一个调用者可以看到的作用域内即可。</p>
<p>让我们用 Scarb 启动一个名为 <em>functions</em> 的新项目来进一步探索函数。将 <code>another_function</code> 示例放在 <em>src/lib.cairo</em> 中并运行它。你应该看到以下输出：</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_15_functions v0.1.0 (listings/ch02-common-programming-concepts/no_listing_15_functions/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing no_listing_15_functions
Hello, world!
Another function.


</code></pre>
<p>这些行按照它们在 <code>main</code> 函数中出现的顺序执行。首先打印 <code>Hello, world!</code> 消息，然后调用 <code>another_function</code> 并打印其消息。</p>
<h2 id="参数-parameters"><a class="header" href="#参数-parameters">参数 (Parameters)</a></h2>
<p>我们可以定义具有 <em>参数</em> 的函数，参数是函数签名的一部分的特殊变量。当一个函数有参数时，你可以为这些参数提供具体的值。从技术上讲，具体的值被称为 <em>参数 (arguments)</em>，但在日常对话中，人们倾向于互换使用 <em>参数 (parameter)</em> 和 <em>参数 (argument)</em> 这两个词来指代函数定义中的变量或调用函数时传入的具体值。</p>
<p>在这个版本的 <code>another_function</code> 中，我们添加了一个参数：</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    another_function(5);
}

fn another_function(x: felt252) {
    println!("The value of x is: {}", x);
}
</code></pre>
<p>尝试运行这个程序；你应该得到以下输出：</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_16_single_param v0.1.0 (listings/ch02-common-programming-concepts/no_listing_16_single_param/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing no_listing_16_single_param
The value of x is: 5


</code></pre>
<p><code>another_function</code> 的声明有一个名为 <code>x</code> 的参数。<code>x</code> 的类型被指定为 <code>felt252</code>。当我们传递 <code>5</code>给 <code>another_function</code> 时，<code>println!</code> 宏把 <code>5</code> 放在了格式字符串中包含 <code>x</code> 的那对花括号的位置。</p>
<p>在函数签名中，你 <em>必须</em> 声明每个参数的类型。这是 Cairo 设计中的一个深思熟虑的决定：要求在函数定义中进行类型注解意味着编译器几乎不需要你在代码的其他地方使用它们来弄清楚你的意思是哪种类型。如果编译器知道函数期望什么类型，它也能够给出更有帮助的错误消息。</p>
<p>当定义多个参数时，用逗号分隔参数声明，像这样：</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    print_labeled_measurement(5, "h");
}

fn print_labeled_measurement(value: u128, unit_label: ByteArray) {
    println!("The measurement is: {value}{unit_label}");
}
</code></pre>
<p>这个例子创建了一个名为 <code>print_labeled_measurement</code> 的函数，它有两个参数。第一个参数名为 <code>value</code>，是一个 <code>u128</code>。第二个名为 <code>unit_label</code>，类型是 <code>ByteArray</code> - Cairo 用于表示字符串字面量的内部类型。然后函数打印包含 <code>value</code> 和 <code>unit_label</code> 的文本。</p>
<p>让我们试着运行这段代码。用前面的例子替换目前的 <em>functions</em> 项目的 <em>src/lib.cairo</em> 文件，并使用 <code>scarb execute</code> 运行它：</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_17_multiple_params v0.1.0 (listings/ch02-common-programming-concepts/no_listing_17_multiple_params/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing no_listing_17_multiple_params
The measurement is: 5h


</code></pre>
<p>因为我们以 <code>5</code> 作为 <code>value</code> 的值和 <code>"h"</code> 作为 <code>unit_label</code> 的值来调用函数，所以程序输出包含这些值。</p>
<h3 id="命名参数-named-parameters"><a class="header" href="#命名参数-named-parameters">命名参数 (Named Parameters)</a></h3>
<p>在 Cairo 中，命名参数允许你在调用函数时指定参数的名称。这使得函数调用更具可读性和自描述性。如果你想使用命名参数，你需要指定参数的名称和你想要传递给它的值。语法是 <code>parameter_name: value</code>。如果你传递一个与参数同名的变量，你可以简单地写 <code>:parameter_name</code> 而不是 <code>parameter_name: variable_name</code>。</p>
<p>这是一个例子：</p>
<pre><code class="language-cairo">fn foo(x: u8, y: u8) {}

#[executable]
fn main() {
    let first_arg = 3;
    let second_arg = 4;
    foo(x: first_arg, y: second_arg);
    let x = 1;
    let y = 2;
    foo(:x, :y)
}
</code></pre>
<h2 id="语句和表达式-statements-and-expressions"><a class="header" href="#语句和表达式-statements-and-expressions">语句和表达式 (Statements and Expressions)</a></h2>
<p>函数体由一系列语句组成，可选择以一个表达式结束。到目前为止，我们涵盖的函数还没有包含结束表达式，但你已经看到过作为一个语句一部分的表达式。因为 Cairo 是一种基于表达式的语言，这是一个需要理解的重要区别。其他语言没有相同的区别，所以让我们看看语句和表达式是什么，以及它们的区别如何影响函数体。</p>
<ul>
<li><strong>语句</strong> 是执行某些操作且不返回值的指令。</li>
<li><strong>表达式</strong> 计算出一个结果值。让我们看一些例子。</li>
</ul>
<p>我们实际上已经使用过语句和表达式了。使用 <code>let</code> 关键字创建一个变量并为其赋值是一个语句。在清单 {{#ref fn-main}} 中，<code>let y = 6;</code> 是一个语句。</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let y = 6;
}
</code></pre>
<p>{{#label fn-main}} <span class="caption">清单 {{#ref fn-main}}: 一个包含一个语句的 <code>main</code> 函数声明</span></p>
<p>函数定义也是语句；整个前面的例子本身就是一个语句。</p>
<p>语句不返回值。因此，你不能将一个 <code>let</code> 语句赋值给另一个变量，如下面的代码试图做的那样；你会得到一个错误：</p>
<pre><code class="language-cairo noplayground">// TAGS: does_not_compile, ignore_fmt
#[executable]
fn main() {
    let x = (let y = 6);
}
</code></pre>
<p>当你运行这个程序时，你会得到的错误如下所示：</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_18_statements_dont_return_values v0.1.0 (listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/Scarb.toml)
error: Missing token ')'.
 --&gt; listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:4:14
    let x = (let y = 6);
             ^

error: Missing token ';'.
 --&gt; listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:4:14
    let x = (let y = 6);
             ^

error: Missing token ';'.
 --&gt; listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:4:23
    let x = (let y = 6);
                      ^

error: Skipped tokens. Expected: statement.
 --&gt; listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:4:23
    let x = (let y = 6);
                      ^^

warn[E0001]: Unused variable. Consider ignoring by prefixing with `_`.
 --&gt; listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:4:9
    let x = (let y = 6);
        ^

warn[E0001]: Unused variable. Consider ignoring by prefixing with `_`.
 --&gt; listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:4:18
    let x = (let y = 6);
                 ^

error: could not compile `no_listing_18_statements_dont_return_values` due to previous error
error: `scarb` command exited with error

</code></pre>
<p><code>let y = 6</code> 语句不返回值，所以没有什么可以让 <code>x</code> 绑定的。这与其他语言（如 C 和 Ruby）中发生的情况不同，在那些语言中赋值返回赋值的值。在那些语言中，你可以写 <code>x = y = 6</code> 并让 <code>x</code> 和 <code>y</code> 都具有值 <code>6</code>；在 Cairo 中情况并非如此。</p>
<p>表达式计算出一个值，并且构成了你将在 Cairo 中编写的大部分其余代码。考虑一个数学运算，如 <code>5 + 6</code>，这是一个计算结果为 <code>11</code> 的表达式。表达式可以是语句的一部分：在清单 {{#ref fn-main}} 中，语句 <code>let y = 6;</code> 中的 <code>6</code> 是一个计算结果为值 <code>6</code> 的表达式。</p>
<p>调用函数是一个表达式，因为它总是计算出一个值：如果指定了显式的返回值，或者是单元类型 <code>()</code>。</p>
<p>使用花括号创建的新作用域块是一个表达式，例如：</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    //ANCHOR: block_expr
    let y = {
        let x = 3;
        x + 1
    };
    //ANCHOR_END: block_expr

    println!("The value of y is: {}", y);
}
</code></pre>
<p>这个表达式：</p>
<pre><code class="language-cairo noplayground">    let y = {
        let x = 3;
        x + 1
    };
</code></pre>
<p>是一个块，在这种情况下，它的计算结果为 <code>4</code>。该值作为 <code>let</code> 语句的一部分绑定到 <code>y</code>。注意 <code>x + 1</code> 行末尾没有分号，这与你目前看到的大多数行都不一样。表达式不包含结束分号。如果你在表达式末尾添加分号，你就把它变成了一个语句，它就不会返回值了。在接下来探索函数返回值和表达式时，请记住这一点。</p>
<h2 id="具有返回值的函数"><a class="header" href="#具有返回值的函数">具有返回值的函数</a></h2>
<p>函数可以将值返回给调用它们的代码。我们不命名返回值，但我们要必须在箭头 (<code>-&gt;</code>) 之后声明它们的类型。在 Cairo 中，函数的返回值等同于函数体块中最后一个表达式的值。你可以通过使用 <code>return</code> 关键字并指定一个值来从函数提前返回，但大多数函数隐式地返回最后一个表达式。这是一个返回值的函数的例子：</p>
<pre><code class="language-cairo">fn five() -&gt; u32 {
    5
}

#[executable]
fn main() {
    let x = five();
    println!("The value of x is: {}", x);
}
</code></pre>
<p>在 <code>five</code> 函数中没有函数调用，甚至没有 <code>let</code> 语句——只有数字 <code>5</code> 本身。这在 Cairo 中是一个完全有效的函数。注意函数的返回类型也被指定了，即 <code>-&gt; u32</code>。尝试运行这段代码；输出应该看起来像这样：</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_20_function_return_values v0.1.0 (listings/ch02-common-programming-concepts/no_listing_22_function_return_values/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing no_listing_20_function_return_values
The value of x is: 5


</code></pre>
<p><code>five</code> 中的 <code>5</code> 是函数的返回值，这就是为什么返回类型是 <code>u32</code>。让我们更详细地检查一下。有两个重要的部分：首先，<code>let x = five();</code> 这一行表明我们正在使用函数的返回值来初始化一个变量。因为函数 <code>five</code> 返回 <code>5</code>，那一行与下面是一样的：</p>
<pre><code class="language-cairo noplayground">let x = 5;
</code></pre>
<p>其次，<code>five</code> 函数没有参数并定义了返回值的类型，但函数体是一个孤独的 <code>5</code>，没有分号，因为它是一个我们要返回其值的表达式。让我们看另一个例子：</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: u32) -&gt; u32 {
    x + 1
}
</code></pre>
<p>运行这段代码将打印 <code>x = 6</code>。但是如果你在包含 <code>x + 1</code> 的行的末尾放置一个分号，将其从表达式更改为语句，我们会得到一个错误：</p>
<pre><code class="language-cairo does_not_compile">//TAG: does_not_compile

#[executable]
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: u32) -&gt; u32 {
    x + 1;
}
</code></pre>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_22_function_return_invalid v0.1.0 (listings/ch02-common-programming-concepts/no_listing_24_function_return_invalid/Scarb.toml)
error: Unexpected return type. Expected: "core::integer::u32", found: "()".
 --&gt; listings/ch02-common-programming-concepts/no_listing_24_function_return_invalid/src/lib.cairo:10:24
fn plus_one(x: u32) -&gt; u32 {
                       ^^^

error: could not compile `no_listing_22_function_return_invalid` due to previous error
error: `scarb` command exited with error

</code></pre>
<p>主要错误消息 <code>Unexpected return type</code> 揭示了这段代码的核心问题。函数 <code>plus_one</code> 的定义说它将返回一个 <code>u32</code>，但语句不计算出一个值，这由 <code>()</code>（单元类型）表示。因此，没有返回任何东西，这与函数定义相矛盾并导致错误。</p>
<h3 id="const-函数"><a class="header" href="#const-函数">Const 函数</a></h3>
<p>可以在编译时计算的函数可以使用 <code>const fn</code> 语法标记为 <code>const</code>。这允许从常量上下文调用该函数，并由编译器在编译时进行解释。</p>
<p>将函数声明为 <code>const</code> 会限制参数和返回类型可以使用的类型，并将函数体限制为常量表达式。</p>
<p>核心库中的几个函数被标记为 <code>const</code>。这是一个来自核心库的例子，展示了实现为 <code>const fn</code> 的 <code>pow</code> 函数：</p>
<pre><code class="language-cairo">use core::num::traits::Pow;

const BYTE_MASK: u16 = 2_u16.pow(8) - 1;

#[executable]
fn main() {
    let my_value = 12345;
    let first_byte = my_value &amp; BYTE_MASK;
    println!("first_byte: {}", first_byte);
}
</code></pre>
<p>在这个例子中，<code>pow</code> 是一个 <code>const</code> 函数，允许它在常量表达式中用于在编译时定义 <code>mask</code>。这是核心库中如何使用 <code>const fn</code> 定义 <code>pow</code> 的片段：</p>
<p>注意，将函数声明为 <code>const</code> 对现有用法没有影响；它只对常量上下文施加限制。</p>
<p>{{#quiz ../quizzes/ch02-03-functions.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="注释"><a class="header" href="#注释">注释</a></h1>
<p>所有程序员都努力使他们的代码易于理解，但有时额外的解释是必要的。在这些情况下，程序员在源代码中留下注释，编译器会忽略这些注释，但阅读源代码的人可能会发现它们很有用。</p>
<p>这是一个简单的注释：</p>
<pre><code class="language-cairo noplayground">// hello, world
</code></pre>
<p>在 Cairo 中，惯用的注释风格是以两个斜杠开始注释，注释一直持续到行尾。对于超过一行的注释，你需要在每一行包含 <code>//</code>，像这样：</p>
<pre><code class="language-cairo noplayground">// So we’re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what’s going on.
</code></pre>
<p>注释也可以放在包含代码的行的末尾：</p>
<pre><code class="language-cairo">#[executable]
fn main() -&gt; felt252 {
    1 + 4 // return the sum of 1 and 4
}
</code></pre>
<p>但你会更频繁地看到这种格式，注释位于它所注视的代码上方的单独一行：</p>
<pre><code class="language-cairo">#[executable]
fn main() -&gt; felt252 {
    // this function performs a simple addition
    1 + 4
}
</code></pre>
<h2 id="项目级文档-item-level-documentation"><a class="header" href="#项目级文档-item-level-documentation">项目级文档 (Item-level Documentation)</a></h2>
<p>项目级文档注释指的是特定的项目，如函数、实现、Trait 等。它们以前缀三个斜杠 (<code>///</code>) 开头。这些注释提供了对项目的详细描述、使用示例以及可能导致 panic 的条件。在函数的情况下，注释还可以包括参数和返回值描述的单独部分。</p>
<pre><code class="language-cairo noplayground">/// Returns the sum of `arg1` and `arg2`.
/// `arg1` cannot be zero.
///
/// # Panics
///
/// This function will panic if `arg1` is `0`.
///
/// # Examples
///
/// ```
/// let a: felt252 = 2;
/// let b: felt252 = 3;
/// let c: felt252 = add(a, b);
/// assert!(c == a + b, "Should equal a + b");
/// ```
fn add(arg1: felt252, arg2: felt252) -&gt; felt252 {
    assert!(arg1 != 0, "Cannot be zero");
    arg1 + arg2
}
</code></pre>
<h2 id="模块文档-module-documentation"><a class="header" href="#模块文档-module-documentation">模块文档 (Module Documentation)</a></h2>
<p>模块文档注释提供整个模块的概述，包括其目的和使用示例。这些注释旨在放在它们描述的模块上方，并以前缀 <code>//!</code> 开头。这种类型的文档提供了对模块作用以及如何使用的广泛理解。</p>
<pre><code class="language-cairo noplayground">//! # my_module and implementation
//!
//! This is an example description of my_module and some of its features.
//!
//! # Examples
//!
//! ```
//! mod my_other_module {
//!   use path::to::my_module;
//!
//!   fn foo() {
//!     my_module.bar();
//!   }
//! }
//! ```
mod my_module { // rest of implementation...
}
</code></pre>
<p>{{#quiz ../quizzes/ch02-04-comments.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="控制流"><a class="header" href="#控制流">控制流</a></h1>
<p>根据条件是否为真来运行某些代码，以及在条件为真时重复运行某些代码的能力，是大多数编程语言的基本构建块。让你控制 Cairo 代码执行流程的最常见结构是 <code>if</code> 表达式和循环。</p>
<h2 id="if-表达式"><a class="header" href="#if-表达式"><code>if</code> 表达式</a></h2>
<p><code>if</code> 表达式允许你根据条件分支你的代码。你提供一个条件，然后声明，“如果满足这个条件，运行这段代码块。如果不满足这个条件，不要运行这段代码块。”</p>
<p>在你的 <em>cairo_projects</em> 目录中创建一个名为 <em>branches</em> 的新项目来探索 <code>if</code> 表达式。在 <em>src/lib.cairo</em> 文件中，输入以下内容：</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let number = 3;

    if number == 5 {
        println!("condition was true and number = {}", number);
    } else {
        println!("condition was false and number = {}", number);
    }
}
</code></pre>
<p>所有的 <code>if</code> 表达式都以关键字 <code>if</code> 开头，后跟一个条件。在这种情况下，条件检查变量 <code>number</code> 的值是否等于 5。我们将如果条件为 <code>true</code> 时要执行的代码块放在条件之后的在大括号内。</p>
<p>或者，我们也可以包含一个 <code>else</code> 表达式（我们在这里选择这样做），以便在条件计算为 <code>false</code> 时给程序一个替代的代码块来执行。如果你不提供 <code>else</code> 表达式且条件为 <code>false</code>，程序将直接跳过 <code>if</code> 块并继续下一段代码。</p>
<p>尝试运行这段代码；你应该看到以下输出：</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_24_if v0.1.0 (listings/ch02-common-programming-concepts/no_listing_27_if/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing no_listing_24_if
condition was false and number = 3


</code></pre>
<p>让我们尝试将 <code>number</code> 的值更改为一个使条件为 <code>true</code> 的值，看看会发生什么：</p>
<pre><code class="language-cairo noplayground">    let number = 5;
</code></pre>
<pre><code class="language-shell">$ scarb execute
condition was true and number = 5
Run completed successfully, returning []
</code></pre>
<p>同样值得注意的是，此代码中的条件必须是 <code>bool</code>。如果条件不是 <code>bool</code>，我们会得到一个错误。例如，尝试运行以下代码：</p>
<pre><code class="language-cairo">//TAG: does_not_compile

#[executable]
fn main() {
    let number = 3;

    if number {
        println!("number was three");
    }
}
</code></pre>
<p>这次 <code>if</code> 条件计算为值 3，Cairo 抛出一个错误：</p>
<pre><code class="language-shell">$ scarb build 
   Compiling no_listing_28_bis_if_not_bool v0.1.0 (listings/ch02-common-programming-concepts/no_listing_28_bis_if_not_bool/Scarb.toml)
error: Mismatched types. The type `core::bool` cannot be created from a numeric literal.
 --&gt; listings/ch02-common-programming-concepts/no_listing_28_bis_if_not_bool/src/lib.cairo:5:18
    let number = 3;
                 ^

error: could not compile `no_listing_28_bis_if_not_bool` due to previous error

</code></pre>
<p>错误表明 Cairo 根据 <code>number</code> 稍后作为 <code>if</code> 语句条件的用法推断出它的类型是 <code>bool</code>。它尝试从值 <code>3</code> 创建一个 <code>bool</code>，但 Cairo 反正不支持从数字文字实例化 <code>bool</code> —— 你只能使用 <code>true</code> 或 <code>false</code> 来创建 <code>bool</code>。与 Ruby 和 JavaScript 等语言不同，Cairo 不会自动尝试将非布尔类型转换为布尔类型。如果你希望 <code>if</code> 代码块仅在数字不等于 0 时运行，例如，我们可以将 if 表达式更改为以下内容：</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let number = 3;

    if number != 0 {
        println!("number was something other than zero");
    }
}

</code></pre>
<p>运行这段代码将打印 <code>number was something other than zero</code>。</p>
<h2 id="使用-else-if-处理多个条件"><a class="header" href="#使用-else-if-处理多个条件">使用 <code>else if</code> 处理多个条件</a></h2>
<p>你可以通过在 <code>else if</code> 表达式中组合 <code>if</code> 和 <code>else</code> 来使用多个条件。例如：</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let number = 3;

    if number == 12 {
        println!("number is 12");
    } else if number == 3 {
        println!("number is 3");
    } else if number - 2 == 1 {
        println!("number minus 2 is 1");
    } else {
        println!("number not found");
    }
}
</code></pre>
<p>这个程序有四条可能的路径可以走。运行后，你应该看到以下输出：</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_25_else_if v0.1.0 (listings/ch02-common-programming-concepts/no_listing_30_else_if/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing no_listing_25_else_if
number is 3


</code></pre>
<p>当这个程序执行时，它依次检查每个 <code>if</code> 表达式，并执行条件计算为 <code>true</code> 的第一个主体。注意，即使 <code>number - 2 == 1</code> 是 <code>true</code>，我们也没有看到输出 <code>number minus 2 is 1</code>，也没有看到来自 <code>else</code> 块的 <code>number not found</code> 文本。这是因为 Cairo 只执行第一个真条件的代码块，一旦找到一个，它甚至不会检查其余的。使用过多的 <code>else if</code> 表达式会使你的代码杂乱无章，所以如果你有多个，你可能想要重构你的代码。<a href="#match-控制流结构">第 {{#chap enums-and-pattern-matching}} 章</a> 描述了一个强大的 Cairo 分支结构，称为 <code>match</code>，专门处理这些情况。</p>
<h2 id="在-let-语句中使用-if"><a class="header" href="#在-let-语句中使用-if">在 <code>let</code> 语句中使用 <code>if</code></a></h2>
<p>因为 <code>if</code> 是一个表达式，我们可以在 <code>let</code> 语句的右侧使用它来讲结果赋值给一个变量。</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    if number == 5 {
        println!("condition was true and number is {}", number);
    }
}
</code></pre>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_26_if_let v0.1.0 (listings/ch02-common-programming-concepts/no_listing_31_if_let/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing no_listing_26_if_let
condition was true and number is 5


</code></pre>
<p><code>number</code> 变量将绑定到一个基于 <code>if</code> 表达式结果的值，在这里是 5。</p>
<h2 id="使用循环重复执行"><a class="header" href="#使用循环重复执行">使用循环重复执行</a></h2>
<p>多次执行一块代码通常很有用。为了这个任务，Cairo 提供了一个简单的循环语法，它将运行循环体内的代码直到结束，然后立即从头开始。为了试验循环，让我们创建一个名为 <em>loops</em> 的新项目。</p>
<p>Cairo 有三种类型的循环：<code>loop</code>，<code>while</code> 和 <code>for</code>。让我们尝试每一个。</p>
<h3 id="使用-loop-重复代码"><a class="header" href="#使用-loop-重复代码">使用 <code>loop</code> 重复代码</a></h3>
<p><code>loop</code> 关键字告诉 Cairo 一遍又一遍地执行一块代码，直到永远或直到你明确告诉它停止。</p>
<p>作为一个例子，将 <em>loops</em> 目录中的 <em>src/lib.cairo</em> 文件更改为如下所示：</p>
<pre><code class="language-cairo">// TAG: does_not_run

#[executable]
fn main() {
    loop {
        println!("again!");
    }
}
</code></pre>
<p>当我们运行这个程序时，我们将看到 <code>again!</code> 被连续不断地打印，直到程序耗尽 gas 或者我们手动停止程序。大多数终端支持键盘快捷键 ctrl-c 来中断陷入持续循环的程序。试一试：</p>
<pre><code class="language-shell">$ scarb execute --available-gas=20000000
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished release target(s) in 0 seconds
     Running loops
again!
again!
again!
^Cagain!
</code></pre>
<p>符号 <code>^C</code> 代表你按下 ctrl-c 的位置。你可能会也可能不会在 ^C 之后看到单词 <code>again!</code> 打印出来，这取决于接收到中断信号时代码在循环中的位置。</p>
<blockquote>
<p>注意：Cairo 通过包含 gas 计来防止我们运行无限循环的程序。Gas 计是一种限制程序中可以完成的计算量的机制。通过设置 <code>--available-gas</code> 标志的值，我们可以设置程序可用的最大 gas 量。Gas 是表示指令计算成本的计量单位。当 gas 计耗尽时，程序将停止。在前一种情况下，我们将 gas 限制设置得足够高，以便程序运行相当长的时间。</p>
</blockquote>
<blockquote>
<p>这在部署在 Starknet 上的智能合约的背景下尤为重要，因为它可以防止在网络上运行无限循环。如果你正在编写一个需要运行循环的程序，你将需要使用设置了足够大值的 <code>--available-gas</code> 标志来执行它，以便运行程序。</p>
</blockquote>
<p>现在，尝试再次运行相同的程序，但这次将 <code>--available-gas</code> 标志设置为 <code>200000</code> 而不是 <code>2000000000000</code>。你会看到程序只打印了 3 次 <code>again!</code> 就停止了，因为它耗尽了 gas 无法继续执行循环。</p>
<p>幸运的是，Cairo 也提供了一种使用代码跳出循环的方法。你可以把 <code>break</code> 关键字放在循环内，告诉程序何时停止执行循环。</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut i: usize = 0;
    loop {
        if i &gt; 10 {
            break;
        }
        println!("i = {}", i);
        i += 1;
    }
}
</code></pre>
<p><code>continue</code> 关键字告诉程序转到循环的下一次迭代，并跳过本次迭代中的其余代码。让我们在循环中添加一个 <code>continue</code> 语句，当 <code>i</code> 等于 <code>5</code> 时跳过 <code>println!</code> 语句。</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut i: usize = 0;
    loop {
        if i &gt; 10 {
            break;
        }
        if i == 5 {
            i += 1;
            continue;
        }
        println!("i = {}", i);
        i += 1;
    }
}
</code></pre>
<p>执行此程序将在 <code>i</code> 等于 <code>5</code> 时不打印 <code>i</code> 的值。</p>
<h3 id="从循环返回值"><a class="header" href="#从循环返回值">从循环返回值</a></h3>
<p><code>loop</code> 的用途之一是重试你明知可能失败的操作，例如检查操作是否成功。你可能还需要将该操作的结果从循环中传递给代码的其余部分。为此，你可以在用于停止循环的 <code>break</code> 表达式之后添加你想要返回的值；该值将从循环中返回，以便你可以使用它，如下所示：</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut counter = 0;

    let result = loop {
        if counter == 10 {
            break counter * 2;
        }
        counter += 1;
    };

    println!("The result is {}", result);
}
</code></pre>
<p>在循环之前，我们声明一个名为 <code>counter</code> 的变量并将其初始化为 <code>0</code>。然后我们声明一个名为 <code>result</code> 的变量来保存从循环返回的值。在循环的每次迭代中，我们检查 <code>counter</code> 是否等于 <code>10</code>，然后将 <code>counter</code> 变量加 <code>1</code>。当条件满足时，我们使用 <code>break</code> 关键字和值 <code>counter * 2</code>。在循环之后，我们使用分号结束将值赋值给 <code>result</code> 的语句。最后，我们打印 <code>result</code> 中的值，在这种情况下是 <code>20</code>。</p>
<h3 id="使用-while-的条件循环"><a class="header" href="#使用-while-的条件循环">使用 <code>while</code> 的条件循环</a></h3>
<p>程序通常需要在循环内评估条件。当条件为 <code>true</code> 时，循环运行。当条件不再为 <code>true</code> 时，程序调用 <code>break</code>，停止循环。可以使用 <code>loop</code>、<code>if</code>、<code>else</code> 和 <code>break</code> 的组合来实现像这样的行为；如果你愿意，你现在可以在程序中尝试一下。然而，这种模式非常常见，以至于 Cairo 有一个内置的语言结构，称为 <code>while</code> 循环。</p>
<p>在清单 {{#ref while-true}} 中，我们使用 <code>while</code> 循环程序三次，每次打印 <code>number</code> 的值后倒数，然后在循环之后，打印一条消息并退出。</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");
        number -= 1;
    }

    println!("LIFTOFF!!!");
}
</code></pre>
<p>{{#label while-true}} <span class="caption">清单 {{#ref while-true}}: 使用 <code>while</code> 循环在条件保持 <code>true</code> 时运行代码。</span></p>
<p>如果你使用 <code>loop</code>、<code>if</code>、<code>else</code> 和 <code>break</code>，这种结构消除了许多必要的嵌套，并且更清晰。只要条件计算为 <code>true</code>，代码就会运行；否则，它退出循环。</p>
<h3 id="使用-for-遍历集合"><a class="header" href="#使用-for-遍历集合">使用 <code>for</code> 遍历集合</a></h3>
<p>你也可以使用 while 结构来遍历集合的元素，例如数组。例如，清单 {{#ref iter-while}} 中的循环打印数组 <code>a</code> 中的每个元素。</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let a = [10, 20, 30, 40, 50].span();
    let mut index = 0;

    while index &lt; 5 {
        println!("the value is: {}", a[index]);
        index += 1;
    }
}
</code></pre>
<p>{{#label iter-while}} <span class="caption">清单 {{#ref iter-while}}: 使用 <code>while</code> 循环遍历集合的每个元素</span></p>
<p>这里，代码通过数组中的元素向上计数。它从索引 <code>0</code> 开始，然后循环直到达到数组中的最后一个索引（即，当 <code>index &lt; 5</code> 不再为 <code>true</code> 时）。运行这段代码将打印数组中的每个元素：</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_45_iter_loop_while v0.1.0 (listings/ch02-common-programming-concepts/no_listing_45_iter_loop_while/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing no_listing_45_iter_loop_while
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50


</code></pre>
<p>所有五个数组值都如预期出现在终端中。即使 <code>index</code> 在某个时刻会达到值 <code>5</code>，循环在尝试从数组中获取第六个值之前就停止执行了。</p>
<p>然而，这种方法容易出错；如果索引值或测试条件不正确，我们可能会导致程序 panic。例如，如果你将 <code>a</code> 数组的定义更改为有四个元素，但忘记将条件更新为 <code>while index &lt; 4</code>，代码将会 panic。它也很慢，因为编译器会添加运行时代码，以便在每次循环迭代中执行索引是否在数组边界内的条件检查。</p>
<p>作为一个更简洁的替代方案，你可以使用 <code>for</code> 循环并为集合中的每个项目执行一些代码。<code>for</code> 循环看起来像清单 {{#ref iter-for}} 中的代码。</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let a = [10, 20, 30, 40, 50].span();

    for element in a {
        println!("the value is: {element}");
    }
}
</code></pre>
<p>{{#label iter-for}} <span class="caption">清单 {{#ref iter-for}}: 使用 <code>for</code> 循环遍历集合的每个元素</span></p>
<p>当我们运行这段代码时，我们将看到与清单 {{#ref iter-while}} 相同的输出。更重要的是，我们现在提高了代码的安全性，并消除了因超出数组末尾或没有走得足够远而遗漏某些项目而导致 bug 的机会。</p>
<p>使用 <code>for</code> 循环，如果你更改数组中值的数量，你不需要记得更改任何其他代码，正如你在清单 {{#ref iter-while}} 中使用的方法那样。</p>
<p><code>for</code> 循环的安全性和简洁性使它们成为 Cairo 中最常用的循环结构。即使在你想运行某些代码一定次数的情况下，如清单 {{#ref while-true}} 中使用 while 循环的倒计时示例。另一种运行代码一定次数的方法是使用核心库提供的 <code>Range</code>，它按顺序生成从一个数字开始并在另一个数字之前结束的所有数字。</p>
<p>这是你如何使用 <code>Range</code> 从 1 数到 3：</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    for number in 1..4_u8 {
        println!("{number}!");
    }
    println!("Go!!!");
}
</code></pre>
<p>这段代码好一点，不是吗？</p>
<h2 id="循环和递归函数的等价性"><a class="header" href="#循环和递归函数的等价性">循环和递归函数的等价性</a></h2>
<p>循环和递归函数是多次重复代码块的两种常用方法。<code>loop</code> 关键字用于创建一个无限循环，可以使用 <code>break</code> 关键字中断。</p>
<pre><code class="language-cairo">#[executable]
fn main() -&gt; felt252 {
    let mut x: felt252 = 0;
    loop {
        if x == 2 {
            break;
        } else {
            x += 1;
        }
    }
    x
}
</code></pre>
<p>循环可以通过在函数内部调用函数本身转换为递归函数。这是模仿上面 <code>loop</code> 示例行为的递归函数的示例。</p>
<pre><code class="language-cairo">#[executable]
fn main() -&gt; felt252 {
    recursive_function(0)
}

fn recursive_function(mut x: felt252) -&gt; felt252 {
    if x == 2 {
        x
    } else {
        recursive_function(x + 1)
    }
}
</code></pre>
<p>在这两种情况下，代码块都将无限期运行，直到满足条件 <code>x == 2</code>，此时将显示 x 的值。</p>
<p>在 Cairo 中，循环和递归不仅在概念上等效：它们还被编译成类似的低级表示。为了理解这一点，我们可以将两个示例都编译为 Sierra，并分析 Cairo 编译器为这两个示例生成的 Sierra 代码。在你的 <code>Scarb.toml</code> 文件中添加以下内容：</p>
<pre><code class="language-toml">[lib]
sierra-text = true
</code></pre>
<p>然后，运行 <code>scarb build</code> 编译两个示例。你会发现为这两个示例生成的 Sierra 代码非常相似，因为循环在 Sierra 语句中被编译成了递归函数。</p>
<blockquote>
<p>注意：对于我们的示例，我们的发现来自于理解 Sierra 中显示两个程序执行轨迹的 <strong>statements</strong> 部分。如果你对学习更多关于 Sierra 的知识感到好奇，请查看 <a href="https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5">Exploring Sierra</a>。</p>
</blockquote>
<p>{{#quiz ../quizzes/ch02-05-control-flow.toml}}</p>
<h2 id="总结-2"><a class="header" href="#总结-2">总结</a></h2>
<p>你做到了！这是一个相当大的章节：你学习了变量、数据类型、函数、注释、<code>if</code> 表达式和循环！为了练习本章讨论的概念，尝试构建程序来做以下事情：</p>
<ul>
<li>生成第 <em>n</em> 个斐波那契数。</li>
<li>计算数字 <em>n</em> 的阶乘。</li>
</ul>
<p>现在，我们将在下一章回顾 Cairo 中的常见集合类型。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="常见集合"><a class="header" href="#常见集合">常见集合</a></h1>
<p>Cairo 提供了一组常见的集合类型，可用于存储和操作数据。这些集合被设计为高效、灵活且易于使用。本节介绍了 Cairo 中可用的主要集合类型：数组和字典。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="数组"><a class="header" href="#数组">数组</a></h1>
<p>数组是相同类型元素的集合。你可以通过使用核心库中的 <code>ArrayTrait</code> trait 来创建和使用数组方法。</p>
<p>需要注意的一件重要事情是，数组的修改选项有限。实际上，数组是其值不能被修改的队列。这与以下事实有关：内存槽一被写入，就不能被覆盖，只能从中读取。你只能将项目追加到数组的末尾，并从前面移除项目。</p>
<h2 id="创建一个数组"><a class="header" href="#创建一个数组">创建一个数组</a></h2>
<p>创建数组是通过 <code>ArrayTrait::new()</code> 调用完成的。这是一个创建数组并向其追加 3 个元素的示例：</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut a = ArrayTrait::new();
    a.append(0);
    a.append(1);
    a.append(2);
}
</code></pre>
<p>当需要时，你可以在像这样实例化数组时传递数组内部预期的项目类型，或者显式定义变量的类型。</p>
<pre><code class="language-cairo noplayground">let mut arr = ArrayTrait::&lt;u128&gt;::new();
</code></pre>
<pre><code class="language-cairo noplayground">let mut arr:Array&lt;u128&gt; = ArrayTrait::new();
</code></pre>
<h2 id="更新数组"><a class="header" href="#更新数组">更新数组</a></h2>
<h3 id="添加元素"><a class="header" href="#添加元素">添加元素</a></h3>
<p>要将元素添加到数组的末尾，可以使用 <code>append()</code> 方法：</p>
<pre><code class="language-cairo">&lt;!-- Warning: Anchor '5' not found in lib.cairo --&gt;
</code></pre>
<h3 id="移除元素"><a class="header" href="#移除元素">移除元素</a></h3>
<p>你只能通过使用 <code>pop_front()</code> 方法从数组的前面移除元素。此方法返回一个可以解包的 <code>Option</code>，其中包含被移除的元素，或者如果数组为空则返回 <code>None</code>。</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut a = ArrayTrait::new();
    a.append(10);
    a.append(1);
    a.append(2);

    let first_value = a.pop_front().unwrap();
    println!("The first value is {}", first_value);
}
</code></pre>
<p>上面的代码将打印 <code>The first value is 10</code>，因为我们移除了添加的第一个元素。</p>
<p>在 Cairo 中，内存是不可变的，这意味着一旦数组元素被添加，就不可能修改它们。你只能将元素添加到数组的末尾，并从数组的前面移除元素。这些操作不需要内存突变，因为它们涉及更新指针而不是直接修改内存单元。</p>
<h2 id="从数组读取元素"><a class="header" href="#从数组读取元素">从数组读取元素</a></h2>
<p>要访问数组元素，你可以使用返回不同类型的 <code>get()</code> 或 <code>at()</code> 数组方法。使用 <code>arr.at(index)</code> 等同于使用下标运算符 <code>arr[index]</code>。</p>
<h3 id="get-方法"><a class="header" href="#get-方法"><code>get()</code> 方法</a></h3>
<p><code>get</code> 函数返回一个 <code>Option&lt;Box&lt;@T&gt;&gt;</code>，这意味着如果指定的索引处的元素存在于数组中，它返回一个指向该元素的快照的 Box 类型（Cairo 的智能指针类型）的 option。如果元素不存在，<code>get</code> 返回 <code>None</code>。当你期望访问可能不在数组边界内的索引，并且想要优雅地处理此类情况而不会引起 panic 时，此方法很有用。快照将在 <a href="#snapshots">“引用和快照”</a> 章节中更详细地解释。</p>
<p>这是一个使用 <code>get()</code> 方法的示例：</p>
<pre><code class="language-cairo">// TAG: does_not_run

#[executable]
fn main() -&gt; u128 {
    let mut arr = ArrayTrait::&lt;u128&gt;::new();
    arr.append(100);
    let index_to_access =
        1; // Change this value to see different results, what would happen if the index doesn't exist?
    match arr.get(index_to_access) {
        Some(x) =&gt; {
            *x
                .unbox() // Don't worry about * for now, if you are curious see Chapter 4.2 #desnap operator
            // It basically means "transform what get(idx) returned into a real value"
        },
        None =&gt; { panic!("out of bounds") },
    }
}
</code></pre>
<h3 id="at-方法"><a class="header" href="#at-方法"><code>at()</code> 方法</a></h3>
<p>另一方面，<code>at</code> 函数及其等效的下标运算符直接返回指向指定索引处元素的快照，使用 <code>unbox()</code> 运算符提取存储在 box 中的值。如果索引越界，则会发生 panic 错误。你应该只在希望程序在提供的索引超出数组边界时 panic 时使用 <code>at</code>，这可以防止意外行为。</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut a = ArrayTrait::new();
    a.append(0);
    a.append(1);

    // using the `at()` method
    let first = *a.at(0);
    assert!(first == 0);
    // using the subscripting operator
    let second = *a[1];
    assert!(second == 1);
}
</code></pre>
<p>在这个例子中，名为 <code>first</code> 的变量将获得值 <code>0</code>，因为那是数组中索引 <code>0</code> 处的值。名为 <code>second</code> 的变量将从数组中的索引 <code>1</code> 获得值 <code>1</code>。</p>
<p>总之，当你想要对越界访问尝试进行 panic 时使用 <code>at</code>，当你更喜欢优雅地处理此类情况而不 panic 时使用 <code>get</code>。</p>
<h2 id="大小相关方法"><a class="header" href="#大小相关方法">大小相关方法</a></h2>
<p>要确定数组中的元素数量，请使用 <code>len()</code> 方法。返回值是 <code>usize</code> 类型。</p>
<p>如果你想检查数组是否为空，可以使用 <code>is_empty()</code> 方法，如果数组为空则返回 <code>true</code>，否则返回 <code>false</code>。</p>
<h2 id="array-宏"><a class="header" href="#array-宏"><code>array!</code> 宏</a></h2>
<p>有时，我们需要创建值在编译时已知的数组。执行此操作的基本方法是多余的。你会先声明数组，然后逐个追加每个值。<code>array!</code> 是通过组合这两个步骤来完成此任务的一种更简单的方法。在编译时，宏扩展为按顺序追加项目的代码。关于声明性宏如何匹配模式和扩展的更深入解释，请参阅 <a href="#declarative-inline-macros-for-general-metaprogramming">宏 → 声明性内联宏</a>。</p>
<p>不使用 <code>array!</code>:</p>
<pre><code class="language-cairo">    let mut arr = ArrayTrait::new();
    arr.append(1);
    arr.append(2);
    arr.append(3);
    arr.append(4);
    arr.append(5);
</code></pre>
<p>使用 <code>array!</code>:</p>
<pre><code class="language-cairo">    let arr = array![1, 2, 3, 4, 5];
</code></pre>
<h2 id="使用枚举存储多种类型"><a class="header" href="#使用枚举存储多种类型">使用枚举存储多种类型</a></h2>
<p>如果你想在数组中存储不同类型的元素，可以使用 <code>Enum</code> 定义一个可以保存多种类型的自定义数据类型。枚举将在 <a href="#枚举和模式匹配">“枚举和模式匹配”</a> 章节中更详细地解释。</p>
<pre><code class="language-cairo">#[derive(Copy, Drop)]
enum Data {
    Integer: u128,
    Felt: felt252,
    Tuple: (u32, u32),
}

#[executable]
fn main() {
    let mut messages: Array&lt;Data&gt; = array![];
    messages.append(Data::Integer(100));
    messages.append(Data::Felt('hello world'));
    messages.append(Data::Tuple((10, 30)));
}
</code></pre>
<h2 id="span"><a class="header" href="#span">Span</a></h2>
<p><code>Span</code> 是一个表示 <code>Array</code> 快照的结构体。它旨在提供对数组元素的安全且受控的访问，而不修改原始数组。Span 对于确保数据完整性和避免在函数之间传递数组或执行只读操作时的借用问题特别有用，如 <a href="#引用和快照-references-and-snapshots">“引用和快照”</a> 中介绍的那样。</p>
<p><code>Array</code> 提供的除 <code>append()</code> 方法外的所有方法也可以与 <code>Span</code> 一起使用。</p>
<h3 id="将数组转换为-span"><a class="header" href="#将数组转换为-span">将数组转换为 Span</a></h3>
<p>要创建 <code>Array</code> 的 <code>Span</code>，请调用 <code>span()</code> 方法：</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut array: Array&lt;u8&gt; = ArrayTrait::new();
    array.span();
}
</code></pre>
<p>{{#quiz ../quizzes/ch03-01-arrays.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="字典"><a class="header" href="#字典">字典</a></h1>
<p>Cairo 在其核心库中提供了一种类似字典的类型。<code>Felt252Dict&lt;T&gt;</code> 数据类型表示键值对的集合，其中每个键都是唯一的，并与相应的值相关联。这种数据结构在不同的编程语言中有不同的名称，如映射 (maps)、哈希表 (hash tables)、关联数组 (associative arrays) 等。</p>
<p><code>Felt252Dict&lt;T&gt;</code> 类型在你想要以某种方式组织数据，而使用 <code>Array&lt;T&gt;</code> 和索引不足以应付时非常有用。Cairo 字典还允许程序员在没有可变内存的情况下轻松模拟可变内存的存在。</p>
<h2 id="字典的基本用法"><a class="header" href="#字典的基本用法">字典的基本用法</a></h2>
<p>在其他语言中，创建新字典时通常要定义键和值的数据类型。在 Cairo 中，键类型被限制为 <code>felt252</code>，只留下了指定值数据类型的可能性，由 <code>Felt252Dict&lt;T&gt;</code> 中的 <code>T</code> 表示。</p>
<p><code>Felt252Dict&lt;T&gt;</code> 的核心功能是在 <code>Felt252DictTrait</code> trait 中实现的，其中包括所有基本操作。其中我们可以找到：</p>
<ol>
<li><code>insert(felt252, T) -&gt; ()</code> 用于向字典实例写入值，以及</li>
<li><code>get(felt252) -&gt; T</code> 用于从中读取值。</li>
</ol>
<p>这些函数允许我们像在任何其他语言中一样操作字典。在下面的示例中，我们创建一个字典来表示个人与其余额之间的映射：</p>
<pre><code class="language-cairo">use core::dict::Felt252Dict;

#[executable]
fn main() {
    let mut balances: Felt252Dict&lt;u64&gt; = Default::default();

    balances.insert('Alex', 100);
    balances.insert('Maria', 200);

    let alex_balance = balances.get('Alex');
    assert!(alex_balance == 100, "Balance is not 100");

    let maria_balance = balances.get('Maria');
    assert!(maria_balance == 200, "Balance is not 200");
}
</code></pre>
<p>我们可以通过使用 <code>Default</code> trait 的 <code>default</code> 方法创建一个 <code>Felt252Dict&lt;u64&gt;</code> 的新实例，并使用 <code>insert</code> 方法添加两个人，每个人都有自己的余额。最后，我们使用 <code>get</code> 方法检查用户的余额。这些方法定义在核心库的 <code>Felt252DictTrait</code> trait 中。</p>
<p>在整本书中，我们要一直在谈论 Cairo 的内存是如何不可变的，这意味着你只能向内存单元写入一次，但 <code>Felt252Dict&lt;T&gt;</code> 类型代表了一种克服这一障碍的方法。我们稍后将在 <a href="#dictionaries-underneath">“底层字典”</a> 中解释这是如何实现的。</p>
<p>基于我们之前的例子，让我们展示一个同一个用户的余额发生变化的代码示例：</p>
<pre><code class="language-cairo">use core::dict::Felt252Dict;

#[executable]
fn main() {
    let mut balances: Felt252Dict&lt;u64&gt; = Default::default();

    // Insert Alex with 100 balance
    balances.insert('Alex', 100);
    // Check that Alex has indeed 100 associated with him
    let alex_balance = balances.get('Alex');
    assert!(alex_balance == 100, "Alex balance is not 100");

    // Insert Alex again, this time with 200 balance
    balances.insert('Alex', 200);
    // Check the new balance is correct
    let alex_balance_2 = balances.get('Alex');
    assert!(alex_balance_2 == 200, "Alex balance is not 200");
}
</code></pre>
<p>注意在这个例子中我们是如何两次添加 ‘Alex’ 个人的，每次使用不同的余额，并且每次我们检查其余额时，它都有最后插入的值！<code>Felt252Dict&lt;T&gt;</code> 有效地允许我们“重写”任何给定键的存储值。</p>
<p>在继续解释字典是如何实现的之前，值得一提的是，一旦你实例化一个 <code>Felt252Dict&lt;T&gt;</code>，在幕后所有的键都有其关联的值初始化为零。这意味着如果例如，你试图获取一个不存在的用户的余额，你会得到 0 而不是错误或未定义的值。这也意味着没有办法从字典中删除数据。这是将此结构纳入你的代码时需要考虑的事情。</p>
<p>到目前为止，我们已经看到了 <code>Felt252Dict&lt;T&gt;</code> 的所有基本特性，以及它如何模仿任何其他语言中相应数据结构的相同行为，当然是在表面上。Cairo 本质上是一种非确定性图灵完备编程语言，与现存的任何其他流行语言都非常不同，因此这意味着字典的实现也非常不同！</p>
<p>在接下来的部分中，我们将给出一些关于 <code>Felt252Dict&lt;T&gt;</code> 内部机制以及为使其工作而做出的妥协的见解。之后，我们将看看如何将字典与其他数据结构一起使用，以及使用 <code>entry</code> 方法作为与它们交互的另一种方式。</p>
<h2 id="底层字典-dictionaries-underneath"><a class="header" href="#底层字典-dictionaries-underneath">底层字典 (Dictionaries Underneath)</a></h2>
<p>Cairo 非确定性设计的约束之一是其内存系统是不可变的，因此为了模拟可变性，该语言将 <code>Felt252Dict&lt;T&gt;</code> 实现为条目（entries）列表。每个条目代表字典被访问以进行读取/更新/写入目的的时间。一个条目有三个字段：</p>
<ol>
<li>一个 <code>key</code> 字段，标识此字典键值对的键。</li>
<li>一个 <code>previous_value</code> 字段，指示先前在 <code>key</code> 处保存的值。</li>
<li>一个 <code>new_value</code> 字段，指示在 <code>key</code> 处保存的新值。</li>
</ol>
<p>如果我们尝试使用高级结构实现 <code>Felt252Dict&lt;T&gt;</code>，这种内部定义为 <code>Array&lt;Entry&lt;T&gt;&gt;</code>，其中每个 <code>Entry&lt;T&gt;</code> 都有关于它代表什么键值对以及它保存的先前和新值的信息。<code>Entry&lt;T&gt;</code> 的定义将是：</p>
<pre><code class="language-cairo noplayground">struct Entry&lt;T&gt; {
    key: felt252,
    previous_value: T,
    new_value: T,
}
</code></pre>
<p>每当我们与 <code>Felt252Dict&lt;T&gt;</code> 交互时，都会注册一个新的 <code>Entry&lt;T&gt;</code>：</p>
<ul>
<li><code>get</code> 会注册一个状态没有变化的条目，并且先前和新值存储相同的值。</li>
<li><code>insert</code> 会注册一个新的 <code>Entry&lt;T&gt;</code>，其中 <code>new_value</code> 将是被插入的元素，而 <code>previous_value</code> 是在此之前最后插入的元素。如果它是某个键的第一个条目，那么先前的值将是零。</li>
</ul>
<p>使用这个条目列表表明没有任何重写，只是每次 <code>Felt252Dict&lt;T&gt;</code> 交互都创建新的内存单元。让我们用上一节的 <code>balances</code> 字典并插入用户 ‘Alex’ 和 ‘Maria’ 来展示这方面的一个例子：</p>
<pre><code class="language-cairo">    balances.insert('Alex', 100_u64);
    balances.insert('Maria', 50_u64);
    balances.insert('Alex', 200_u64);
    balances.get('Maria');
</code></pre>
<p>这些指令将产生以下条目列表：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: center">key</th><th>previous</th><th>new</th></tr>
</thead>
<tbody>
<tr><td style="text-align: center">Alex</td><td>0</td><td>100</td></tr>
<tr><td style="text-align: center">Maria</td><td>0</td><td>50</td></tr>
<tr><td style="text-align: center">Alex</td><td>100</td><td>200</td></tr>
<tr><td style="text-align: center">Maria</td><td>50</td><td>50</td></tr>
</tbody>
</table>
</div>
<p>注意，因为 ‘Alex’ 被插入了两次，它出现了两次，并且 <code>previous</code> 和 <code>current</code> 值被正确设置。另外从 ‘Maria’ 读取也注册了一个先前到当前值没有变化的条目。</p>
<p>这种实现 <code>Felt252Dict&lt;T&gt;</code> 的方法意味着对于每个读/写操作，都会扫描整个条目列表以查找具有相同 <code>key</code> 的最后一个条目。一旦找到条目，它的 <code>new_value</code> 将被提取并用作要添加的新条目的 <code>previous_value</code>。这意味着与 <code>Felt252Dict&lt;T&gt;</code> 交互具有 <code>O(n)</code> 的最坏情况时间复杂度，其中 <code>n</code> 是列表中的条目数。</p>
<p>如果你仔细思考实现 <code>Felt252Dict&lt;T&gt;</code> 的替代方法，你肯定会找到它们，甚至可能完全放弃对 <code>previous_value</code> 字段的需求，尽管如此，由于 Cairo 不是你的普通语言，这行不通。Cairo 的目的之一是，使用 STARK 证明系统生成计算完整性的证明。这意味着你需要验证程序执行是正确的并且在 Cairo 限制的边界内。这些边界检查之一包括“字典压缩 (dictionary squashing)”，这需要每个条目的先前值和新值的信息。</p>
<h2 id="压缩字典-squashing-dictionaries"><a class="header" href="#压缩字典-squashing-dictionaries">压缩字典 (Squashing Dictionaries)</a></h2>
<p>为了验证使用 <code>Felt252Dict&lt;T&gt;</code> 的 Cairo 程序执行生成的证明是正确的，我们需要检查字典没有被非法篡改。这是通过一种名为 <code>squash_dict</code> 的方法完成的，该方法审查条目列表的每个条目，并检查对字典的访问在整个执行过程中保持连贯。</p>
<p>压缩的过程如下：给定所有具有特定键 <code>k</code> 的条目，按它们被插入的顺序排列，验证第 i 个条目的 <code>new_value</code> 是否等于第 i + 1 个条目的 <code>previous_value</code>。</p>
<p>例如，给定以下条目列表：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: center">key</th><th>previous</th><th>new</th></tr>
</thead>
<tbody>
<tr><td style="text-align: center">Alex</td><td>0</td><td>150</td></tr>
<tr><td style="text-align: center">Maria</td><td>0</td><td>100</td></tr>
<tr><td style="text-align: center">Charles</td><td>0</td><td>70</td></tr>
<tr><td style="text-align: center">Maria</td><td>100</td><td>250</td></tr>
<tr><td style="text-align: center">Alex</td><td>150</td><td>40</td></tr>
<tr><td style="text-align: center">Alex</td><td>40</td><td>300</td></tr>
<tr><td style="text-align: center">Maria</td><td>250</td><td>190</td></tr>
<tr><td style="text-align: center">Alex</td><td>300</td><td>90</td></tr>
</tbody>
</table>
</div>
<p>压缩后，条目列表将减少为：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: center">key</th><th>previous</th><th>new</th></tr>
</thead>
<tbody>
<tr><td style="text-align: center">Alex</td><td>0</td><td>90</td></tr>
<tr><td style="text-align: center">Maria</td><td>0</td><td>190</td></tr>
<tr><td style="text-align: center">Charles</td><td>0</td><td>70</td></tr>
</tbody>
</table>
</div>
<p>如果在第一个表中的任何值上有变化，压缩将在运行时失败。</p>
<h2 id="字典销毁-dictionary-destruction"><a class="header" href="#字典销毁-dictionary-destruction">字典销毁 (Dictionary Destruction)</a></h2>
<p>如果你运行 <a href="#basic-use-of-dictionaries">“字典的基本用法”</a> 部分的示例，你会注意到从未调用过字典压缩，但程序还是成功编译了。幕后发生的事情是，通过 <code>Destruct&lt;T&gt;</code> trait 的 <code>Felt252Dict&lt;T&gt;</code> 实现自动调用了压缩。此调用发生在 <code>balance</code> 字典超出作用域之前。</p>
<p><code>Destruct&lt;T&gt;</code> trait 代表了除了 <code>Drop&lt;T&gt;</code> 之外将实例移出作用域的另一种方式。这两者之间的主要区别是 <code>Drop&lt;T&gt;</code> 被视为无操作 (no-op)，这意味着它不生成新的 CASM，而 <code>Destruct&lt;T&gt;</code> 没有此限制。唯一主动使用 <code>Destruct&lt;T&gt;</code> trait 的类型是 <code>Felt252Dict&lt;T&gt;</code>，对于每种其他类型，<code>Destruct&lt;T&gt;</code> 和 <code>Drop&lt;T&gt;</code> 是同义词。你可以在附录 C 的 <a href="#drop-and-destruct">Drop 和 Destruct</a> 部分阅读更多关于这些 trait 的信息。</p>
<p>稍后在 <a href="#dictionaries-as-struct-members">“作为结构体成员的字典”</a> 部分，我们将有一个实践示例，我们将为自定义类型实现 <code>Destruct&lt;T&gt;</code> trait。</p>
<h2 id="更多字典"><a class="header" href="#更多字典">更多字典</a></h2>
<p>到目前为止，我们已经对 <code>Felt252Dict&lt;T&gt;</code> 的功能以及它为何以某种方式实现进行了全面的概述。如果你没有完全理解它，别担心，因为在本节中我们将有更多使用字典的例子。</p>
<p>我们将从解释 <code>entry</code> 方法开始，该方法是包含在 <code>Felt252DictTrait&lt;T&gt;</code> 中的字典基本功能的一部分，我们在开始时没有提到。之后不久，我们将看到如何将 <code>Felt252Dict&lt;T&gt;</code> 与其他 <a href="#dictionaries-of-types-not-supported-natively">复杂类型</a> 一起使用的例子，例如 <code>Array&lt;T&gt;</code>。</p>
<h2 id="entry-和-finalize"><a class="header" href="#entry-和-finalize">Entry 和 Finalize</a></h2>
<p>在 <a href="#dictionaries-underneath">“底层字典”</a> 部分，我们解释了 <code>Felt252Dict&lt;T&gt;</code> 在内部是如何工作的。它是每次以任何方式访问字典时的条目列表。它首先会根据给定的特定 <code>key</code> 找到最后一个条目，然后根据它正在执行的任何操作对其进行相应的更新。Cairo 语言为我们提供了通过 <code>entry</code> 和 <code>finalize</code> 方法自己复制此操作的工具。</p>
<p><code>entry</code> 方法作为 <code>Felt252DictTrait&lt;T&gt;</code> 的一部分出现，目的是根据给定键创建一个新条目。一旦调用，此方法获取字典的所有权并返回要更新的条目。方法签名如下：</p>
<pre><code class="language-cairo noplayground">fn entry(self: Felt252Dict&lt;T&gt;, key: felt252) -&gt; (Felt252DictEntry&lt;T&gt;, T) nopanic
</code></pre>
<p>第一个输入参数获取字典的所有权，而第二个参数用于创建适当的条目。它返回一个元组，其中包含 <code>Felt252DictEntry&lt;T&gt;</code>（Cairo 用于表示字典条目的类型）和一个表示先前保存的值的 <code>T</code>。<code>nopanic</code> 符号简单地表示该函数保证永远不会 panic。</p>
<p>接下来要做的是用新值更新条目。为此，我们使用 <code>finalize</code> 方法，该方法插入条目并返回字典的所有权：</p>
<pre><code class="language-cairo noplayground">fn finalize(self: Felt252DictEntry&lt;T&gt;, new_value: T) -&gt; Felt252Dict&lt;T&gt;
</code></pre>
<p>此方法接收条目和新值作为参数，并返回更新后的字典。</p>
<p>让我们看一个使用 <code>entry</code> 和 <code>finalize</code> 的例子。想象一下我们想实现我们自己的字典 <code>get</code> 方法版本。那么我们应该做以下事情：</p>
<ol>
<li>使用 <code>entry</code> 方法创建要添加的新条目。</li>
<li>将 <code>new_value</code> 等于 <code>previous_value</code> 的条目插回。</li>
<li>返回该值。</li>
</ol>
<p>实现我们的自定义 get 看起来像这样：</p>
<pre><code class="language-cairo noplayground">use core::dict::{Felt252Dict, Felt252DictEntryTrait};

fn custom_get&lt;T, +Felt252DictValue&lt;T&gt;, +Drop&lt;T&gt;, +Copy&lt;T&gt;&gt;(
    ref dict: Felt252Dict&lt;T&gt;, key: felt252,
) -&gt; T {
    // Get the new entry and the previous value held at `key`
    let (entry, prev_value) = dict.entry(key);

    // Store the value to return
    let return_value = prev_value;

    // Update the entry with `prev_value` and get back ownership of the dictionary
    dict = entry.finalize(prev_value);

    // Return the read value
    return_value
}
</code></pre>
<p><code>ref</code> 关键字意味着变量的所有权将在函数结束时归还。这个概念将在 <a href="#引用和快照-references-and-snapshots">“引用和快照”</a> 部分更详细地解释。</p>
<p>实现 <code>insert</code> 方法将遵循类似的工作流程，除了在定稿 (finalize) 时插入新值。如果我们实现它，它看起来像下面这样：</p>
<pre><code class="language-cairo noplayground">use core::dict::{Felt252Dict, Felt252DictEntryTrait};

fn custom_insert&lt;T, +Felt252DictValue&lt;T&gt;, +Destruct&lt;T&gt;, +Drop&lt;T&gt;&gt;(
    ref dict: Felt252Dict&lt;T&gt;, key: felt252, value: T,
) {
    // Get the last entry associated with `key`
    // Notice that if `key` does not exist, `_prev_value` will
    // be the default value of T.
    let (entry, _prev_value) = dict.entry(key);

    // Insert `entry` back in the dictionary with the updated value,
    // and receive ownership of the dictionary
    dict = entry.finalize(value);
}
</code></pre>
<p>作为最后的说明，这两个方法的实现方式与 <code>Felt252Dict&lt;T&gt;</code> 的 <code>insert</code> 和 <code>get</code> 的实现方式类似。此代码显示了一些用法示例：</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut dict: Felt252Dict&lt;u64&gt; = Default::default();

    custom_insert(ref dict, '0', 100);

    let val = custom_get(ref dict, '0');

    assert!(val == 100, "Expecting 100");
}
</code></pre>
<h2 id="原生不支持类型的字典"><a class="header" href="#原生不支持类型的字典">原生不支持类型的字典</a></h2>
<p>我们没有谈到的 <code>Felt252Dict&lt;T&gt;</code> 的一个限制是 <code>Felt252DictValue&lt;T&gt;</code> trait。此 trait 定义了 <code>zero_default</code> 方法，当字典中不存在值时会调用该方法。这是一些常见数据类型（如大多数无符号整数、<code>bool</code> 和 <code>felt252</code>）实现的——但它没有为更复杂的类型（如数组、结构体（包括 <code>u256</code>）和核心库中的其他类型）实现。这意味着制作原生不支持类型的字典不是一项简单的任务，因为你需要编写几个 trait 实现才能使数据类型成为有效的字典值类型。为了弥补这一点，你可以将你的类型包装在 <code>Nullable&lt;T&gt;</code> 中。</p>
<p><code>Nullable&lt;T&gt;</code> 是一个智能指针类型，在没有值的情况下，它可以指向一个值或是 <code>null</code>。它通常在面向对象编程语言中当引用不指向任何地方时使用。与 <code>Option</code> 的区别在于包装的值存储在 <code>Box&lt;T&gt;</code> 数据类型中。<code>Box&lt;T&gt;</code> 类型是一个智能指针，允许我们为数据使用专用的 <code>boxed_segment</code> 内存段，并使用一次只能在一个地方操作的指针访问此段。有关更多信息，请参阅 <a href="#智能指针">智能指针章节</a>。</p>
<p>让我们用一个例子来展示。我们将尝试在字典中存储一个 <code>Span&lt;felt252&gt;</code>。为此，我们将使用 <code>Nullable&lt;T&gt;</code> 和 <code>Box&lt;T&gt;</code>。此外，我们存储的是 <code>Span&lt;T&gt;</code> 而不是 <code>Array&lt;T&gt;</code>，因为后者没有实现从字典读取所需的 <code>Copy&lt;T&gt;</code> trait。</p>
<pre><code class="language-cairo noplayground">use core::dict::Felt252Dict;
use core::nullable::{FromNullableResult, NullableTrait, match_nullable};

#[executable]
fn main() {
    // Create the dictionary
    let mut d: Felt252Dict&lt;Nullable&lt;Span&lt;felt252&gt;&gt;&gt; = Default::default();

    // Create the array to insert
    let a = array![8, 9, 10];

    // Insert it as a `Span`
    d.insert(0, NullableTrait::new(a.span()));

//...
</code></pre>
<p>在此代码片段中，我们做的第一件事是创建一个新字典 <code>d</code>。我们要它保存一个 <code>Nullable&lt;Span&gt;</code>。在那之后，我们创建了一个数组并填入了值。</p>
<p>最后一步是将数组作为 span 插入字典中。注意我们使用 <code>NullableTrait</code> 的 <code>new</code> 函数来执行此操作。</p>
<p>一旦元素在字典中，并且我们要获取它，我们遵循相同的步骤但顺序相反。以下代码显示了如何实现这一点：</p>
<pre><code class="language-cairo noplayground">//...

    // Get value back
    let val = d.get(0);

    // Search the value and assert it is not null
    let span = match match_nullable(val) {
        FromNullableResult::Null =&gt; panic!("No value found"),
        FromNullableResult::NotNull(val) =&gt; val.unbox(),
    };

    // Verify we are having the right values
    assert!(*span.at(0) == 8, "Expecting 8");
    assert!(*span.at(1) == 9, "Expecting 9");
    assert!(*span.at(2) == 10, "Expecting 10");
}
</code></pre>
<p>在这里我们：</p>
<ol>
<li>使用 <code>get</code> 读取值。</li>
<li>使用 <code>match_nullable</code> 函数验证它非 null。</li>
<li>解包 box 内的值并断言它是正确的。</li>
</ol>
<p>完整的脚本看起来像这样：</p>
<pre><code class="language-cairo">// ANCHOR: imports
use core::dict::Felt252Dict;
use core::nullable::{FromNullableResult, NullableTrait, match_nullable};
// ANCHOR_END: imports

// ANCHOR: header
#[executable]
fn main() {
    // Create the dictionary
    let mut d: Felt252Dict&lt;Nullable&lt;Span&lt;felt252&gt;&gt;&gt; = Default::default();

    // Create the array to insert
    let a = array![8, 9, 10];

    // Insert it as a `Span`
    d.insert(0, NullableTrait::new(a.span()));
    // ANCHOR_END: header

    // ANCHOR: footer
    // Get value back
    let val = d.get(0);

    // Search the value and assert it is not null
    let span = match match_nullable(val) {
        FromNullableResult::Null =&gt; panic!("No value found"),
        FromNullableResult::NotNull(val) =&gt; val.unbox(),
    };

    // Verify we are having the right values
    assert!(*span.at(0) == 8, "Expecting 8");
    assert!(*span.at(1) == 9, "Expecting 9");
    assert!(*span.at(2) == 10, "Expecting 10");
}
// ANCHOR_END: footer

</code></pre>
<h2 id="在字典内使用数组"><a class="header" href="#在字典内使用数组">在字典内使用数组</a></h2>
<p>在上一节中，我们探索了如何使用 <code>Nullable&lt;T&gt;</code> 和 <code>Box&lt;T&gt;</code> 在字典中存储和检索复杂类型。现在，让我们看看如何在字典中存储数组并动态修改其内容。</p>
<p>在 Cairo 的字典中存储数组与存储其他类型略有不同。这是因为数组是更复杂的数据结构，需要特殊处理以避免内存复制和引用问题。</p>
<p>首先，让我们看看如何创建一个字典并将数组插入其中。这个过程非常直接，遵循与插入其他类型数据类似的模式：</p>
<pre><code class="language-cairo">use core::dict::Felt252Dict;

#[executable]
fn main() {
    let arr = array![20, 19, 26];
    let mut dict: Felt252Dict&lt;Nullable&lt;Array&lt;u8&gt;&gt;&gt; = Default::default();
    dict.insert(0, NullableTrait::new(arr));
    println!("Array inserted successfully.");
}
</code></pre>
<p>然而，试图使用 <code>get</code> 方法从字典中读取数组将导致编译器错误。这是因为 <code>get</code> 试图在内存中复制数组，这对数组来说是不可能的（正如我们已经在 <a href="#dictionaries-of-types-not-supported-natively">上一节</a> 中提到的，<code>Array&lt;T&gt;</code> 没有实现 <code>Copy&lt;T&gt;</code> trait）：</p>
<pre><code class="language-cairo">//TAG: does_not_compile
use core::dict::Felt252Dict;
use core::nullable::{FromNullableResult, match_nullable};

#[executable]
fn main() {
    let arr = array![20, 19, 26];
    let mut dict: Felt252Dict&lt;Nullable&lt;Array&lt;u8&gt;&gt;&gt; = Default::default();
    dict.insert(0, NullableTrait::new(arr));
    println!("Array: {:?}", get_array_entry(ref dict, 0));
}

fn get_array_entry(ref dict: Felt252Dict&lt;Nullable&lt;Array&lt;u8&gt;&gt;&gt;, index: felt252) -&gt; Span&lt;u8&gt; {
    let val = dict.get(0); // This will cause a compiler error
    let arr = match match_nullable(val) {
        FromNullableResult::Null =&gt; panic!("No value!"),
        FromNullableResult::NotNull(val) =&gt; val.unbox(),
    };
    arr.span()
}
</code></pre>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_15_dict_of_array_attempt_get v0.1.0 (listings/ch03-common-collections/no_listing_15_dict_of_array_attempt_get/Scarb.toml)
error: Trait has no implementation in context: core::traits::Copy::&lt;core::nullable::Nullable::&lt;core::array::Array::&lt;core::integer::u8&gt;&gt;&gt;.
 --&gt; listings/ch03-common-collections/no_listing_15_dict_of_array_attempt_get/src/lib.cairo:14:20
    let val = dict.get(0); // This will cause a compiler error
                   ^^^

error: could not compile `no_listing_15_dict_of_array_attempt_get` due to previous error
error: `scarb` command exited with error

</code></pre>
<p>为了正确地从字典中读取数组，我们需要使用字典条目。这允许我们获取数组值的引用而不复制它：</p>
<pre><code class="language-cairo noplayground">fn get_array_entry(ref dict: Felt252Dict&lt;Nullable&lt;Array&lt;u8&gt;&gt;&gt;, index: felt252) -&gt; Span&lt;u8&gt; {
    let (entry, _arr) = dict.entry(index);
    let mut arr = _arr.deref_or(array![]);
    let span = arr.span();
    dict = entry.finalize(NullableTrait::new(arr));
    span
}
</code></pre>
<blockquote>
<p>注意：我们必须在 finalize 条目之前将数组转换为 <code>Span</code>，因为调用 <code>NullableTrait::new(arr)</code> 会移动数组，从而使其无法从函数返回。</p>
</blockquote>
<p>要修改存储的数组，例如追加一个新值，我们可以使用类似的方法。下面的 <code>append_value</code> 函数演示了这一点：</p>
<pre><code class="language-cairo noplayground">fn append_value(ref dict: Felt252Dict&lt;Nullable&lt;Array&lt;u8&gt;&gt;&gt;, index: felt252, value: u8) {
    let (entry, arr) = dict.entry(index);
    let mut unboxed_val = arr.deref_or(array![]);
    unboxed_val.append(value);
    dict = entry.finalize(NullableTrait::new(unboxed_val));
}
</code></pre>
<p>在 <code>append_value</code> 函数中，我们访问字典条目，解引用数组，追加新值，并用更新的数组 finalize 条目。</p>
<blockquote>
<p>注意：从存储的数组中移除项目可以用类似的方式实现。</p>
</blockquote>
<p>下面是演示在字典中创建、插入、读取和修改数组的完整示例：</p>
<pre><code class="language-cairo">use core::dict::{Felt252Dict, Felt252DictEntryTrait};
use core::nullable::NullableTrait;

//ANCHOR: append
fn append_value(ref dict: Felt252Dict&lt;Nullable&lt;Array&lt;u8&gt;&gt;&gt;, index: felt252, value: u8) {
    let (entry, arr) = dict.entry(index);
    let mut unboxed_val = arr.deref_or(array![]);
    unboxed_val.append(value);
    dict = entry.finalize(NullableTrait::new(unboxed_val));
}
//ANCHOR_END: append

//ANCHOR: get
fn get_array_entry(ref dict: Felt252Dict&lt;Nullable&lt;Array&lt;u8&gt;&gt;&gt;, index: felt252) -&gt; Span&lt;u8&gt; {
    let (entry, _arr) = dict.entry(index);
    let mut arr = _arr.deref_or(array![]);
    let span = arr.span();
    dict = entry.finalize(NullableTrait::new(arr));
    span
}
//ANCHOR_END: get

#[executable]
fn main() {
    let arr = array![20, 19, 26];
    let mut dict: Felt252Dict&lt;Nullable&lt;Array&lt;u8&gt;&gt;&gt; = Default::default();
    dict.insert(0, NullableTrait::new(arr));
    println!("Before insertion: {:?}", get_array_entry(ref dict, 0));

    append_value(ref dict, 0, 30);

    println!("After insertion: {:?}", get_array_entry(ref dict, 0));
}
</code></pre>
<p>{{#quiz ../quizzes/ch03-02-dictionaries.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="理解-cairo-的所有权系统"><a class="header" href="#理解-cairo-的所有权系统">理解 Cairo 的所有权系统</a></h1>
<p>Cairo 是一门围绕线性类型系统构建的语言，这允许我们在静态上确保在每个 Cairo 程序中，一个值被确切地使用一次。这种线性类型系统通过确保导致此类错误的操作（例如两次写入同一个内存单元）在编译时被检测到，从而帮助预防运行时错误。这是通过实现所有权系统并默认禁止复制和丢弃值来实现的。在本章中，我们将讨论 Cairo 的所有权系统以及引用和快照。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="使用线性类型系统的所有权"><a class="header" href="#使用线性类型系统的所有权">使用线性类型系统的所有权</a></h1>
<p>Cairo 使用线性类型系统。在这种类型系统中，任何值（基本类型、结构体、枚举）必须被使用，而且只能被使用一次。这里的“使用”意味着该值要么 <em>被销毁 (destroyed)</em>，要么 <em>被移动 (moved)</em>。</p>
<p><em>销毁</em> 可以通过几种方式发生：</p>
<ul>
<li>变量超出作用域。</li>
<li>结构体被解构。</li>
<li>使用 <code>destruct()</code> 显式销毁。</li>
</ul>
<p><em>移动</em> 一个值仅仅意味着将该值传递给另一个函数。</p>
<p>这导致了与 Rust 所有权模型有些相似的约束，但也存在一些差异。特别是，Rust 所有权模型之所以存在，（部分）是为了避免数据竞争和对内存值的并发可变访问。这在 Cairo 中显然是不可能的，因为内存是不可变的。相反，Cairo 利用其线性类型系统主要用于两个目的：</p>
<ul>
<li>确保所有代码都是可证明的，因此是可验证的。</li>
<li>抽象掉 Cairo VM 的不可变内存。</li>
</ul>
<h3 id="所有权-ownership"><a class="header" href="#所有权-ownership">所有权 (Ownership)</a></h3>
<p>在 Cairo 中，所有权适用于 <em>变量</em> 而不适用于 <em>值</em>。一个值可以被许多不同的变量安全地引用（即使它们是可变变量），因为值本身总是不可变的。然而，变量可以是可变的，因此编译器必须确保常量变量不会被程序员意外修改。这使得谈论变量的所有权成为可能：所有者是可以读取（如果是可变的，则可以写入）该变量的代码。</p>
<p>这意味着变量（而非值）遵循与 Rust 值类似的规则：</p>
<ul>
<li>Cairo 中的每个变量都有一个所有者。</li>
<li>一次只能有一个所有者。</li>
<li>当所有者超出作用域时，变量将被销毁。</li>
</ul>
<p>现在我们已经过了基础的 Cairo 语法阶段，我们不会在示例中包含所有的 <code>fn main() {</code> 代码，所以如果你在跟着做，请确保手动将以下示例放在 main 函数内。结果是，我们的例子将更加简洁，让我们专注于实际细节而不是样板代码。</p>
<h2 id="变量作用域-variable-scope"><a class="header" href="#变量作用域-variable-scope">变量作用域 (Variable Scope)</a></h2>
<p>作为线性类型系统的第一个例子，我们将看一些变量的 <em>作用域</em>。作用域是程序中项目有效的范围。以这个变量为例：</p>
<pre><code class="language-cairo noplayground">let s = 'hello';
</code></pre>
<p>变量 <code>s</code> 引用一个短字符串。该变量从声明点开始直到当前 <em>作用域</em> 结束都是有效的。清单 {{#ref variable-scope}} 展示了一个带有注释的程序，注释说明了变量 <code>s</code> 何时有效。</p>
<pre><code class="language-cairo">    { // s is not valid here, it’s not yet declared
        let s = 'hello'; // s is valid from this point forward
        // do stuff with s
    } // this scope is now over, and s is no longer valid
</code></pre>
<p>{{#label variable-scope}} <span class="caption">清单 {{#ref variable-scope}}:
一个变量及其有效的作用域</span></p>
<p>换句话说，这里有两个重要时间点：</p>
<ul>
<li>当 <code>s</code> <em>进入</em> 作用域时，它是有效的。</li>
<li>它保持有效，直到它 <em>超出</em> 作用域。</li>
</ul>
<p>在这一点上，作用域与变量何时有效之间的关系与其他编程语言中的类似。现在我们将基于这一理解，使用我们在之前的 <a href="#数组">“数组”</a> 部分介绍的 <code>Array</code> 类型。</p>
<h3 id="移动值-moving-values"><a class="header" href="#移动值-moving-values">移动值 (Moving values)</a></h3>
<p>如前所述，<em>移动</em> 一个值仅仅意味着将该值传递给另一个函数。当这种情况发生时，原始作用域中引用该值的变量将被销毁并且不再可用，并且会创建一个新变量来持有相同的值。</p>
<p>数组是一个复杂类型的例子，当将其传递给另一个函数时会被移动。这是一个关于数组长什么样的简短提醒：</p>
<pre><code class="language-cairo">&lt;!-- Warning: Anchor '2' not found in lib.cairo --&gt;
</code></pre>
<p>类型系统如何确保 Cairo 程序永远不会尝试两次写入同一个内存单元？考虑下面的代码，我们尝试两次移除数组的前端：</p>
<pre><code class="language-cairo does_not_compile">//TAG: does_not_run
fn foo(mut arr: Array&lt;u128&gt;) {
    arr.pop_front();
}

#[executable]
fn main() {
    let arr: Array&lt;u128&gt; = array![];
    foo(arr);
    foo(arr);
}
</code></pre>
<p>在这种情况下，我们试图将相同的值（<code>arr</code> 变量中的数组）传递给两个函数调用。这意味着我们的代码试图两次移除第一个元素，这将会尝试两次写入同一个内存单元——这是 Cairo VM 禁止的，会导致运行时错误。值得庆幸的是，这段代码实际上不能编译。一旦我们将数组传递给 <code>foo</code> 函数，变量 <code>arr</code> 就不再可用了。我们会得到这个编译时错误，告诉我们需要 Array 实现 Copy Trait：</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_02_pass_array_by_value v0.1.0 (listings/ch04-understanding-ownership/no_listing_02_pass_array_by_value/Scarb.toml)
warn: Unhandled `#[must_use]` type `core::option::Option::&lt;core::integer::u128&gt;`
 --&gt; listings/ch04-understanding-ownership/no_listing_02_pass_array_by_value/src/lib.cairo:3:5
    arr.pop_front();
    ^^^^^^^^^^^^^^^

error: Variable was previously moved.
 --&gt; listings/ch04-understanding-ownership/no_listing_02_pass_array_by_value/src/lib.cairo:10:9
    foo(arr);
        ^^^
note: variable was previously used here:
  --&gt; listings/ch04-understanding-ownership/no_listing_02_pass_array_by_value/src/lib.cairo:9:9
    foo(arr);
        ^^^
note: Trait has no implementation in context: core::traits::Copy::&lt;core::array::Array::&lt;core::integer::u128&gt;&gt;.

error: could not compile `no_listing_02_pass_array_by_value` due to previous error
error: `scarb` command exited with error

</code></pre>
<h2 id="copy-trait"><a class="header" href="#copy-trait"><code>Copy</code> Trait</a></h2>
<p><code>Copy</code> trait 允许简单类型通过复制 felt 来复制，而无需分配新的内存段。这与 Cairo 默认的“移动”语义形成对比，后者转移值的所有权以确保内存安全并防止诸如对同一内存单元进行多次写入等问题。<code>Copy</code> 是为复制既安全又高效的类型实现的，绕过了移动语义的需要。像 <code>Array</code> 和 <code>Felt252Dict</code> 这样的类型不能实现 <code>Copy</code>，因为类型系统禁止在不同作用域中操作它们。</p>
<p>之前在 <a href="#数据类型">“数据类型”</a> 中描述的所有基本类型默认都实现了 <code>Copy</code> trait。</p>
<p>虽然数组和字典不能被复制，但不包含它们的自定义类型可以被复制。你可以通过在类型定义中添加 <code>#[derive(Copy)]</code> 注解来实现 <code>Copy</code> trait。然而，如果类型本身或其任何组件未实现 Copy trait，Cairo 将不允许该类型被注解为 Copy。</p>
<pre><code class="language-cairo ignore_format">#[derive(Copy, Drop)]
struct Point {
    x: u128,
    y: u128,
}

#[executable]
fn main() {
    let p1 = Point { x: 5, y: 10 };
    foo(p1);
    foo(p1);
}

fn foo(p: Point) { // do something with p
}
</code></pre>
<p>在这个例子中，我们可以将 <code>p1</code> 传递给 foo 函数两次，因为 <code>Point</code> 类型实现了 <code>Copy</code> trait。这意味着当我们把 <code>p1</code> 传递给 <code>foo</code> 时，我们实际上是在传递 <code>p1</code> 的副本，所以 <code>p1</code> 仍然有效。用所有权术语来说，这意味着 <code>p1</code> 的所有权仍然保留在 <code>main</code> 函数中。如果你从 <code>Point</code> 类型中移除 <code>Copy</code> trait 派生，你在尝试编译代码时会得到编译时错误。</p>
<p><em>不用担心 <code>Struct</code> 关键字。我们将在 <a href="#使用结构体组织相关数据">第 {{#chap using-structs-to-structure-related-data}} 章</a> 中介绍它。</em></p>
<h2 id="销毁值---feltdict-示例"><a class="header" href="#销毁值---feltdict-示例">销毁值 - FeltDict 示例</a></h2>
<p>线性类型被 <em>使用</em> 的另一种方式是被销毁。销毁必须确保‘资源’现在被正确释放。例如，在 Rust 中，这可能是关闭文件访问或锁定互斥锁。在 Cairo 中，具有这种行为的一种类型是 <code>Felt252Dict</code>。为了可证明性，字典在销毁时必须被‘压缩 (squashed)’。这很容易被忘记，所以它由类型系统和编译器强制执行。</p>
<h3 id="无操作销毁-no-op-destruction-drop-trait"><a class="header" href="#无操作销毁-no-op-destruction-drop-trait">无操作销毁 (No-op Destruction): <code>Drop</code> Trait</a></h3>
<p>你可能已经注意到前面例子中的 <code>Point</code> 类型也实现了 <code>Drop</code> trait。例如，下面的代码将无法编译，因为结构体 <code>A</code> 在超出作用域之前没有被移动或销毁：</p>
<pre><code class="language-cairo does_not_compile">//TAG: does_not_compile
struct A {}

#[executable]
fn main() {
    A {}; // error: Variable not dropped.
}
</code></pre>
<p>然而，实现了 <code>Drop</code> trait 的类型在超出作用域时会自动销毁。这种销毁什么也不做，它是无操作 (no-op)——仅仅是对编译器的提示，表明此类型一旦不再有用就可以安全销毁。我们称之为“丢弃 (dropping)”一个值。</p>
<p>目前，可以为所有类型派生 <code>Drop</code> 实现，允许它们在超出作用域时被丢弃，除了字典 (<code>Felt252Dict</code>) 和包含字典的类型。例如，下面的代码可以编译：</p>
<pre><code class="language-cairo">#[derive(Drop)]
struct A {}

#[executable]
fn main() {
    A {}; // Now there is no error.
}
</code></pre>
<h3 id="有副作用的销毁-destruct-trait"><a class="header" href="#有副作用的销毁-destruct-trait">有副作用的销毁: <code>Destruct</code> Trait</a></h3>
<p>当一个值被销毁时，编译器首先尝试在该类型上调用 <code>drop</code> 方法。如果它不存在，编译器则尝试调用 <code>destruct</code>。此方法由 <code>Destruct</code> trait 提供。</p>
<p>如前所述，Cairo 中的字典是在销毁时必须被“压缩”的类型，以便可以证明访问顺序。这对开发者来说很容易忘记，所以字典实现了 <code>Destruct</code> trait 以确保所有字典在超出作用域时都被 <em>压缩</em>。因此，以下示例将无法编译：</p>
<pre><code class="language-cairo does_not_compile">//TAG: does_not_compile
use core::dict::Felt252Dict;

struct A {
    dict: Felt252Dict&lt;u128&gt;,
}

#[executable]
fn main() {
    A { dict: Default::default() };
}
</code></pre>
<p>如果你尝试运行这段代码，你会得到一个编译时错误：</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_06_no_destruct_compile_fails v0.1.0 (listings/ch04-understanding-ownership/no_listing_06_no_destruct_compile_fails/Scarb.toml)
error: Variable not dropped.
 --&gt; listings/ch04-understanding-ownership/no_listing_06_no_destruct_compile_fails/src/lib.cairo:10:5
    A { dict: Default::default() };
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: Trait has no implementation in context: core::traits::Drop::&lt;no_listing_06_no_destruct_compile_fails::A&gt;.
note: Trait has no implementation in context: core::traits::Destruct::&lt;no_listing_06_no_destruct_compile_fails::A&gt;.

error: could not compile `no_listing_06_no_destruct_compile_fails` due to previous error
error: `scarb` command exited with error

</code></pre>
<p>当 <code>A</code> 超出作用域时，它不能被丢弃，因为它既没有实现 <code>Drop</code>（因为它包含一个字典且不能 <code>derive(Drop)</code>）也没有实现 <code>Destruct</code> trait。为了修复这个问题，我们可以为 <code>A</code> 类型派生 <code>Destruct</code> trait 实现：</p>
<pre><code class="language-cairo">use core::dict::Felt252Dict;

#[derive(Destruct)]
struct A {
    dict: Felt252Dict&lt;u128&gt;,
}

#[executable]
fn main() {
    A { dict: Default::default() }; // No error here
}
</code></pre>
<p>现在，当 <code>A</code> 超出作用域时，其字典将自动被 <code>squashed</code>，程序将可以编译。</p>
<h2 id="使用-clone-复制数组数据"><a class="header" href="#使用-clone-复制数组数据">使用 <code>clone</code> 复制数组数据</a></h2>
<p>如果我们 <em>确实</em> 想要深度复制 <code>Array</code> 的数据，我们可以使用一个称为 <code>clone</code> 的常用方法。我们将在 <a href="#方法语法">第 {{#chap using-structs-to-structure-related-data}} 章</a> 的专门部分讨论方法语法，但因为方法是许多编程语言中的常见特性，你可能以前见过它们。</p>
<p>这是一个 <code>clone</code> 方法的实际例子。</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let arr1: Array&lt;u128&gt; = array![];
    let arr2 = arr1.clone();
}
</code></pre>
<p>当你看到对 <code>clone</code> 的调用时，你知道正在执行一些任意代码，并且该代码可能很昂贵。这是一个视觉指示器，表明正在发生一些不同的事情。在这种情况下，<code>arr1</code> 引用的 <em>值</em> 被复制，导致使用了新的内存单元，并且创建了一个新的 <em>变量</em> <code>arr2</code>，引用新复制的值。</p>
<h2 id="返回值和作用域"><a class="header" href="#返回值和作用域">返回值和作用域</a></h2>
<p>返回值等同于 <em>移动</em> 它们。清单 {{#ref move-return-values}} 展示了一个返回某个值的函数示例，其注释与清单 {{#ref variable-scope}} 中的类似。</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo">//TAG: ignore_fmt
#[derive(Drop)]
struct A {}

#[executable]
fn main() {
    let a1 = gives_ownership();           // gives_ownership moves its return
                                          // value into a1

    let a2 = A {};                        // a2 comes into scope

    let a3 = takes_and_gives_back(a2);    // a2 is moved into
                                          // takes_and_gives_back, which also
                                          // moves its return value into a3

} // Here, a3 goes out of scope and is dropped. a2 was moved, so nothing
  // happens. a1 goes out of scope and is dropped.

fn gives_ownership() -&gt; A {               // gives_ownership will move its
                                          // return value into the function
                                          // that calls it

    let some_a = A {};                    // some_a comes into scope

    some_a                                // some_a is returned and
                                          // moves ownership to the calling
                                          // function
}

// This function takes an instance some_a of A and returns it
fn takes_and_gives_back(some_a: A) -&gt; A { // some_a comes into scope

    some_a                                // some_a is returned and
                                          // moves ownership to the calling
                                          // function
}
</code></pre>
<p>{{#label move-return-values}} <span class="caption">清单
{{#ref move-return-values}}: 移动返回值</span></p>
<p>虽然这行得通，但在每个函数中移入和移出都有些繁琐。如果我们想让一个函数使用一个值但不移动该值怎么办？如果我们想再次使用它，除了我们可能想作为返回值返回的函数体产生的任何数据之外，我们传入的任何东西也需要被传回，这非常烦人。</p>
<p>Cairo 确实允许我们使用元组返回多个值，如清单 {{#ref return-multiple-values}} 所示。</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let arr1: Array&lt;u128&gt; = array![];

    let (arr2, len) = calculate_length(arr1);
}

fn calculate_length(arr: Array&lt;u128&gt;) -&gt; (Array&lt;u128&gt;, usize) {
    let length = arr.len(); // len() returns the length of an array

    (arr, length)
}
</code></pre>
<p>{{#label return-multiple-values}} <span class="caption">清单
{{#ref return-multiple-values}}: 返回多个值</span></p>
<p>但这对于一个应该是通用的概念来说太繁琐了，而且要做很多工作。对我们来说幸运的是，Cairo 有两个特性可以通过不销毁或移动值来传递值，称为 <em>引用</em> 和 <em>快照</em>。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="引用和快照-references-and-snapshots"><a class="header" href="#引用和快照-references-and-snapshots">引用和快照 (References and Snapshots)</a></h1>
<p>前一个清单 {{#ref return-multiple-values}} 中的元组代码的问题在于，我们必须将 <code>Array</code> 返回给调用函数，以便我们在调用 <code>calculate_length</code> 之后仍然可以使用 <code>Array</code>，因为 <code>Array</code> 被移动到了 <code>calculate_length</code> 中。</p>
<h2 id="快照-snapshots"><a class="header" href="#快照-snapshots">快照 (Snapshots)</a></h2>
<p>在上一章中，我们讨论了 Cairo 的所有权系统如何阻止我们在移动变量后使用它，从而保护我们免受可能对同一内存单元进行两次写入的影响。然而，这不是很方便。让我们看看如何使用快照在调用函数中保留变量的所有权。</p>
<p>在 Cairo 中，快照是程序执行在某一时刻值的不可变视图。回想一下，内存是不可变的，所以修改变量实际上填充了一个新的内存单元。旧的内存单元仍然存在，快照是引用那个“旧”值的变量。在这个意义上，快照是“对过去的”视图。</p>
<p>这是你如何定义和使用一个 <code>calculate_area</code> 函数，它接受 <code>Rectangle</code> 结构体的快照作为参数，而不是获取底层值的所有权。在这个例子中，<code>calculate_area</code> 函数返回作为快照传递的 <code>Rectangle</code> 的面积。由于我们将它作为不可变视图传递，我们可以确定 <code>calculate_area</code> 不会改变 <code>Rectangle</code>，并且所有权保留在 <code>main</code> 函数中。</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo">#[derive(Drop)]
struct Rectangle {
    height: u64,
    width: u64,
}

#[executable]
fn main() {
    let mut rec = Rectangle { height: 3, width: 10 };
    let first_snapshot = @rec; // Take a snapshot of `rec` at this point in time
    rec.height = 5; // Mutate `rec` by changing its height
    let first_area = calculate_area(first_snapshot); // Calculate the area of the snapshot
    let second_area = calculate_area(@rec); // Calculate the current area
    println!("The area of the rectangle when the snapshot was taken is {}", first_area);
    println!("The current area of the rectangle is {}", second_area);
}

fn calculate_area(rec: @Rectangle) -&gt; u64 {
    *rec.height * *rec.width
}
</code></pre>
<blockquote>
<p>注意：访问快照的字段（例如 <code>rec.height</code>）会产生这些字段的快照，我们使用 <code>*</code> 对其进行去快照 (desnap) 以获取值。这在这里之所以有效是因为 <code>u64</code> 实现了 <code>Copy</code>。你将在下一节了解更多关于去快照的内容。</p>
</blockquote>
<p>这个程序的输出是：</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_09_snapshots v0.1.0 (listings/ch04-understanding-ownership/no_listing_09_snapshots/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing no_listing_09_snapshots
The area of the rectangle when the snapshot was taken is 30
The current area of the rectangle is 50


</code></pre>
<p>首先，注意变量声明和函数返回值中的所有元组代码都没了。其次，注意我们将 <code>@rec</code> 传入 <code>calculate_area</code>，并且在其定义中，我们接受 <code>@Rectangle</code> 而不是 <code>Rectangle</code>。</p>
<p>让我们仔细看看这里的函数调用：</p>
<pre><code class="language-cairo">let second_length = calculate_length(@arr1); // 计算当前数组的长度
</code></pre>
<p><code>@rec</code> 语法允许我们创建 <code>rec</code> 中值的快照。因为快照是执行在特定时刻值的不可变视图，所以不强制执行线性类型系统的通常规则。特别是，快照变量总是实现 <code>Drop</code> trait，从不实现 <code>Destruct</code> trait，即使是字典快照。</p>
<p>值得注意的是，<code>@T</code> 不是指针——快照是按值传递给函数的，就像普通变量一样。这意味着 <code>@T</code> 的大小与 <code>T</code> 的大小相同，当你将 <code>@rec</code> 传递给 <code>calculate_area</code> 时，整个结构体（在这种情况下，是具有两个 <code>u64</code> 字段的 <code>Rectangle</code>）被复制到了函数的堆栈中。对于大型数据结构，可以通过使用 <code>Box&lt;T&gt;</code> 来避免这种复制——这就提供了无需改变值的需求，我们将在 <a href="#智能指针">第 12 章</a> 中探讨这一点，但现在，请理解快照依赖于这种按值传递机制。</p>
<p>同样，函数签名使用 <code>@</code> 来指示参数 <code>arr</code> 的类型是快照。让我们添加一些解释性注释：</p>
<pre><code class="language-cairo noplayground">fn calculate_area(
    rec_snapshot: @Rectangle // rec_snapshot 是 Rectangle 的快照
) -&gt; u64 {
    *rec_snapshot.height * *rec_snapshot.width
} // 这里，rec_snapshot 超出作用域并被丢弃。
// 然而，因为它只是原始 `rec` 包含内容的视图，原始 `rec` 仍然可以使用。
</code></pre>
<p>变量 <code>rec_snapshot</code> 有效的作用域与任何函数参数的作用域相同，但是当 <code>rec_snapshot</code> 停止使用时，快照的底层值不会被丢弃。当函数拥有快照作为参数而不是实际值时，我们不需要返回值来归还原始值的所有权，因为我们从未拥有过它。</p>
<h3 id="去快照运算符-desnap-operator"><a class="header" href="#去快照运算符-desnap-operator">去快照运算符 (Desnap Operator)</a></h3>
<p>要将快照转换回普通变量，可以使用 <code>desnap</code> 运算符 <code>*</code>，它是 <code>@</code> 运算符的反义词。</p>
<p>只有 <code>Copy</code> 类型可以被去快照。然而，在一般情况下，因为值没有被修改，<code>desnap</code> 运算符创建的新变量复用了旧值，所以去快照是一个完全免费的操作，就像 <code>Copy</code> 一样。</p>
<p>在下面的例子中，我们想计算一个矩形的面积，但我们不想在 <code>calculate_area</code> 函数中获取矩形的所有权，因为我们可能想在函数调用后再次使用矩形。由于我们的函数不改变矩形实例，我们可以将矩形的快照传递给函数，然后使用 <code>desnap</code> 运算符 <code>*</code> 将快照转换回值。</p>
<pre><code class="language-cairo">#[derive(Drop)]
struct Rectangle {
    height: u64,
    width: u64,
}

#[executable]
fn main() {
    let rec = Rectangle { height: 3, width: 10 };
    let area = calculate_area(@rec);
    println!("Area: {}", area);
}

fn calculate_area(rec: @Rectangle) -&gt; u64 {
    // As rec is a snapshot to a Rectangle, its fields are also snapshots of the fields types.
    // We need to transform the snapshots back into values using the desnap operator `*`.
    // This is only possible if the type is copyable, which is the case for u64.
    // Here, `*` is used for both multiplying the height and width and for desnapping the snapshots.
    *rec.height * *rec.width
}
</code></pre>
<p>但是，如果我们尝试修改作为快照传递的东西会发生什么？尝试清单 {{#ref modify-snapshot}} 中的代码。剧透警告：它不起作用！</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo does_not_compile">//TAG: does_not_compile
#[derive(Copy, Drop)]
struct Rectangle {
    height: u64,
    width: u64,
}

#[executable]
fn main() {
    let rec = Rectangle { height: 3, width: 10 };
    flip(@rec);
}

fn flip(rec: @Rectangle) {
    let temp = rec.height;
    rec.height = rec.width;
    rec.width = temp;
}
</code></pre>
<p>{{#label modify-snapshot}}</p>
<p><span class="caption">清单 {{#ref modify-snapshot}}: 尝试修改快照值</span></p>
<p>这是错误：</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling listing_04_04 v0.1.0 (listings/ch04-understanding-ownership/listing_04_attempt_modifying_snapshot/Scarb.toml)
error: Invalid left-hand side of assignment.
 --&gt; listings/ch04-understanding-ownership/listing_04_attempt_modifying_snapshot/src/lib.cairo:16:5
    rec.height = rec.width;
    ^^^^^^^^^^

error: Invalid left-hand side of assignment.
 --&gt; listings/ch04-understanding-ownership/listing_04_attempt_modifying_snapshot/src/lib.cairo:17:5
    rec.width = temp;
    ^^^^^^^^^

error: could not compile `listing_04_04` due to previous error
error: `scarb` command exited with error

</code></pre>
<p>编译器阻止我们修改与快照关联的值。</p>
<h2 id="可变引用-mutable-references"><a class="header" href="#可变引用-mutable-references">可变引用 (Mutable References)</a></h2>
<p>我们可以通过使用 <em>可变引用</em> 而不是快照来实现我们在清单 {{#ref modify-snapshot}} 中想要的行为。可变引用实际上是传递给函数的可变值，它们在函数结束时隐式返回，将所有权归还给调用上下文。通过这样做，它们允许你改变传递的值，同时通过在执行结束时自动返回它来保持对它的所有权。在 Cairo 中，可以使用 <code>ref</code> 修饰符将参数作为 <em>可变引用</em> 传递。</p>
<blockquote>
<p><strong>注意</strong>: 在 Cairo 中，只有当变量用 <code>mut</code> 声明为可变时，参数才能使用 <code>ref</code> 修饰符作为 <em>可变引用</em> 传递。</p>
</blockquote>
<p>在清单 4-5 中，我们在 <code>flip</code> 函数中使用可变引用来修改 <code>Rectangle</code> 实例的 <code>height</code> 和 <code>width</code> 字段的值。</p>
<pre><code class="language-cairo">#[derive(Drop)]
struct Rectangle {
    height: u64,
    width: u64,
}

#[executable]
fn main() {
    let mut rec = Rectangle { height: 3, width: 10 };
    flip(ref rec);
    println!("height: {}, width: {}", rec.height, rec.width);
}

fn flip(ref rec: Rectangle) {
    let temp = rec.height;
    rec.height = rec.width;
    rec.width = temp;
}
</code></pre>
<p><span class="caption">清单 4-5: 使用可变引用修改值</span></p>
<p>首先，我们将 <code>rec</code> 更改为 <code>mut</code>。然后我们用 <code>ref rec</code> 将 <code>rec</code> 的可变引用传入 <code>flip</code>，并更新函数签名以接受带有 <code>ref rec: Rectangle</code> 的可变引用。这非常清楚地表明 <code>flip</code> 函数将改变作为参数传递的 <code>Rectangle</code> 实例的值。</p>
<p>与快照不同，可变引用允许突变，但像快照一样，<code>ref</code> 参数不是指针——它们也是按值传递的。当你传递 <code>ref rec</code> 时，无论是否实现 <code>Copy</code>，整个 <code>Rectangle</code> 类型都会被复制到函数的堆栈中。这确保了函数在其自己的数据本地版本上操作，然后隐式返回给调用者。为了避免对大型类型的这种复制，Cairo 提供了在 <a href="#智能指针">第 {{#chap smart-pointers}} 章</a> 中介绍的 <code>Box&lt;T&gt;</code> 类型作为替代方案，但在本例中，<code>ref</code> 修饰符完美地满足了我们的需求。</p>
<p>程序的输出是：</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling listing_04_05 v0.1.0 (listings/ch04-understanding-ownership/listing_05_mutable_reference/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing listing_04_05
height: 10, width: 3


</code></pre>
<p>正如预期的那样，<code>rec</code> 变量的 <code>height</code> 和 <code>width</code> 字段已被交换。</p>
<p>{{#quiz ../quizzes/ch04-02-references-and-snapshots.toml}}</p>
<h2 id="小结"><a class="header" href="#小结">小结</a></h2>
<p>让我们回顾一下我们讨论过的关于线性类型系统、所有权、快照和引用的内容：</p>
<ul>
<li>在任何给定时间，一个变量只能有一个所有者。</li>
<li>你可以通过按值 (by-value)、按快照 (by-snapshot) 或按引用 (by-reference) 将变量传递给函数。</li>
<li>如果你按值传递，变量的所有权将转移给函数。</li>
<li>如果你想保留变量的所有权并且知道你的函数不会改变它，你可以用 <code>@</code> 将其作为快照传递。</li>
<li>如果你想保留变量的所有权并且知道你的函数会改变它，你可以用 <code>ref</code> 将其作为可变引用传递。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="使用结构体组织相关数据"><a class="header" href="#使用结构体组织相关数据">使用结构体组织相关数据</a></h1>
<p>结构体 (struct)，或结构 (structure)，是一种自定义数据类型，允许我们将多个相关的值打包并命名，从而组成一个有意义的组。如果你熟悉面向对象的语言，结构体就像对象的属性数据。在本章中，我们将对比元组与结构体，以建立在你已知知识的基础上，并演示何时结构体是分组数据的更好方式。</p>
<p>我们将演示如何定义和实例化结构体。我们将讨论如何定义关联函数，特别是称为方法的那类关联函数，以指定与结构体类型相关的行为。结构体和枚举（在 <a href="#枚举">下一章</a> 中讨论）是在你的程序领域中创建新类型的构建块，以充分利用 Cairo 的编译时类型检查。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="定义并实例化结构体"><a class="header" href="#定义并实例化结构体">定义并实例化结构体</a></h1>
<p>结构体和我们在 <a href="#数据类型">数据类型</a> 部分讨论过的元组类似，它们都包含多个相关的值。和元组一样，结构体的每一部分可以是不同类型的。但不同于元组，结构体需要给每一部分数据命名，以便清楚它们表示什么。因为有了这些名字，结构体比元组更灵活：不需要依赖数据的顺序来指定或访问实例中的值。</p>
<p>定义结构体，需要使用 <code>struct</code> 关键字并为整个结构体命名。结构体的名字应该描述被组合在一起的数据的意义。然后，在花括号中，定义每一部分数据的名字和类型，我们称为字段 (field)。例如，清单 {{#ref user-struct}} 展示了一个存储用户账号信息的结构体。</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo noplayground">#[derive(Drop)]
struct User {
    active: bool,
    username: ByteArray,
    email: ByteArray,
    sign_in_count: u64,
}
</code></pre>
<p>{{#label user-struct}}</p>
<p><span class="caption">清单 {{#ref user-struct}}: <code>User</code> 结构体定义</span></p>
<blockquote>
<p><strong>注意 :</strong><br>你可以在结构体上派生多个 trait，例如用于比较的 <code>Drop</code>、<code>PartialEq</code> 和用于调试打印的 <code>Debug</code>。<br>请参阅 <a href="#附录-c---可派生-traits">附录：可派生 Traits</a> 以获取完整列表和示例。</p>
</blockquote>
<p>定义了结构体后，为了使用它，我们需要通过为每个字段指定具体值来创建该结构体的 <em>实例</em>。我们通过声明结构体的名字，然后添加包含 <em>key: value</em> 对的花括号来创建实例，其中键是字段的名字，值是我们想要存储在这些字段中的数据。我们不需要按照在结构体中声明的顺序指定字段。换句话说，结构体定义就像是类型的通用模板，而实例则用特定数据填充该模板以创建该类型的值。</p>
<p>例如，我们可以声明两个特定的用户，如清单 {{#ref user-instances}} 所示。</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo">// ANCHOR: user
#[derive(Drop)]
struct User {
    active: bool,
    username: ByteArray,
    email: ByteArray,
    sign_in_count: u64,
}
// ANCHOR_END: user

// ANCHOR: main
#[executable]
fn main() {
    let user1 = User {
        active: true, username: "someusername123", email: "someone@example.com", sign_in_count: 1,
    };
    let user2 = User {
        sign_in_count: 1, username: "someusername123", active: true, email: "someone@example.com",
    };
}
// ANCHOR_END: main

</code></pre>
<p>{{#label user-instances}} <span class="caption">清单 {{#ref user-instances}}:
创建 <code>User</code> 结构体的两个实例</span></p>
<p>要从结构体中获取特定值，我们使用点号。例如，要访问 <code>user1</code> 的电子邮件地址，我们使用 <code>user1.email</code>。如果实例是可变的，我们可以通过使用点号并赋值给特定字段来更改值。清单 {{#ref user-mut}} 展示了如何更改可变 <code>User</code> 实例的 <code>email</code> 字段中的值。</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut user1 = User {
        active: true, username: "someusername123", email: "someone@example.com", sign_in_count: 1,
    };
    user1.email = "anotheremail@example.com";
}
</code></pre>
<p>{{#label user-mut}} <span class="caption">清单 {{#ref user-mut}}: 更改 <code>User</code> 实例 <code>email</code> 字段的值</span></p>
<p>注意整个实例必须是可变的；Cairo 不允许我们仅将某些字段标记为可变。</p>
<p>和任何表达式一样，我们可以构造一个新的结构体实例作为函数体的最后一个表达式，以隐式返回该新实例。</p>
<p>清单 {{#ref build-user}} 展示了一个 <code>build_user</code> 函数，它返回一个带有给定电子邮件和用户名的 <code>User</code> 实例。<code>active</code> 字段的值为 <code>true</code>，<code>sign_in_count</code> 的值为 <code>1</code>。</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo">fn build_user(email: ByteArray, username: ByteArray) -&gt; User {
    User { active: true, username: username, email: email, sign_in_count: 1 }
}
</code></pre>
<p>{{#label build-user}} <span class="caption">清单 {{#ref build-user}}: 一个 <code>build_user</code> 函数，它接受电子邮件和用户名并返回一个 <code>User</code> 实例。</span></p>
<p>使用与结构体字段相同的名称来命名函数参数是有意义的，但是必须重复 <code>email</code> 和 <code>username</code> 字段名称和变量有点繁琐。如果结构体有更多字段，重复每个名称会变得更加烦人。幸运的是，有一个方便的简写！</p>
<h2 id="使用字段初始化简写"><a class="header" href="#使用字段初始化简写">使用字段初始化简写</a></h2>
<p>因为清单 {{#ref build-user}} 中的参数名称和结构体字段名称完全相同，我们可以使用字段初始化简写语法重写 <code>build_user</code>，使其行为完全相同，但没有 <code>username</code> 和 <code>email</code> 的重复，如清单 {{#ref init-shorthand}} 所示。</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo">fn build_user_short(email: ByteArray, username: ByteArray) -&gt; User {
    User { active: true, username, email, sign_in_count: 1 }
}
</code></pre>
<p>{{#label init-shorthand}} <span class="caption">清单 {{#ref init-shorthand}}:
一个使用字段初始化简写的 <code>build_user</code> 函数，因为 <code>username</code> 和 <code>email</code> 参数与结构体字段名称相同。</span></p>
<p>在这里，我们正在创建一个 <code>User</code> 结构体的新实例，它有一个名为 <code>email</code> 的字段。我们想要将 <code>email</code> 字段的值设置为 <code>build_user</code> 函数的 <code>email</code> 参数中的值。因为 <code>email</code> 字段和 <code>email</code> 参数具有相同的名称，我们只需要写 <code>email</code> 而不是 <code>email: email</code>。</p>
<h2 id="使用结构体更新语法从其他实例创建实例"><a class="header" href="#使用结构体更新语法从其他实例创建实例">使用结构体更新语法从其他实例创建实例</a></h2>
<p>创建一个新结构体实例，其中包含来自另一个实例的大部分值，但更改了一些值，这通常很有用。你可以使用 <em>结构体更新语法</em> 来做到这一点。</p>
<p>首先，在清单 {{#ref without-update-syntax}} 中，我们展示了如何在 <code>user2</code> 中常规创建一个新的 <code>User</code> 实例，而不使用更新语法。我们要为 <code>email</code> 设置一个新值，但在其他方面使用我们在清单 {{#ref user-instances}} 中创建的 <code>user1</code> 中的相同值。</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo">#[executable]
fn main() {
    // --snip--

    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: "another@example.com",
        sign_in_count: user1.sign_in_count,
    };
}
</code></pre>
<p>{{#label without-update-syntax}}</p>
<p><span class="caption">清单 {{#ref without-update-syntax}}: 使用 <code>user1</code> 中的除一个值之外的所有值创建一个新的 <code>User</code> 实例</span></p>
<p>使用结构体更新语法，我们可以用更少的代码实现相同的效果，如清单 {{#ref update-syntax}} 所示。语法 <code>..</code> 指定未显式设置的剩余字段应具有与给定实例中的字段相同的值。</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo">#[executable]
fn main() {
    // --snip--

    let user2 = User { email: "another@example.com", ..user1 };
}
</code></pre>
<p>{{#label update-syntax}}</p>
<p><span class="caption">清单 {{#ref update-syntax}}: 使用结构体更新语法为一个 <code>User</code> 实例设置新的 <code>email</code> 值，但使用 <code>user1</code> 中的其余值</span></p>
<p>清单 {{#ref update-syntax}} 中的代码也创建了一个 <code>user2</code> 实例，它的 <code>email</code> 值不同，但在 <code>username</code>、<code>active</code> 和 <code>sign_in_count</code> 字段上的值与 <code>user1</code> 相同。<code>..user1</code> 部分必须放在最后，以指定任何剩余字段应从 <code>user1</code> 中的相应字段获取其值，但我们可以选择以任何顺序为任意数量的字段指定值，而不管结构体定义中字段的顺序如何。</p>
<p>注意结构体更新语法像赋值一样使用 <code>=</code>；这是因为它移动了数据，就像我们在 <a href="#moving-values">“移动值”</a><!-- ignore --> 部分看到的那样。在这个例子中，我们在创建 <code>user2</code> 后不能再作为一个整体使用 <code>user1</code>，因为 <code>user1</code> 的 <code>username</code> 字段中的 <code>ByteArray</code> 被移入到了 <code>user2</code> 中。如果我们给 <code>user2</code> 的 <code>email</code> 和 <code>username</code> 都提供了新的 <code>ByteArray</code> 值，从而只使用了 <code>user1</code> 中的 <code>active</code> 和 <code>sign_in_count</code> 值，那么 <code>user1</code> 在创建 <code>user2</code> 后仍然有效。<code>active</code> 和 <code>sign_in_count</code> 都是实现了 <code>Copy</code> trait 的类型，所以我们在 <a href="#the-copy-trait">“<code>Copy</code> Trait”</a><!-- ignore --> 部分讨论的行为将适用。</p>
<p>{{#quiz ../quizzes/ch05-01-defining-and-instantiating-structs.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="一个使用结构体的示例程序"><a class="header" href="#一个使用结构体的示例程序">一个使用结构体的示例程序</a></h1>
<p>为了理解我们何时可能想使用结构体，让我们编写一个计算矩形面积的程序。我们将从使用单个变量开始，然后重构程序直到我们使用结构体代替。</p>
<p>让我们用 Scarb 创建一个名为 <em>rectangles</em> 的新项目，该项目将获取以像素为单位指定的矩形的宽度和高度，并计算矩形的面积。清单 {{#ref area-fn}} 展示了一个在我们的项目 <em>src/lib.cairo</em> 中实现此目的的一种方法的简短程序。</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let width = 30;
    let height = 10;
    let area = area(width, height);
    println!("Area is {}", area);
}

//ANCHOR: here
fn area(width: u64, height: u64) -&gt; u64 {
    //ANCHOR_END: here
    width * height
}
</code></pre>
<p>{{#label area-fn}} <span class="caption">清单 {{#ref area-fn}}: 计算由单独的宽度和高度变量指定的矩形的面积。</span></p>
<p>现在用 <code>scarb execute</code> 运行程序：</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling listing_04_06_no_struct v0.1.0 (listings/ch05-using-structs-to-structure-related-data/listing_03_no_struct/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing listing_04_06_no_struct
Area is 300


</code></pre>
<p>这段代码通过用每个维度调用 <code>area</code> 函数成功地计算出了矩形的面积，但我们可以做得更多，使这段代码更清晰、更易读。</p>
<p>这段代码的问题在 <code>area</code> 的签名中显而易见：</p>
<pre><code class="language-cairo noplayground">fn area(width: u64, height: u64) -&gt; u64 {
</code></pre>
<p><code>area</code> 函数应该计算一个矩形的面积，但我们要编写的函数有两个参数，而且在我们的程序中没有任何地方明确表明这些参数是相关的。将宽度和高度组合在一起会更易读、更易于管理。我们在 <a href="#the-tuple-type">第 {{#chap common-programming-concepts}} 章的元组部分</a> 中已经讨论过一种可能的方法。</p>
<h2 id="使用元组重构"><a class="header" href="#使用元组重构">使用元组重构</a></h2>
<p>清单 {{#ref rectangle-tuple}} 展示了我们程序的另一个使用元组的版本。</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let rectangle = (30, 10);
    let area = area(rectangle);
    println!("Area is {}", area);
}

fn area(dimension: (u64, u64)) -&gt; u64 {
    let (x, y) = dimension;
    x * y
}
</code></pre>
<p>{{#label rectangle-tuple}} <span class="caption">清单
{{#ref rectangle-tuple}}: 使用元组指定矩形的宽度和高度。</span></p>
<p>在某种程度上，这个程序更好了。元组让我们增加了一点结构，而且我们现在只传递一个参数。但在另一种方式上，这个版本不太清晰：元组没有给它们的元素命名，所以我们必须索引到元组的部分，这使得我们的计算不那么明显。</p>
<p>混淆宽度和高度对于面积计算没有影响，但如果我们想计算差值，那就有影响了！我们必须记住 <code>width</code> 是元组索引 <code>0</code>，<code>height</code> 是元组索引 <code>1</code>。如果别人要使用我们的代码，这也将更难弄清楚并记住。因为我们没有在代码中传达数据的含义，现在更容易引入错误。</p>
<h2 id="使用结构体重构增加更多意义"><a class="header" href="#使用结构体重构增加更多意义">使用结构体重构：增加更多意义</a></h2>
<p>我们使用结构体通过标记数据来增加意义。我们可以将我们正在使用的元组转换为一个结构体，并为整体命名，也为部分命名。</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo">struct Rectangle {
    width: u64,
    height: u64,
}

#[executable]
fn main() {
    let rectangle = Rectangle { width: 30, height: 10 };
    let area = area(rectangle);
    println!("Area is {}", area);
}

fn area(rectangle: Rectangle) -&gt; u64 {
    rectangle.width * rectangle.height
}
</code></pre>
<p>{{#label rectangle-struct}} <span class="caption">清单
{{#ref rectangle-struct}}: 定义一个 <code>Rectangle</code> 结构体。</span></p>
<p>在这里我们定义了一个结构体并将其命名为 <code>Rectangle</code>。在花括号内，我们将字段定义为 <code>width</code> 和 <code>height</code>，它们的类型都是 <code>u64</code>。然后，在 <code>main</code> 中，我们创建了一个特定的 <code>Rectangle</code> 实例，它的宽度为 <code>30</code>，高度为 <code>10</code>。我们的 <code>area</code> 函数现在被定义为有一个参数，我们将其命名为 <code>rectangle</code>，其类型为 <code>Rectangle</code> 结构体。然后我们可以用点号访问实例的字段，这给值提供了描述性的名称，而不是使用元组索引值 <code>0</code> 和 <code>1</code>。</p>
<h2 id="自定义类型的转换"><a class="header" href="#自定义类型的转换">自定义类型的转换</a></h2>
<p>我们已经描述了如何对内置类型执行类型转换，请参见 <a href="#type-conversion">数据类型 &gt; 类型转换</a>。在本节中，我们将看到如何为自定义类型定义转换。</p>
<blockquote>
<p>注意：也可以为复合类型（例如元组）定义转换。</p>
</blockquote>
<h3 id="into-1"><a class="header" href="#into-1">Into</a></h3>
<p>使用 <code>Into</code> trait 为自定义类型定义转换通常需要指定要转换为的类型，因为编译器大多数时候无法确定这一点。然而，考虑到我们要免费获得的功能，这是一个很小的权衡。</p>
<pre><code class="language-cairo">#[derive(Drop, PartialEq)]
struct Rectangle {
    width: u64,
    height: u64,
}

#[derive(Drop)]
struct Square {
    side_length: u64,
}

impl SquareIntoRectangle of Into&lt;Square, Rectangle&gt; {
    fn into(self: Square) -&gt; Rectangle {
        Rectangle { width: self.side_length, height: self.side_length }
    }
}

#[executable]
fn main() {
    let square = Square { side_length: 5 };
    // Compiler will complain if you remove the type annotation
    let result: Rectangle = square.into();
    let expected = Rectangle { width: 5, height: 5 };
    assert!(
        result == expected,
        "A square is always convertible to a rectangle with the same width and height!",
    );
}
</code></pre>
<h3 id="tryinto-1"><a class="header" href="#tryinto-1">TryInto</a></h3>
<p>为 <code>TryInto</code> 定义转换类似于为 <code>Into</code> 定义。</p>
<pre><code class="language-cairo">#[derive(Drop)]
struct Rectangle {
    width: u64,
    height: u64,
}

#[derive(Drop, PartialEq)]
struct Square {
    side_length: u64,
}

impl RectangleIntoSquare of TryInto&lt;Rectangle, Square&gt; {
    fn try_into(self: Rectangle) -&gt; Option&lt;Square&gt; {
        if self.height == self.width {
            Some(Square { side_length: self.height })
        } else {
            None
        }
    }
}

#[executable]
fn main() {
    let rectangle = Rectangle { width: 8, height: 8 };
    let result: Square = rectangle.try_into().unwrap();
    let expected = Square { side_length: 8 };
    assert!(
        result == expected,
        "Rectangle with equal width and height should be convertible to a square.",
    );

    let rectangle = Rectangle { width: 5, height: 8 };
    let result: Option&lt;Square&gt; = rectangle.try_into();
    assert!(
        result.is_none(),
        "Rectangle with different width and height should not be convertible to a square.",
    );
}
</code></pre>
<p>{{#quiz ../quizzes/ch05-02-an-example-program-using-structs.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="方法语法"><a class="header" href="#方法语法">方法语法</a></h1>
<p><em>方法 (Methods)</em> 与函数类似：我们使用 <code>fn</code> 关键字和名称声明它们，它们可以有参数和返回值，并且包含在从别处调用该方法时运行的代码。与函数不同，方法是在结构体（或枚举，我们将在 <a href="#枚举">第 {{#chap enums-and-pattern-matching}} 章</a> 中介绍）的上下文中定义的，并且它们的第一个参数总是 <code>self</code>，它代表调用该方法的类型的实例。</p>
<h2 id="定义方法"><a class="header" href="#定义方法">定义方法</a></h2>
<p>让我们改变以 <code>Rectangle</code> 实例为参数的 <code>area</code> 函数，改为在 <code>Rectangle</code> 结构体上定义一个 <code>area</code> 方法，如清单 {{#ref area-method}} 所示。</p>
<pre><code class="language-cairo noplayground">#[derive(Copy, Drop)]
struct Rectangle {
    width: u64,
    height: u64,
}

//ANCHOR: trait_definition
trait RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64;
}
//ANCHOR_END: trait_definition

//ANCHOR: trait_implementation
impl RectangleImpl of RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64 {
        (*self.width) * (*self.height)
    }
}
//ANCHOR_END: trait_implementation

//ANCHOR: main
#[executable]
fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    println!("Area is {}", rect1.area());
}
//ANCHOR_END: main
</code></pre>
<p>{{#label area-method}} 清单 {{#ref area-method}}: 在 <code>Rectangle</code> 结构体上定义 <code>area</code> 方法。</p>
<p>要在 <code>Rectangle</code> 的上下文中定义函数，我们需要为 <code>RectangleTrait</code> trait 启动一个 <code>impl</code>（实现）块，该 trait 定义了可以在 <code>Rectangle</code> 实例上调用的方法。由于只能为 trait 而不能为类型定义 impl 块，我们需要首先定义这个 trait - 但它不打算用于任何其他事情。</p>
<p>此 <code>impl</code> 块内的所有内容都将与 <code>Rectangle</code> 类型相关联。然后我们将 <code>area</code> 函数移到 <code>impl</code> 花括号内，并将签名中和主体内各处的第一个（在这种情况下是唯一的）参数更改为 <code>self</code>。在 <code>main</code> 中，我们之前调用 <code>area</code> 函数并将 <code>rect1</code> 作为参数传递的地方，我们现在可以使用 <em>方法语法</em> 在我们的 <code>Rectangle</code> 实例上调用 <code>area</code> 方法。方法语法在实例之后：我们添加一个点，后跟方法名称、括号和任何参数。</p>
<p>在 <code>area</code> 的签名中，我们使用 <code>self: @Rectangle</code> 而不是 <code>rectangle: @Rectangle</code>。方法必须有一个名为 <code>self</code> 的参数作为它们的第一个参数，<code>self</code> 的类型指示了可以调用该方法的类型。方法可以获取 <code>self</code> 的所有权，但 <code>self</code> 也可以像任何其他参数一样通过快照或引用传递。</p>
<blockquote>
<p>类型和 trait 之间没有直接联系。只有方法的 <code>self</code> 参数的类型定义了可以调用此方法的类型。这意味着，从技术上讲，可以在同一个 trait 中定义多个类型的方法（例如混合 <code>Rectangle</code> 和 <code>Circle</code> 方法）。但 <strong>这不是推荐的做法</strong>，因为它会导致混淆。</p>
</blockquote>
<p>使用方法而不是函数的主要原因，除了提供方法语法外，还在于组织。我们将所有可以用一个类型的实例做的事情放在一个 <code>impl</code> 块中，而不是让我们代码的未来用户在我们提供的库中的各个地方搜索 <code>Rectangle</code> 的功能。</p>
<h2 id="generate_trait-属性"><a class="header" href="#generate_trait-属性"><code>generate_trait</code> 属性</a></h2>
<p>如果你熟悉 Rust，你可能会觉得 Cairo 的方法令人困惑，因为方法不能直接在类型上定义。相反，你必须定义一个 <a href="#cairo-中的-traits">trait</a>，并实现与该方法预期的类型相关联的此 trait。然而，定义一个 trait 然后实现它以在特定类型上定义方法是冗长的，并且不必要的：trait 本身不会被重用。</p>
<p>因此，为了避免定义无用的 trait，Cairo 提供了 <code>#[generate_trait]</code> 属性添加到 trait 实现上方，这告诉编译器为你生成相应的 trait 定义，并让你只关注实现。这两种方法是等效的，但在这种情况下不显式定义 trait 被认为是最佳实践。</p>
<p>前一个例子也可以写成如下形式：</p>
<pre><code class="language-cairo">#[derive(Copy, Drop)]
struct Rectangle {
    width: u64,
    height: u64,
}

#[generate_trait]
impl RectangleImpl of RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64 {
        (*self.width) * (*self.height)
    }
}

#[executable]
fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    println!("Area is {}", rect1.area());
}
</code></pre>
<p>让我们在接下来的章节中使用这个 <code>#[generate_trait]</code> 来使我们的代码更清晰。</p>
<h2 id="快照和引用"><a class="header" href="#快照和引用">快照和引用</a></h2>
<p>由于 <code>area</code> 方法不修改调用实例，<code>self</code> 被声明为使用 <code>@</code> 快照运算符的 <code>Rectangle</code> 实例的快照。但是，当然，我们也可以定义一些接收此实例的可变引用的方法，以便能够修改它。</p>
<p>让我们编写一个新方法 <code>scale</code>，它使用作为参数给出的 <code>factor</code> 来调整矩形的大小：</p>
<pre><code class="language-cairo">#[generate_trait]
impl RectangleImpl of RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64 {
        (*self.width) * (*self.height)
    }
    fn scale(ref self: Rectangle, factor: u64) {
        self.width *= factor;
        self.height *= factor;
    }
}

#[executable]
fn main() {
    let mut rect2 = Rectangle { width: 10, height: 20 };
    rect2.scale(2);
    println!("The new size is (width: {}, height: {})", rect2.width, rect2.height);
}
</code></pre>
<p>也可以通过仅使用 <code>self</code> 作为第一个参数来定义获取实例所有权的方法，但这很少见。这种技术通常在方法将 <code>self</code> 转换为其他东西并且你想防止调用者在转换后使用原始实例时使用。</p>
<p>查看 <a href="#理解-cairo-的所有权系统">理解所有权</a> 章节以获取有关这些重要概念的更多详细信息。</p>
<h2 id="多个参数的方法"><a class="header" href="#多个参数的方法">多个参数的方法</a></h2>
<p>让我们通过在 <code>Rectangle</code> 结构体上实现另一个方法来练习使用方法。这次我们要编写方法 <code>can_hold</code>，它接受另一个 <code>Rectangle</code> 实例，如果此矩形可以完全容纳在 self 内，则返回 <code>true</code>；否则，它应该返回 false。</p>
<pre><code class="language-cairo">#[generate_trait]
impl RectangleImpl of RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64 {
        *self.width * *self.height
    }

    fn scale(ref self: Rectangle, factor: u64) {
        self.width *= factor;
        self.height *= factor;
    }

    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool {
        *self.width &gt; *other.width &amp;&amp; *self.height &gt; *other.height
    }
}

#[executable]
fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 10, height: 40 };
    let rect3 = Rectangle { width: 60, height: 45 };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(@rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(@rect3));
}
</code></pre>
<p>在这里，我们期望 <code>rect1</code> 可以容纳 <code>rect2</code> 但不能容纳 <code>rect3</code>。</p>
<h2 id="关联函数"><a class="header" href="#关联函数">关联函数</a></h2>
<p>我们称在与特定类型关联的 <code>impl</code> 块内定义的所有函数为 <em>关联函数 (Associated functions)</em>。虽然编译器不强制执行此操作，但将与同一类型相关的关联函数保留在同一 <code>impl</code> 块中是一个好习惯 - 例如，所有与 <code>Rectangle</code> 相关的函数都将分组在 <code>RectangleTrait</code> 的同一 <code>impl</code> 块中。</p>
<p>方法是一种特殊类型的关联函数，但我们也可以定义没有 <code>self</code> 作为其第一个参数的关联函数（因此不是方法），因为它们不需要该类型的实例来工作，但仍与该类型相关联。</p>
<p>不是方法的关联函数通常用于将返回类型新实例的构造函数。这些通常被称为 <code>new</code>，但 <code>new</code> 不是一个特殊的名称，也不是语言内置的。例如，我们可以选择提供一个名为 <code>square</code> 的关联函数，该函数将具有一个维度参数并将其用作宽度和高度，从而使创建正方形 <code>Rectangle</code> 更容易，而不必指定相同的值两次：</p>
<p>让我们创建函数 <code>new</code>，它从 <code>width</code> 和 <code>height</code> 创建一个 <code>Rectangle</code>；<code>square</code>，它从 <code>size</code> 创建一个正方形 <code>Rectangle</code>；以及 <code>avg</code>，它计算两个 <code>Rectangle</code> 实例的平均值：</p>
<pre><code class="language-cairo">#[generate_trait]
impl RectangleImpl of RectangleTrait {
    fn area(self: @Rectangle) -&gt; u64 {
        (*self.width) * (*self.height)
    }

    fn new(width: u64, height: u64) -&gt; Rectangle {
        Rectangle { width, height }
    }

    fn square(size: u64) -&gt; Rectangle {
        Rectangle { width: size, height: size }
    }

    fn avg(lhs: @Rectangle, rhs: @Rectangle) -&gt; Rectangle {
        Rectangle {
            width: ((*lhs.width) + (*rhs.width)) / 2, height: ((*lhs.height) + (*rhs.height)) / 2,
        }
    }
}

#[executable]
fn main() {
    let rect1 = RectangleTrait::new(30, 50);
    let rect2 = RectangleTrait::square(10);

    println!(
        "The average Rectangle of {:?} and {:?} is {:?}",
        @rect1,
        @rect2,
        RectangleTrait::avg(@rect1, @rect2),
    );
}
</code></pre>
<p>要调用 <code>square</code> 关联函数，我们使用带有结构体名称的 <code>::</code> 语法；<code>let sq = RectangleTrait::square(3);</code> 就是一个例子。此函数由 trait 命名空间化：<code>::</code> 语法用于关联函数和模块创建的命名空间。我们将在 <a href="#定义模块以控制作用域">第 7 章</a> 讨论模块。</p>
<p>注意 <code>avg</code> 函数也可以写成以第一个矩形为 <code>self</code> 的方法等。在这种情况下，它将不使用 <code>RectangleTrait::avg(@rect1, @rect2)</code>，而是通过 <code>rect1.avg(rect2)</code> 调用。</p>
<h2 id="多个-traits-和-impl-块"><a class="header" href="#多个-traits-和-impl-块">多个 Traits 和 <code>impl</code> 块</a></h2>
<p>每个结构体允许有多个 <code>trait</code> 和 <code>impl</code> 块。例如，以下代码等同于 <em>多个参数的方法</em> 部分中显示的代码，该部分将每个方法放在自己的 <code>trait</code> 和 <code>impl</code> 块中。</p>
<pre><code class="language-cairo">#[generate_trait]
impl RectangleCalcImpl of RectangleCalc {
    fn area(self: @Rectangle) -&gt; u64 {
        (*self.width) * (*self.height)
    }
}

#[generate_trait]
impl RectangleCmpImpl of RectangleCmp {
    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool {
        *self.width &gt; *other.width &amp;&amp; *self.height &gt; *other.height
    }
}
</code></pre>
<p>这里没有强烈的理由将这些方法分成多个 <code>trait</code> 和 <code>impl</code> 块，但这是有效的语法。</p>
<p>{{#quiz ../quizzes/ch05-03-method-syntax.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="枚举和模式匹配"><a class="header" href="#枚举和模式匹配">枚举和模式匹配</a></h1>
<p>在本章中，我们将研究 <em>枚举 (enumerations)</em>，也简称为 <em>enums</em>。枚举允许你通过列举其可能的 <em>变体 (variants)</em> 来定义一种类型。首先，我们将定义并使用一个枚举，以展示枚举如何将含义与数据一起编码。接下来，我们将探索一个特别有用的枚举，称为 <code>Option</code>，它表示一个值可以是某物或是无。最后，我们将看看 <code>match</code> 表达式中的模式匹配如何使针对枚举的不同值运行不同代码变得容易。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="枚举"><a class="header" href="#枚举">枚举</a></h1>
<p>枚举 (Enums)，是 “enumerations” 的缩写，是一种通过定义一组固定的命名值（称为 <em>变体 (variants)</em>）来定义自定义数据类型的方法。枚举对于表示一组相关的值非常有用，其中每个值都是独特的并且具有特定的意义。</p>
<h2 id="枚举变体和值"><a class="header" href="#枚举变体和值">枚举变体和值</a></h2>
<p>这是一个简单的枚举示例：</p>
<pre><code class="language-cairo noplayground">#[derive(Drop)]
enum Direction {
    North,
    East,
    South,
    West,
}
</code></pre>
<p>在这个例子中，我们定义了一个名为 <code>Direction</code> 的枚举，有四个变体：<code>North</code>、<code>East</code>、<code>South</code> 和 <code>West</code>。命名约定是对枚举变体使用 PascalCase。每个变体代表 <code>Direction</code> 类型的一个独特值。在这个特定例子中，变体没有任何关联值。可以使用这种语法实例化一个变体：</p>
<pre><code class="language-cairo noplayground">    let direction = Direction::North;
</code></pre>
<p>现在让我们想象我们的變体有关联值，存储方向的确切度数。我们可以定义一个新的 <code>Direction</code> 枚举：</p>
<pre><code class="language-cairo noplayground">#[derive(Drop)]
enum Direction {
    North: u128,
    East: u128,
    South: u128,
    West: u128,
}
</code></pre>
<p>并如下实例化它：</p>
<pre><code class="language-cairo noplayground">    let direction = Direction::North(10);
</code></pre>
<p>在这段代码中，每个变体都关联了一个 <code>u128</code> 值，表示以度为单位的方向。在下一个例子中，我们将看到也可以将不同的数据类型与每个变体关联。</p>
<p>编写根据枚举实例的变体不同而采取不同行动的代码很容易，在这个例子中是根据方向运行特定代码。你可以在 <a href="#match-控制流结构">Match 控制流结构</a> 部分了解更多相关信息。</p>
<h2 id="结合自定义类型的枚举"><a class="header" href="#结合自定义类型的枚举">结合自定义类型的枚举</a></h2>
<p>枚举也可以用来存储与每个变体关联的更有趣的自定义数据。例如：</p>
<pre><code class="language-cairo noplayground">#[derive(Drop)]
enum Message {
    Quit,
    Echo: felt252,
    Move: (u128, u128),
}
</code></pre>
<p>在这个例子中，<code>Message</code> 枚举有三个变体：<code>Quit</code>、<code>Echo</code> 和 <code>Move</code>，都有不同的类型：</p>
<ul>
<li><code>Quit</code> 没有任何关联值。</li>
<li><code>Echo</code> 是单个 <code>felt252</code>。</li>
<li><code>Move</code> 是两个 <code>u128</code> 值的元组。</li>
</ul>
<p>你甚至可以在你的枚举变体中使用结构体或你定义的另一个枚举。</p>
<h2 id="枚举的-trait-实现"><a class="header" href="#枚举的-trait-实现">枚举的 Trait 实现</a></h2>
<p>在 Cairo 中，你可以定义 trait 并为你的自定义枚举实现它们。这允许你定义与枚举关联的方法和行为。这是一个为前面的 <code>Message</code> 枚举定义 trait 并实现它的例子：</p>
<pre><code class="language-cairo noplayground">trait Processing {
    fn process(self: Message);
}

impl ProcessingImpl of Processing {
    fn process(self: Message) {
        match self {
            Message::Quit =&gt; { println!("quitting") },
            Message::Echo(value) =&gt; { println!("echoing {}", value) },
            Message::Move((x, y)) =&gt; { println!("moving from {} to {}", x, y) },
        }
    }
}
</code></pre>
<p>在这个例子中，我们为 <code>Message</code> 实现了 <code>Processing</code> trait。这是如何使用它来处理 <code>Quit</code> 消息的：</p>
<pre><code class="language-cairo">    let msg: Message = Message::Quit;
    msg.process(); // prints "quitting"
</code></pre>
<h2 id="option-枚举及其优势"><a class="header" href="#option-枚举及其优势"><code>Option</code> 枚举及其优势</a></h2>
<p><code>Option</code> 枚举是一个标准的 Cairo 枚举，表示可选值的概念。它有两个变体：<code>Some: T</code> 和 <code>None</code>。<code>Some: T</code> 表示有一个类型为 <code>T</code> 的值，而 <code>None</code> 表示没有值。</p>
<pre><code class="language-cairo noplayground">enum Option&lt;T&gt; {
    Some: T,
    None,
}
</code></pre>
<p><code>Option</code> 枚举很有用，因为它允许你显式表示值不存在的可能性，使你的代码更具表现力且更易于推理。使用 <code>Option</code> 还可以帮助防止由使用未初始化或意外的 <code>null</code> 值引起的错误。</p>
<p>举个例子，这是一个返回数组中具有给定值的第一个元素的索引的函数，如果元素不存在则返回 <code>None</code>。</p>
<p>我们演示上述函数的两种方法：</p>
<ul>
<li>使用 <code>find_value_recursive</code> 的递归方法。</li>
<li>使用 <code>find_value_iterative</code> 的迭代方法。</li>
</ul>
<pre><code class="language-cairo noplayground">fn find_value_recursive(mut arr: Span&lt;felt252&gt;, value: felt252, index: usize) -&gt; Option&lt;usize&gt; {
    match arr.pop_front() {
        Some(index_value) =&gt; { if (*index_value == value) {
            return Some(index);
        } },
        None =&gt; { return None; },
    }

    find_value_recursive(arr, value, index + 1)
}

fn find_value_iterative(mut arr: Span&lt;felt252&gt;, value: felt252) -&gt; Option&lt;usize&gt; {
    for (idx, array_value) in arr.into_iter().enumerate() {
        if (*array_value == value) {
            return Some(idx);
        }
    }
    None
}
</code></pre>
<p>枚举在许多情况下都很有用，尤其是在使用我们刚刚使用的 <code>match</code> 流结构时。我们将在下一节描述它。</p>
<p>其他枚举非常常用，例如 <code>Result</code> 枚举，允许优雅地处理错误。我们将在 <a href="#the-result-enum">“错误处理”</a> 章节详细解释 <code>Result</code> 枚举。</p>
<p>{{#quiz ../quizzes/ch06-01-enums.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="match-控制流结构"><a class="header" href="#match-控制流结构">Match 控制流结构</a></h1>
<p>Cairo 有一个极其强大的控制流结构叫 <code>match</code>，它允许你将一个值与一系列模式进行比较，然后根据匹配的模式执行代码。模式可以由字面值、变量名、通配符和许多其他东西组成。<code>match</code> 的力量来自于模式的表现力以及编译器确认所有可能的情况都得到了处理。</p>
<p>把 <code>match</code> 表达式想象成一台硬币分类机：硬币沿着一条有不同大小孔的轨道滑下，每枚硬币都会掉进它遇到的第一个适合它的孔里。同样地，值通过 match 中的每一个模式，在第一个“适合”的模式处，值就会进入关联的代码块在执行期间被使用。</p>
<p>说到硬币，让我们用它们作为使用 <code>match</code> 的例子！我们可以写一个函数，它接受一个未知的美国硬币，并以类似于计数机的方式，确定它是哪种硬币并以美分返回其值，如清单 {{#ref match-enum}} 所示。</p>
<pre><code class="language-cairo noplayground">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

// ANCHOR: function
fn value_in_cents(coin: Coin) -&gt; felt252 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
// ANCHOR_END: function
</code></pre>
<p>{{#label match-enum}} <span class="caption">清单 {{#ref match-enum}}: 一个枚举和一个以枚举变体作为其模式的 <code>match</code> 表达式</span></p>
<p>让我们分解 <code>value_in_cents</code> 函数中的 <code>match</code> 表达式。首先，我们列出 <code>match</code> 关键字后跟一个表达式，在这种情况下是值 <code>coin</code>。这看起来与用于 <code>if</code> 语句的条件表达式非常相似，但有一个很大的不同：对于 <code>if</code>，条件需要评估为布尔值，但这里它可以是任何类型。在这个例子中，<code>coin</code> 的类型是我们在第一行定义的 <code>Coin</code> 枚举。</p>
<p>接下来是 <code>match</code> 分支 (arms)。一个分支有两个部分：一个模式和一些代码。这里的第一个分支有一个模式，即值 <code>Coin::Penny</code>，然后是 <code>=&gt;</code> 运算符，将模式和要运行的代码分开。这种情况下的代码只是值 <code>1</code>。每个分支与下一个分支用逗号分隔。</p>
<p>当 <code>match</code> 表达式执行时，它将结果值与每个分支的模式按给定的顺序进行比较。如果模式与值匹配，则执行与该模式关联的代码。如果该模式不匹配值，则执行继续到下一个分支，就像硬币分类机一样。我们可以有任意数量的分支：在上面的例子中，我们的 <code>match</code> 有四个分支。</p>
<p>与每个分支关联的代码是一个表达式，匹配分支中表达式的结果值是整个 match 表达式返回的值。</p>
<p>如果 <code>match</code> 分支代码很短，我们通常不使用花括号，就像在我们的例子中，每个分支只是返回一个值。如果你想在 <code>match</code> 分支中运行多行代码，你必须使用花括号，并在分支后跟一个逗号。例如，以下代码每次用 <code>Coin::Penny</code> 调用该方法时都会打印“Lucky penny!”，但仍返回块的最后一个值 <code>1</code>：</p>
<pre><code class="language-cairo noplayground">fn value_in_cents(coin: Coin) -&gt; felt252 {
    match coin {
        Coin::Penny =&gt; {
            println!("Lucky penny!");
            1
        },
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
</code></pre>
<h2 id="绑定到值的模式"><a class="header" href="#绑定到值的模式">绑定到值的模式</a></h2>
<p><code>match</code> 分支的另一个有用特性是它们可以绑定到匹配模式的值的部分。这就是我们如何从枚举变体中提取值。</p>
<p>举个例子，让我们改变我们的一个枚举变体以在其中保存数据。从 1999 年到 2008 年，美国铸造了 25 美分硬币，一面是 50 个州中每个州的不同设计。没有其他硬币有州设计，所以只有 25 美分硬币有这个额外的值。我们可以通过更改 <code>Quarter</code> 变体以包含存储在其中的 <code>UsState</code> 值来将此信息添加到我们的 <code>enum</code> 中，我们在清单 {{#ref match-pattern-bind}} 中已经这样做了。</p>
<pre><code class="language-cairo noplayground">
#[derive(Drop, Debug)] // Debug so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
}

#[derive(Drop)]
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter: UsState,
}
</code></pre>
<p>{{#label match-pattern-bind}} <span class="caption">清单
{{#ref match-pattern-bind}}: 一个 <code>Coin</code> 枚举，其中 <code>Quarter</code> 变体也保存一个 <code>UsState</code> 值</span></p>
<p>让我们想象一个朋友正在试图收集所有 50 个州的 25 美分硬币。当我们按硬币类型分类我们的零钱时，我们也会喊出每个 25 美分硬币关联的州名，这样如果它是我们朋友没有的，他们就可以把它加到他们的收藏中。</p>
<p>在这段代码的 <code>match</code> 表达式中，我们向匹配 <code>Coin::Quarter</code> 变体值的模式添加了一个名为 <code>state</code> 的变量。当 <code>Coin::Quarter</code> 匹配时，<code>state</code> 变量将绑定到那个 25 美分硬币的州的值。然后我们可以在该分支的代码中使用 <code>state</code>，像这样：</p>
<pre><code class="language-cairo noplayground">fn value_in_cents(coin: Coin) -&gt; felt252 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!("State quarter from {:?}!", state);
            25
        },
    }
}
</code></pre>
<p>因为 <code>state</code> 是一个实现了 <code>Debug</code> trait 的 <code>UsState</code> 枚举，我们可以用 <code>println!</code> 宏打印 <code>state</code> 值。</p>
<blockquote>
<p>注意：<code>{:?}</code> 是一种特殊的格式化语法，允许打印传递给 <code>println!</code> 宏的参数的调试形式。你可以在 <a href="#debug-for-printing-and-debugging">附录 C</a> 中找到关于它的更多信息。</p>
</blockquote>
<p>如果我们调用 <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>，<code>coin</code> 将是 <code>Coin::Quarter(UsState::Alaska)</code>。当我们把那个值与每个匹配分支比较时，直到我们到达 <code>Coin::Quarter(state)</code> 都没有匹配的。在那一点，<code>state</code> 的绑定将是值 <code>UsState::Alaska</code>。然后我们可以在 <code>println!</code> 宏中使用该绑定，从而从 <code>Quarter</code> 的 <code>Coin</code> 枚举变体中获取内部状态值。</p>
<h2 id="匹配-optiont"><a class="header" href="#匹配-optiont">匹配 <code>Option&lt;T&gt;</code></a></h2>
<p>在上一节中，我们想在使用 <code>Option&lt;T&gt;</code> 时从 <code>Some</code> 情况中获取内部 <code>T</code> 值；我们也可以使用 <code>match</code> 处理 <code>Option&lt;T&gt;</code>，就像我们处理 <code>Coin</code> 枚举一样！我们将比较 <code>Option&lt;T&gt;</code> 的变体，而不是比较硬币，但 <code>match</code> 表达式的工作方式保持不变。</p>
<p>假设我们要写一个函数，它接受一个 <code>Option&lt;u8&gt;</code>，如果里面有值，就给那个值加 <code>1</code>。如果里面没有值，函数应该返回 <code>None</code> 值，不尝试执行任何操作。</p>
<p>这个函数很容易编写，这就多亏了 <code>match</code>，看起来像清单 {{#ref match-option}}。</p>
<pre><code class="language-cairo">fn plus_one(x: Option&lt;u8&gt;) -&gt; Option&lt;u8&gt; {
    match x {
        //ANCHOR: option_some
        Some(val) =&gt; Some(val + 1),
        //ANCHOR_END: option_some
        // ANCHOR: option_none
        None =&gt; None,
        //ANCHOR_END: option_none
    }
}

#[executable]
fn main() {
    let five: Option&lt;u8&gt; = Some(5);
    let six: Option&lt;u8&gt; = plus_one(five);
    let none = plus_one(None);
}
</code></pre>
<p>{{#label match-option}} <span class="caption">清单 {{#ref match-option}}: 一个在 <code>Option&lt;u8&gt;</code> 上使用 <code>match</code> 表达式的函数</span></p>
<p>让我们更详细地检查 <code>plus_one</code> 的第一次执行。当我们调用 <code>plus_one(five)</code> 时，<code>plus_one</code> 主体中的变量 <code>x</code> 将具有值 <code>Some(5)</code>。然后我们将其与每个 <code>match</code> 分支进行比较：</p>
<pre><code class="language-cairo noplayground">        Some(val) =&gt; Some(val + 1),
</code></pre>
<p><code>Some(5)</code> 值匹配模式 <code>Some(val)</code> 吗？是的！我们要么有相同的变体。<code>val</code> 绑定到包含在 <code>Some</code> 中的值，所以 <code>val</code> 取值 <code>5</code>。然后执行 <code>match</code> 分支中的代码，所以我们将 <code>val</code> 的值加 <code>1</code> 并创建一个包含我们总数 <code>6</code> 的新 <code>Some</code> 值。因为第一个分支匹配了，所以不再比较其他分支。</p>
<p>现在让我们考虑我们的 main 函数中 <code>plus_one</code> 的第二次调用，其中 <code>x</code> 是 <code>None</code>。我们进入 <code>match</code> 并与第一个分支比较：</p>
<pre><code class="language-cairo noplayground">        Some(val) =&gt; Some(val + 1),
</code></pre>
<p><code>Some(val)</code> 值不匹配模式 <code>None</code>，所以我们继续到下一个分支：</p>
<pre><code class="language-cairo">        None =&gt; None,
</code></pre>
<p>匹配了！没有值可以加，所以匹配结构结束并在 <code>=&gt;</code> 右侧返回 <code>None</code> 值。</p>
<p>结合 <code>match</code> 和枚举在各种情况下都很有用。你会在 Cairo 代码中经常看到这种模式：针对枚举进行 <code>match</code>，将变量绑定到内部数据，然后基于此执行代码。起初这有点棘手，但一旦你习惯了它，你会希望所有语言都有它。它始终是用户的最爱。</p>
<h2 id="匹配是穷尽的-exhaustive"><a class="header" href="#匹配是穷尽的-exhaustive">匹配是穷尽的 (Exhaustive)</a></h2>
<p>我们需要讨论 <code>match</code> 的另一个方面：分支的模式必须覆盖所有可能性。考虑这个版本的 <code>plus_one</code> 函数，它有一个错误并且无法编译：</p>
<pre><code class="language-cairo noplayground">fn plus_one(x: Option&lt;u8&gt;) -&gt; Option&lt;u8&gt; {
    match x {
        Some(val) =&gt; Some(val + 1),
    }
}
</code></pre>
<p>我们没有处理 <code>None</code> 的情况，所以这段代码会导致错误。幸运的是，这是一个 Cairo 知道如何捕获的错误。如果我们尝试编译这段代码，我们会得到这个错误：</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_08_missing_match_arm v0.1.0 (listings/ch06-enums-and-pattern-matching/no_listing_09_missing_match_arm/Scarb.toml)
error: Missing match arm: `None` not covered.
 --&gt; listings/ch06-enums-and-pattern-matching/no_listing_09_missing_match_arm/src/lib.cairo:5:5-7:5
      match x {
 _____^
|         Some(val) =&gt; Some(val + 1),
|     }
|_____^

error: could not compile `no_listing_08_missing_match_arm` due to previous error
error: `scarb` command exited with error

</code></pre>
<p>Cairo 知道我们没有覆盖所有可能的情况，甚至知道我们忘记了哪个模式！Cairo 中的匹配是穷尽的：为了使代码有效，我们必须穷尽每一种可能性。特别是在 <code>Option&lt;T&gt;</code> 的情况下，当 Cairo 阻止我们忘记显式处理 <code>None</code> 情况时，它保护我们免受假设我们在可能有 null 时有一个值的影响，从而使之前讨论的 <a href="https://en.wikipedia.org/wiki/Null_pointer#History">十亿美元错误</a> 成为不可能。</p>
<h2 id="使用-_-通配符的-catch-all"><a class="header" href="#使用-_-通配符的-catch-all">使用 <code>_</code> 通配符的 Catch-all</a></h2>
<p>使用枚举，我们还可以对一些特定值采取特殊操作，但对所有其他值采取一个默认操作。<code>_</code> 是一个特殊模式，它可以匹配任何值并且不绑定到该值。你可以通过简单地添加一个新分支，并将 <code>_</code> 作为 <code>match</code> 表达式最后一个分支的模式来使用它。</p>
<p>想象我们有一台只接受 10 美分硬币 (Dime) 的自动售货机。我们想要一个处理投入硬币的函数，只有当硬币被接受时才返回 <code>true</code>。</p>
<p>这是一个实现此逻辑的 <code>vending_machine_accept</code> 函数：</p>
<pre><code class="language-cairo noplayground">fn vending_machine_accept(coin: Coin) -&gt; bool {
    match coin {
        Coin::Dime =&gt; true,
        _ =&gt; false,
    }
}
</code></pre>
<p>这个例子也满足穷尽性要求，因为我们在最后一个分支中显式忽略了所有其他值；我们没有忘记任何东西。</p>
<blockquote>
<p>Cairo 中没有允许你使用模式值的 catch-all 模式。</p>
</blockquote>
<!--
  TODO move the following in a separate chapter when there's more pattern matching features in upcoming Cairo versions. cf rust book chapter 18
-->
<h2 id="使用--运算符的多个模式"><a class="header" href="#使用--运算符的多个模式">使用 <code>|</code> 运算符的多个模式</a></h2>
<p>在 <code>match</code> 表达式中，你可以使用 <code>|</code> 语法匹配多个模式，这是模式 <em>或</em> 运算符。</p>
<p>例如，在下面的代码中，我们修改了 <code>vending_machine_accept</code> 函数，在一个分支中同时接受 <code>Dime</code> 和 <code>Quarter</code> 硬币：</p>
<pre><code class="language-cairo noplayground">fn vending_machine_accept(coin: Coin) -&gt; bool {
    match coin {
        Coin::Dime | Coin::Quarter =&gt; true,
        _ =&gt; false,
    }
}
</code></pre>
<h2 id="匹配元组"><a class="header" href="#匹配元组">匹配元组</a></h2>
<p>可以匹配元组。让我们引入一个新的 <code>DayType</code> 枚举：</p>
<pre><code class="language-cairo noplayground">#[derive(Drop)]
enum DayType {
    Week,
    Weekend,
    Holiday,
}
</code></pre>
<p>现在，假设我们的自动售货机在工作日接受任何硬币，但在周末和节假日只接受 25 美分和 10 美分硬币。我们可以修改 <code>vending_machine_accept</code> 函数以接受 <code>Coin</code> 和 <code>Weekday</code> 的元组，并且仅当给定的硬币在指定的日子被接受时才返回 <code>true</code>：</p>
<pre><code class="language-cairo noplayground">fn vending_machine_accept(c: (DayType, Coin)) -&gt; bool {
    match c {
        (DayType::Week, _) =&gt; true,
        (_, Coin::Dime) | (_, Coin::Quarter) =&gt; true,
        (_, _) =&gt; false,
    }
}
</code></pre>
<p>为元组匹配模式的最后一个分支写 <code>(_, _)</code> 可能感觉多余。因此，如果我们想要，例如，我们的自动售货机只在工作日接受 25 美分硬币，我们可以使用 <code>_ =&gt;</code> 语法：</p>
<pre><code class="language-cairo noplayground">fn vending_week_machine(c: (DayType, Coin)) -&gt; bool {
    match c {
        (DayType::Week, Coin::Quarter) =&gt; true,
        _ =&gt; false,
    }
}
</code></pre>
<h2 id="匹配-felt252-和整数变量"><a class="header" href="#匹配-felt252-和整数变量">匹配 <code>felt252</code> 和整数变量</a></h2>
<p>你也可以匹配 <code>felt252</code> 和整数变量。当你想要针对一系列值进行匹配时，这很有用。但是，有一些限制：</p>
<ul>
<li>仅支持适合单个 <code>felt252</code> 的整数（即不支持 <code>u256</code>）。</li>
<li>第一个分支必须是 0。</li>
<li>每个分支必须覆盖一个连续的段，与其他分支连续。</li>
</ul>
<p>想象我们正在实现一个游戏，你掷一个六面的骰子得到一个 0 到 5 之间的数字。如果你有 0、1 或 2，你赢了。如果你有 3，你可以再掷一次。对于所有其他值，你输了。</p>
<p>这是一个实现该逻辑的 match：</p>
<pre><code class="language-cairo noplayground">fn roll(value: u8) {
    match value {
        0 | 1 | 2 =&gt; println!("you won!"),
        3 =&gt; println!("you can roll again!"),
        _ =&gt; println!("you lost..."),
    }
}
</code></pre>
<p>{{#quiz ../quizzes/ch06-02-match.toml}}</p>
<blockquote>
<p>这些限制计划在 Cairo 的未来版本中放宽。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="使用-if-let-和-while-let-的简洁控制流"><a class="header" href="#使用-if-let-和-while-let-的简洁控制流">使用 <code>if let</code> 和 <code>while let</code> 的简洁控制流</a></h1>
<h2 id="if-let"><a class="header" href="#if-let"><code>if let</code></a></h2>
<p><code>if let</code> 语法允许你将 <code>if</code> 和 <code>let</code> 组合成一种不太冗长的方式来处理匹配一个模式的值，同时忽略其余模式。考虑清单 {{#ref config_max}} 中的程序，它匹配 <code>config_max</code> 变量中的 <code>Some&lt;u8&gt;</code> 值，但只有当值是 <code>Some</code> 变体时才想执行代码。</p>
<pre><code class="language-cairo">    let config_max = Some(5);
    match config_max {
        Some(max) =&gt; println!("The maximum is configured to be {}", max),
        _ =&gt; (),
    }
</code></pre>
<p>{{#label config_max}} <span class="caption">清单 {{#ref config_max}}: 一个只关心当值是 <code>Some</code> 时执行代码的 <code>match</code></span></p>
<p>如果值是 <code>Some</code>，我们通过在模式中将值绑定到变量 <code>max</code> 来打印 <code>Some</code> 变体中的值。我们不想对 <code>None</code> 值做任何事情。为了满足 <code>match</code> 表达式，我们在处理完一个变体后必须添加 <code>_ =&gt; ()</code>，这是必须添加的令人讨厌的样板代码。</p>
<p>相反，我们可以使用 <code>if let</code> 以更简短的方式编写此代码。下面的代码与清单 {{#ref config_max}} 中的 <code>match</code> 行为相同：</p>
<pre><code class="language-cairo">    let number = Some(5);
    if let Some(max) = number {
        println!("The maximum is configured to be {}", max);
    }
</code></pre>
<p>语法 <code>if let</code> 接受一个模式和一个由等号分隔的表达式。它的工作方式与 <code>match</code> 相同，其中表达式提供给 <code>match</code>，模式是其第一个分支。在这种情况下，模式是 <code>Some(max)</code>，<code>max</code> 绑定到 <code>Some</code> 内部的值。然后我们可以在 <code>if let</code> 块的主体中使用 <code>max</code>，就像我们在相应的 <code>match</code> 分支中使用 <code>max</code> 一样。如果值不匹配模式，则不运行 <code>if let</code> 块中的代码。</p>
<p>使用 <code>if let</code> 意味着更少的输入、更少的缩进和更少的样板代码。然而，你失去了 <code>match</code> 强制执行的穷尽性检查。在 <code>match</code> 和 <code>if let</code> 之间进行选择取决于你在特定情况下的做法，以及获得简洁性是否是失去穷尽性检查的适当权衡。</p>
<p>换句话说，你可以把 <code>if let</code> 看作是 <code>match</code> 的语法糖，当值匹配某个模式时运行代码，然后忽略所有其他值。</p>
<p>我们可以在 <code>if let</code> 中包含一个 <code>else</code>。与 <code>else</code> 一起的代码块与 <code>match</code> 表达式中的 <code>_</code> 情况一起的代码块相同。回想一下清单 {{#ref match-pattern-bind}} 中的 <code>Coin</code> 枚举定义，其中 <code>Quarter</code> 变体也保存一个 <code>UsState</code> 值。如果我们想计数我们看到的所有非 25 美分硬币，同时还要宣布 25 美分硬币的州，我们可以用 <code>match</code> 表达式这样做，像这样：</p>
<pre><code class="language-cairo">    let coin = Coin::Quarter;
    let mut count = 0;
    match coin {
        Coin::Quarter =&gt; println!("You got a quarter!"),
        _ =&gt; count += 1,
    }
</code></pre>
<p>或者我们可以使用 <code>if let</code> 和 <code>else</code> 表达式，像这样：</p>
<pre><code class="language-cairo">    let coin = Coin::Quarter;
    let mut count = 0;
    if let Coin::Quarter = coin {
        println!("You got a quarter!");
    } else {
        count += 1;
    }
</code></pre>
<p>如果你遇到程序中的逻辑过于冗长而无法使用 <code>match</code> 表达的情况，请记住 <code>if let</code> 也在你的 Cairo 工具箱中。</p>
<h2 id="while-let"><a class="header" href="#while-let"><code>while let</code></a></h2>
<p><code>while let</code> 语法与 <code>if let</code> 语法类似，但它允许你遍历值的集合，并为每个匹配指定模式的值执行代码块。在下面的情况下，模式是 <code>Some(x)</code>，它匹配 <code>Option</code> 枚举的任何 <code>Some</code> 变体。</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut arr = array![1, 2, 3, 4, 5, 6, 7, 8, 9];
    let mut sum = 0;
    while let Some(value) = arr.pop_front() {
        sum += value;
    }
    println!("{}", sum);
}
</code></pre>
<p>使用 <code>while let</code> 提供了编写此循环的一种更简洁和惯用的方式，与具有显式模式匹配或处理 <code>Option</code> 类型的传统 <code>while</code> 循环相比。然而，与 <code>if let</code> 一样，你失去了 <code>match</code> 表达式提供的穷尽性检查，因此在必要时你需要小心处理 <code>while let</code> 循环之外的任何剩余情况。</p>
<h2 id="let-链-let-chains"><a class="header" href="#let-链-let-chains">Let 链 (Let Chains)</a></h2>
<p>Cairo 支持 let 链，以结合涉及 <code>if let</code> 或 <code>while let</code> 的多个条件而无需嵌套。这让你可以在单个表达式中进行模式匹配并应用额外的布尔条件：</p>
<pre><code class="language-cairo">fn get_x() -&gt; Option&lt;u32&gt; {
    Some(5)
}

fn get_y() -&gt; Option&lt;u32&gt; {
    Some(8)
}

#[executable]
fn main() {
    // Using a let chain to combine pattern matching and additional conditions
    if let Some(x) = get_x() &amp;&amp; x &gt; 0 &amp;&amp; let Some(y) = get_y() &amp;&amp; y &gt; 0 {
        let sum: u32 = x + y;
        println!("sum: {}", sum);
        return;
    }
    println!("x or y is not positive");
    // else is not supported yet;
}
</code></pre>
<blockquote>
<p>注意：let 链表达式尚不支持 <code>else</code>；这将在以后的版本中添加。</p>
</blockquote>
<h2 id="let-else"><a class="header" href="#let-else"><code>let else</code></a></h2>
<p><code>let else</code> 启用 <code>let</code> 绑定中的可反驳模式匹配，并在模式不匹配时允许 <code>else</code> 块发散（例如使用 <code>return</code>、<code>break</code>、<code>continue</code> 或 <code>panic!</code>）：</p>
<pre><code class="language-cairo">#[derive(Drop)]
enum MyEnum {
    A: u32,
    B: u32,
}

fn foo(a: MyEnum) {
    let MyEnum::A(x) = a else {
        println!("Called with B");
        return;
    };
    println!("Called with A({x})");
}

#[executable]
fn main() {
    foo(MyEnum::A(42));
    foo(MyEnum::B(7));
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="使用包crate-和模块管理-cairo-项目"><a class="header" href="#使用包crate-和模块管理-cairo-项目">使用包、Crate 和模块管理 Cairo 项目</a></h1>
<p>当你编写大型程序时，组织代码将变得越来越重要。通过将相关功能分组并将具有不同特征的代码分开，你可以明确在哪里可以找到实现特定功能的代码，以及在哪里更改功能的工作方式。</p>
<p>我们写的程序到目前为止都在一个文件中的一个模块里。随着项目的增长，你应该通过将代码拆分成多个模块，然后是多个文件来组织代码。随着包的增长，你可以将部分内容提取到成为外部依赖项的单独 Crate 中。本章涵盖了所有这些技术。</p>
<p>我们还将讨论封装实现细节，这允许你在更高级别重用代码：一旦你是实现了一个操作，其他代码就可以调用你的代码，而无需知道实现是如何工作的。</p>
<p>一个相关的概念是作用域 (scope)：编写代码的嵌套上下文有一组定义为“在作用域内”的名称。在读取、编写和编译代码时，程序员和编译器需要知道特定位置的特定名称是指变量、函数、结构体、枚举、模块、常量还是其他项，以及该项的含义。你可以创建作用域并更改哪些名称在作用域内或外。同一个作用域内不能有两个同名的项。</p>
<p>Cairo 拥有许多允许你管理代码组织的功能。这些功能有时统称为 <em>模块系统 (module system)</em>，包括：</p>
<ul>
<li><strong>包 (Packages):</strong> 一个 Scarb 功能，允许你构建、测试和共享 crate。</li>
<li><strong>Crates:</strong> 对应于单个编译单元的模块树。它有一个根目录，以及在该目录下 <em>lib.cairo</em> 文件中定义的根模块。</li>
<li><strong>模块 (Modules)</strong> 和 <strong>use:</strong> 让你控制项的组织和作用域。</li>
<li><strong>路径 (Paths):</strong> 命名项（如结构体、函数或模块）的方法。</li>
</ul>
<p>在本章中，我们将涵盖所有这些功能，讨论它们如何交互，并解释如何使用它们来管理作用域。到最后，你应该对模块系统有扎实的理解，并能像专业人士一样使用作用域！</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="包-packages-和-crates"><a class="header" href="#包-packages-和-crates">包 (Packages) 和 Crates</a></h1>
<h2 id="什么是-crate"><a class="header" href="#什么是-crate">什么是 Crate？</a></h2>
<p>Crate 是在实际 Cairo 编译中使用的包的一个子集。这包括：</p>
<ul>
<li>包源代码，由包名称和 crate 根标识，crate 根是包的主要入口点。</li>
<li>包元数据的子集，用于标识 Cairo 编译器的 crate 级设置，例如 <em>Scarb.toml</em> 文件中的 <code>edition</code> 字段。</li>
</ul>
<p>Crates 可以包含模块，并且模块可以定义在与 crate 一起编译的其他文件中，这将在后续章节中讨论。</p>
<h2 id="什么是-crate-根"><a class="header" href="#什么是-crate-根">什么是 Crate 根？</a></h2>
<p>Crate 根是 Cairo 编译器开始的 <em>lib.cairo</em> 源文件，构成你的 crate 的根模块。我们将在 <a href="#定义模块以控制作用域">“定义模块以控制作用域”</a> 一章中深入解释模块。</p>
<h2 id="什么是包"><a class="header" href="#什么是包">什么是包？</a></h2>
<p>一个 Cairo 包是一个包含以下内容的目录（或等效物）：</p>
<ul>
<li>带有 <code>[package]</code> 部分的 <em>Scarb.toml</em> 清单文件。</li>
<li>关联的源代码。</li>
</ul>
<p>这个定义意味着一个包可能包含其他包，每个包都有一个对应的 <em>Scarb.toml</em> 文件。</p>
<h2 id="使用-scarb-创建包"><a class="header" href="#使用-scarb-创建包">使用 Scarb 创建包</a></h2>
<p>你可以使用 Scarb 命令行工具创建一个新的 Cairo 包。要创建一个新包，请运行以下命令：</p>
<pre><code class="language-bash">scarb new my_package
</code></pre>
<p>此命令将生成一个名为 <em>my_package</em> 的新包目录，结构如下：</p>
<pre><code>my_package/
├── Scarb.toml
└── src
    └── lib.cairo
</code></pre>
<ul>
<li><em>src/</em> 是将存储包的所有 Cairo 源文件的主目录。</li>
<li><em>lib.cairo</em> 是 crate 的默认根模块，也是包的主要入口点。</li>
<li><em>Scarb.toml</em> 是包清单文件，包含包的元数据和配置选项，例如依赖项、包名称、版本和作者。你可以在 <a href="https://docs.swmansion.com/scarb/docs/reference/manifest.html">Scarb 参考</a> 上找到关于它的文档。</li>
</ul>
<pre><code class="language-toml">[package]
name = "my_package"
version = "0.1.0"
edition = "2024_07"

[executable]

[cairo]
enable-gas = false

[dependencies]
cairo_execute = "2.13.1"
</code></pre>
<p>在你开发包时，你可能希望将代码组织成多个 Cairo 源文件。你可以通过在 <em>src</em> 目录或其子目录中创建额外的 <em>.cairo</em> 文件来做到这一点。</p>
<p>{{#quiz ../quizzes/ch07-01-packages-crates.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="定义模块以控制作用域"><a class="header" href="#定义模块以控制作用域">定义模块以控制作用域</a></h1>
<p>在本节中，我们将讨论模块和模块系统的其他部分，即允许你命名项的 <em>路径 (paths)</em> 和将路径引入作用域的 <code>use</code> 关键字。</p>
<p>首先，我们将从一系列规则开始，以便你在将来组织代码时可以轻松参考。然后我们将详细解释每条规则。</p>
<h2 id="模块备忘单"><a class="header" href="#模块备忘单">模块备忘单</a></h2>
<p>这里我们提供关于模块、路径和 <code>use</code> 关键字如何在编译器中工作，以及大多数开发人员如何组织他们的代码的快速参考。我们将在本章中通过示例来讲解这些规则中的每一条，但这是一个很好的参考位置，可以作为模块工作原理的提醒。你可以使用 <code>scarb new backyard</code> 创建一个新的 Scarb 项目来跟随操作。</p>
<ul>
<li>
<p><strong>从 crate 根开始</strong>: 编译 crate 时，编译器首先在 crate 根文件 (<em>src/lib.cairo</em>) 中查找要编译的代码。</p>
</li>
<li>
<p><strong>声明模块</strong>: 在 crate 根文件中，你可以声明新模块；比如，你声明一个 <code>garden</code> 模块 <code>mod garden;</code>。编译器会在这些地方查找模块的代码：</p>
<ul>
<li>
<p>内联，在替换 <code>mod garden</code> 后面的分号的花括号内。</p>
<pre><code class="language-cairo noplayground">  // crate 根文件 (src/lib.cairo)
  mod garden {
      // 定义 garden 模块的代码放在这里
  }
</code></pre>
</li>
<li>
<p>在文件 <em>src/garden.cairo</em> 中。</p>
</li>
</ul>
</li>
<li>
<p><strong>声明子模块</strong>: 在 crate 根以外的任何文件中，你可以声明子模块。例如，你可能在 <em>src/garden.cairo</em> 中声明 <code>mod vegetables;</code>。编译器会在以父模块命名的目录中的这些地方查找子模块的代码：</p>
<ul>
<li>
<p>内联，直接跟在 <code>mod vegetables</code> 后面，在花括号内而不是分号。</p>
<pre><code class="language-cairo noplayground">// src/garden.cairo 文件
mod vegetables {
    // 定义 vegetables 子模块的代码放在这里
}
</code></pre>
</li>
<li>
<p>在文件 <em>src/garden/vegetables.cairo</em> 中。</p>
</li>
</ul>
</li>
<li>
<p><strong>模块中代码的路径</strong>: 一旦模块成为你的 crate 的一部分，你就可以从同一个 crate 中的任何其他地方引用该模块中的代码，使用代码的路径。例如，<code>vegetables</code> 子模块中的 <code>Asparagus</code> 类型可以在 <code>crate::garden::vegetables::Asparagus</code> 找到。</p>
</li>
<li>
<p><strong>私有与公有</strong>: 默认情况下，模块内的代码对其父模块是私有的。这意味着它只能被当前模块及其后代访问。要使模块公有，请使用 <code>pub mod</code> 而不是 <code>mod</code> 声明它。要使公有模块内的项也公有，请在它们的声明前使用 <code>pub</code>。Cairo 还提供了 <code>pub(crate)</code> 关键字，允许项或模块仅在包含定义的 crate 内可见。</p>
</li>
<li>
<p><strong><code>use</code> 关键字</strong>: 在一个作用域内，<code>use</code> 关键字创建项的快捷方式，以减少长路径的重复。在任何可以引用 <code>crate::garden::vegetables::Asparagus</code> 的作用域中，你可以用 <code>use crate::garden::vegetables::Asparagus;</code> 创建一个快捷方式，从那时起你只需要写 <code>Asparagus</code> 就可以在作用域中使用该类型。</p>
</li>
</ul>
<p>这里我们创建一个名为 <code>backyard</code> 的 crate 来演示这些规则。crate 的目录，也名为 <code>backyard</code>，包含这些文件和目录：</p>
<pre><code class="language-text">backyard/
├── Scarb.toml
└── src
    ├── garden
    │   └── vegetables.cairo
    ├── garden.cairo
    └── lib.cairo
</code></pre>
<p>在这种情况下，crate 根文件是 <em>src/lib.cairo</em>，它包含：</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo">pub mod garden;
use crate::garden::vegetables::Asparagus;

#[executable]
fn main() {
    let plant = Asparagus {};
    println!("I'm growing {:?}!", plant);
}
</code></pre>
<p><code>pub mod garden;</code> 行导入 <code>garden</code> 模块。使用 <code>pub</code> 使 <code>garden</code> 公开访问，或者如果你真的想让 <code>garden</code> 仅对你的 crate 可用则使用 <code>pub(crate)</code>，在这里运行我们的程序是可选的，因为 <code>main</code> 函数驻留在与 <code>pub mod garden;</code> 声明相同的模块中。尽管如此，不声明 <code>garden</code> 为 <code>pub</code> 将使其无法从任何其他包访问。这行告诉编译器包含它在 <em>src/garden.cairo</em> 中找到的代码，即：</p>
<p><span class="filename">文件名: src/garden.cairo</span></p>
<pre><code class="language-cairo noplayground">pub mod vegetables;
</code></pre>
<p>在这里，<code>pub mod vegetables;</code> 意味着 <em>src/garden/vegetables.cairo</em> 中的代码也被包含在内。该代码是：</p>
<pre><code class="language-cairo noplayground">#[derive(Drop, Debug)]
pub struct Asparagus {}
</code></pre>
<p>行 <code>use crate::garden::vegetables::Asparagus;</code> 让我们将 <code>Asparagus</code> 类型引入作用域，以便我们可以在 <code>main</code> 函数中使用它。</p>
<p>现在让我们深入了解这些规则的细节并在实际操作中演示它们！</p>
<h2 id="在模块中分组相关代码"><a class="header" href="#在模块中分组相关代码">在模块中分组相关代码</a></h2>
<p><em>模块 (Modules)</em> 让我们在一个 crate 内组织代码，以提高可读性和易于重用。模块还允许我们控制项的隐私，因为默认情况下模块内的代码是私有的。私有项是不可供外部使用的内部实现细节。我们可以选择使模块及其内部的项公有，这将公开它们以允许外部代码使用和依赖它们。</p>
<p>作为一个例子，让我们编写一个提供餐厅功能的库 Crate。我们将定义函数的签名但将它们的主体留空，以专注于代码的组织，而不是餐厅的实现。</p>
<p>在餐饮业中，餐厅的某些部分被称为 <em>前厅 (front of house)</em>，其他部分被称为 <em>后厨 (back of house)</em>。前厅是顾客所在的地方；这包括迎宾员安排顾客入座、服务员点菜和付款、以及调酒师调制饮料的地方。后厨是厨师和帮厨在厨房工作、洗碗工清理、以及经理做行政工作的地方。</p>
<p>为了以这种方式构建我们的 crate，我们可以将其函数组织成嵌套模块。通过运行 <code>scarb new restaurant</code> 创建一个名为 <em>restaurant</em> 的新包；然后将清单 {{#ref front_of_house}} 中的代码输入 <em>src/lib.cairo</em> 以定义一些模块和函数签名。这是前厅部分：</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo noplayground">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
</code></pre>
<p>{{#label front_of_house}} <span class="caption">清单 {{#ref front_of_house}}:
一个包含其他模块的 <code>front_of_house</code> 模块，这些模块又包含函数</span></p>
<p>我们使用 <code>mod</code> 关键字后跟模块名称（在本例中为 <code>front_of_house</code>）来定义一个模块。模块的主体然后放在花括号内。在模块内，我们可以放置其他模块，就像本例中的 <code>hosting</code> 和 <code>serving</code> 模块一样。模块还可以保存其他项的定义，例如结构体、枚举、常量、trait 和函数。</p>
<p>通过使用模块，我们可以将相关定义分组在一起，并命名它们为什么相关。使用此代码的程序员可以根据组来浏览代码，而不必通读所有定义，从而更容易找到与他们相关的定义。向此代码添加新功能的程序员将知道在哪里放置代码以保持程序井井有条。</p>
<p>之前，我们提到 <em>src/lib.cairo</em> 被称为 crate 根。这个名字的原因是这个文件的内容形成了一个以 crate 名称命名的模块，位于 crate 模块结构的根部，称为 <em>模块树 (module tree)</em>。</p>
<p>清单 {{#ref module-tree}} 展示了清单 {{#ref front_of_house}} 中结构的模块树。</p>
<pre><code class="language-text">restaurant
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre>
<p>{{#label module-tree}} <span class="caption">清单 {{#ref module-tree}}: 清单 {{#ref front_of_house}} 中代码的模块树</span></p>
<p>这棵树展示了一些模块如何嵌套在另一个模块中；例如，<code>hosting</code> 嵌套在 <code>front_of_house</code> 中。该树还显示一些模块彼此是 <em>兄弟 (siblings)</em>，意味着它们定义在同一个模块中；<code>hosting</code> 和 <code>serving</code> 是定义在 <code>front_of_house</code> 内的兄弟。如果模块 A 包含在模块 B 内，我们说模块 A 是模块 B 的 <em>子 (child)</em>，模块 B 是模块 A 的 <em>父 (parent)</em>。注意整个模块树都位于名为 <em>restaurant</em> 的显式名称之下。</p>
<p>模块树可能会让你想起计算机上的文件系统目录树；这是一个非常恰当的类比！就像文件系统中的目录一样，你使用模块来组织你的代码。就像目录中的文件一样，我们需要一种方法来找到我们的模块。</p>
<p>{{#quiz ../quizzes/ch07-02-defining-modules-to-control-scope.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="引用模块树中项的路径"><a class="header" href="#引用模块树中项的路径">引用模块树中项的路径</a></h1>
<p>为了向 Cairo 展示在模块树中哪里可以找到一个项，我们使用路径，就像我们在浏览文件系统时使用路径一样。要调用一个函数，我们需要知道它的路径。</p>
<p>路径可以采取两种形式：</p>
<ul>
<li><em>绝对路径 (absolute path)</em> 是从 crate 根开始的完整路径。绝对路径以 crate 名称开头。</li>
<li><em>相对路径 (relative path)</em> 从当前模块开始。</li>
</ul>
<p>绝对路径和相对路径后都跟一个或多个由双冒号 (<code>::</code>) 分隔的标识符。</p>
<p>为了说明这个概念，让我们拿回我们在上一章使用的餐厅示例清单 {{#ref front_of_house}}。我们有一个名为 <em>restaurant</em> 的 crate，其中有一个名为 <code>front_of_house</code> 的模块，它包含一个名为 <code>hosting</code> 的模块。<code>hosting</code> 模块包含一个名为 <code>add_to_waitlist</code> 的函数。我们想从 <code>eat_at_restaurant</code> 函数调用 <code>add_to_waitlist</code> 函数。我们需要告诉 Cairo <code>add_to_waitlist</code> 函数的路径，以便它可以找到它。</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo noplayground">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}


pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
<p>{{#label path-types}} <span class="caption">清单 {{#ref path-types}}: 使用绝对路径和相对路径调用 <code>add_to_waitlist</code> 函数</span></p>
<p><code>eat_at_restaurant</code> 函数是我们库的公共 API 的一部分，所以我们用 <code>pub</code> 关键字标记它。我们将在 <a href="#exposing-paths-with-the-pub-keyword">“使用 <code>pub</code> 关键字暴露路径”</a> 一节中详细介绍 <code>pub</code>。</p>
<p>我们第一次在 <code>eat_at_restaurant</code> 中调用 <code>add_to_waitlist</code> 函数时，我们使用了绝对路径。<code>add_to_waitlist</code> 函数定义在与 <code>eat_at_restaurant</code> 相同的 crate 中。在 Cairo 中，绝对路径从 crate 根开始，你需要使用 crate 名称来引用它。你可以想象一个具有相同结构的文件系统：我们会指定路径 <em>/front_of_house/hosting/add_to_waitlist</em> 来运行 <em>add_to_waitlist</em> 程序；使用 crate 名称从 crate 根开始就像在 shell 中使用斜杠 (<code>/</code>) 从文件系统根目录开始一样。</p>
<p>我们要第二次调用 <code>add_to_waitlist</code> 时，我们使用了相对路径。路径以 <code>front_of_house</code> 开头，这是在与 <code>eat_at_restaurant</code> 相同的模块树级别定义的模块名称。在这里，等效的文件系统将使用路径 <em>./front_of_house/hosting/add_to_waitlist</em>。以模块名称开头意味着路径是相对于当前模块的。</p>
<p>让我们尝试编译清单 {{#ref path-types}} 并找出为什么它还不能编译！我们得到以下错误：</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling listing_07_02 v0.1.0 (listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_02_paths/Scarb.toml)
error: Item `listing_07_02::front_of_house::hosting` is not visible in this context.
 --&gt; listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_02_paths/src/lib.cairo:22:28
    crate::front_of_house::hosting::add_to_waitlist();
                           ^^^^^^^

error: Item `listing_07_02::front_of_house::hosting::add_to_waitlist` is not visible in this context.
 --&gt; listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_02_paths/src/lib.cairo:22:37
    crate::front_of_house::hosting::add_to_waitlist();
                                    ^^^^^^^^^^^^^^^

error: Item `listing_07_02::front_of_house::hosting` is not visible in this context.
 --&gt; listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_02_paths/src/lib.cairo:25:21
    front_of_house::hosting::add_to_waitlist();
                    ^^^^^^^

error: Item `listing_07_02::front_of_house::hosting::add_to_waitlist` is not visible in this context.
 --&gt; listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_02_paths/src/lib.cairo:25:30
    front_of_house::hosting::add_to_waitlist();
                             ^^^^^^^^^^^^^^^

error: could not compile `listing_07_02` due to previous error
error: `scarb` command exited with error

</code></pre>
<p>错误消息说模块 <code>hosting</code> 和 <code>add_to_waitlist</code> 函数不可见。换句话说，我们有 <code>hosting</code> 模块和 <code>add_to_waitlist</code> 函数的正确路径，但 Cairo 不让我们使用它们，因为它没有访问权限。在 Cairo 中，所有项（函数、方法、结构体、枚举、模块和常量）默认对其父模块是私有的。如果你想让一个像函数或结构体这样的项私有，你就把它放在一个模块里。</p>
<p>父模块中的项不能使用子模块内的私有项，但子模块中的项可以使用其祖先模块中的项。这是因为子模块包装并隐藏了它们的实现细节，但子模块可以看到它们被定义的上下文。继续我们的比喻，把隐私规则想象成餐厅的后勤办公室：那里发生的事情对餐厅顾客是私密的，但办公室经理可以看到并做他们经营的餐厅里的一切。</p>
<p>Cairo 选择让模块系统以这种方式运作，以便默认隐藏内部实现细节。这样，你就知道你可以更改内部代码的哪些部分而不会破坏外部代码。然而，Cairo 确实给了你选择，通过使用 <code>pub</code> 关键字将项公开，将子模块代码的内部部分暴露给外部祖先模块。</p>
<h2 id="使用-pub-关键字暴露路径"><a class="header" href="#使用-pub-关键字暴露路径">使用 <code>pub</code> 关键字暴露路径</a></h2>
<p>让我们回到之前的错误，它告诉我们 <code>hosting</code> 模块和 <code>add_to_waitlist</code> 函数不可见。我们希望父模块中的 <code>eat_at_restaurant</code> 函数能够访问子模块中的 <code>add_to_waitlist</code> 函数，所以我们用 <code>pub</code> 关键字标记 <code>hosting</code> 模块，如清单 {{#ref pub-keyword-not-compiling}} 所示。</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo noplayground">//TAG: does_not_compile
mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
<p>{{#label pub-keyword-not-compiling}} <span class="caption">清单
{{#ref pub-keyword-not-compiling}}: 将 <code>hosting</code> 模块声明为 <code>pub</code> 以便从 <code>eat_at_restaurant</code> 使用它</span></p>
<p>不幸的是，清单 {{#ref pub-keyword-not-compiling}} 中的代码仍然导致错误。</p>
<p>发生了什么？在 <code>mod hosting;</code> 前添加 <code>pub</code> 关键字使模块公有。有了这个变化，如果我们能访问 <code>front_of_house</code>，我们就能访问 <code>hosting</code>。但是 <code>hosting</code> 的内容仍然是私有的；使模块公有并不会使其内容公有。模块上的 <code>pub</code> 关键字只允许其祖先模块中的代码引用它，而不能访问其内部代码。因为模块是容器，仅仅使模块公有我们做不了太多事情；我们需要更进一步，选择将模块内的一个或多个项也公开。</p>
<p>让我们也通过在定义前添加 <code>pub</code> 关键字来使 <code>add_to_waitlist</code> 函数公有，如清单 {{#ref pub-keyword}} 所示。</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo noplayground">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist(); // ✅ Compiles

    // Relative path
    front_of_house::hosting::add_to_waitlist(); // ✅ Compiles
}
</code></pre>
<p>{{#label pub-keyword}} <span class="caption">清单 {{#ref pub-keyword}}:
将 <code>hosting</code> 模块声明为 <code>pub</code> 以便从 <code>eat_at_restaurant</code> 使用它</span></p>
<p>现在代码可以编译了！要了解为什么添加 <code>pub</code> 关键字让我们可以在遵守隐私规则的情况下在 <code>add_to_waitlist</code> 中使用这些路径，让我们看看绝对路径和相对路径。</p>
<p>在绝对路径中，我们从 crate 根开始，即我们 crate 模块树的根。<code>front_of_house</code> 模块定义在 crate 根中。虽然 <code>front_of_house</code> 不是公有的，因为 <code>eat_at_restaurant</code> 函数定义在与 <code>front_of_house</code> 相同的模块中（也就是说，<code>front_of_house</code> 和 <code>eat_at_restaurant</code> 是兄弟），我们可以从 <code>eat_at_restaurant</code> 引用 <code>front_of_house</code>。接下来是用 <code>pub</code> 标记的 <code>hosting</code> 模块。我们可以访问 <code>hosting</code> 的父模块，所以我们可以访问 <code>hosting</code> 本身。最后，<code>add_to_waitlist</code> 函数用 <code>pub</code> 标记，我们可以访问其父模块，所以这个函数调用有效！</p>
<p>在相对路径中，逻辑与绝对路径相同，除了第一步：路径不是从 crate 根开始，而是从 <code>front_of_house</code> 开始。<code>front_of_house</code> 模块定义在与 <code>eat_at_restaurant</code> 相同的模块内，所以从定义 <code>eat_at_restaurant</code> 的模块开始的相对路径有效。接下来，因为 <code>hosting</code> 和 <code>add_to_waitlist</code> 标记为 <code>pub</code>，路径的其余部分有效，这个函数调用是有效的！</p>
<p>{{#quiz ../quizzes/ch07-03-paths-in-module-tree-1.toml}}</p>
<h2 id="使用-super-开始相对路径"><a class="header" href="#使用-super-开始相对路径">使用 <code>super</code> 开始相对路径</a></h2>
<p>我们可以通过在路径开头使用 <code>super</code>，构造从父模块而不是当前模块或 crate 根开始的相对路径。这就像以 <code>..</code> 语法开始文件系统路径一样。使用 <code>super</code> 允许我们引用我们知道在父模块中的项，这可以在模块与父模块紧密相关，但父模块将来可能移动到模块树中其他位置时，更容易重新排列模块树。</p>
<p>考虑清单 {{#ref relative-path}} 中的代码，它模拟了厨师修复错误订单并亲自将其带给顾客的情况。定义在 <code>back_of_house</code> 模块中的函数 <code>fix_incorrect_order</code> 调用定义在父模块中的函数 <code>deliver_order</code>，通过指定以 <code>super</code> 开头的 <code>deliver_order</code> 路径：</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo noplayground">fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}
</code></pre>
<p>{{#label relative-path}} <span class="caption">清单 {{#ref relative-path}}:
使用以 <code>super</code> 开头的相对路径调用函数</span></p>
<p>在这里你可以直接看到你可以使用 <code>super</code> 轻松访问父模块，而在以前并非如此。注意 <code>back_of_house</code> 保持私有，因为外部用户不应该直接与后厨交互。</p>
<h2 id="使结构体和枚举公有"><a class="header" href="#使结构体和枚举公有">使结构体和枚举公有</a></h2>
<p>我们也可以使用 <code>pub</code> 来指定结构体和枚举为公有，但使用 <code>pub</code> 处理结构体和枚举时有一些额外的细节需要考虑。</p>
<ul>
<li>如果我们在结构体定义前使用 <code>pub</code>，我们使结构体公有，但结构体的字段仍然是私有的。我们可以根据具体情况使每个字段公有或不公有。</li>
<li>相反，如果我们使枚举公有，它的所有变体将是公有的。我们只需要在 <code>enum</code> 关键字前加上 <code>pub</code>。</li>
</ul>
<p>还有一种涉及 <code>pub</code> 的情况我们没有涉及到，那就是我们最后的模块系统功能：<code>use</code> 关键字。我们将首先单独介绍 <code>use</code>，然后我们将展示如何结合 <code>pub</code> 和 <code>use</code>。</p>
<p>{{#quiz ../quizzes/ch07-03-paths-in-module-tree-2.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="使用-use-关键字将路径引入作用域"><a class="header" href="#使用-use-关键字将路径引入作用域">使用 <code>use</code> 关键字将路径引入作用域</a></h1>
<p>必须写出路径来调用函数可能会让人觉得不方便和重复。幸运的是，有一种方法可以简化这个过程：我们可以使用 <code>use</code> 关键字一次性创建一个路径的快捷方式，然后在作用域的其他地方使用更短的名称。</p>
<p>在清单 {{#ref use-keyword}} 中，我们将 <code>crate::front_of_house::hosting</code> 模块引入 <code>eat_at_restaurant</code> 函数的作用域，这样我们只需要指定 <code>hosting::add_to_waitlist</code> 就可以在 <code>eat_at_restaurant</code> 中调用 <code>add_to_waitlist</code> 函数。</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo">// section "Defining Modules to Control Scope"

mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}
use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist(); // ✅ Shorter path
}
</code></pre>
<p>{{#label use-keyword}} <span class="caption">清单 {{#ref use-keyword}}:
使用 <code>use</code> 将模块引入作用域</span></p>
<p>在作用域中添加 <code>use</code> 和路径类似于在文件系统中创建符号链接。通过在 crate 根中添加 <code>use crate::front_of_house::hosting;</code>，<code>hosting</code> 现在在该作用域中是一个有效的名称，就像 <code>hosting</code> 模块被定义在 crate 根中一样。</p>
<p>注意 <code>use</code> 只能在 <code>use</code> 发生的特定作用域内创建快捷方式。清单 {{#ref use-scope}} 将 <code>eat_at_restaurant</code> 函数移动到一个名为 <code>customer</code> 的新子模块中，这与 <code>use</code> 语句是不同的作用域，所以函数体将无法编译：</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}
use crate::front_of_house::hosting;

mod customer {
    pub fn eat_at_restaurant() {
        hosting::add_to_waitlist();
    }
}
</code></pre>
<p>{{#label use-scope}} <span class="caption">清单 {{#ref use-scope}}: <code>use</code> 语句只适用于它所在的作用域。</span></p>
<p>编译器错误显示快捷方式不再在 <code>customer</code> 模块内适用：</p>
<pre><code class="language-shell">$ scarb build 
   Compiling listing_07_05 v0.1.0 (listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_07_use_and_scope/Scarb.toml)
warn: Unused import: `listing_07_05::hosting`
 --&gt; listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_07_use_and_scope/src/lib.cairo:9:28
use crate::front_of_house::hosting;
                           ^^^^^^^

error[E0006]: Identifier not found.
 --&gt; listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_07_use_and_scope/src/lib.cairo:13:9
        hosting::add_to_waitlist();
        ^^^^^^^

error: could not compile `listing_07_05` due to previous error

</code></pre>
<h2 id="创建惯用的-use-路径"><a class="header" href="#创建惯用的-use-路径">创建惯用的 <code>use</code> 路径</a></h2>
<p>在清单 {{#ref use-keyword}} 中，你可能想知道为什么我们指定 <code>use crate::front_of_house::hosting</code> 然后在 <code>eat_at_restaurant</code> 中调用 <code>hosting::add_to_waitlist</code>，而不是指定 <code>use</code> 路径一直到 <code>add_to_waitlist</code> 函数以实现相同的结果，如清单 {{#ref unidiomatic-use}} 所示。</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}
use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
}
</code></pre>
<p>{{#label unidiomatic-use}} <span class="caption">清单
{{#ref unidiomatic-use}}: 使用 <code>use</code> 将 <code>add_to_waitlist</code> 函数引入作用域，这是不惯用的</span></p>
<p>虽然清单 {{#ref use-keyword}} 和 {{#ref unidiomatic-use}} 完成了相同的任务，但清单 {{#ref use-keyword}} 是使用 <code>use</code> 将函数引入作用域的惯用方式。使用 <code>use</code> 将函数的父模块引入作用域意味着我们在调用函数时必须指定父模块。在调用函数时指定父模块可以清楚地表明该函数不是在本地定义的，同时仍最大程度地减少完整路径的重复。清单 {{#ref unidiomatic-use}} 中的代码不清楚 <code>add_to_waitlist</code> 是在哪里定义的。</p>
<p>另一方面，当使用 <code>use</code> 引入结构体、枚举、trait 和其他项时，指定完整路径是惯用的。清单 {{#ref idiomatic-use}} 展示了将核心库的 <code>BitSize</code> trait 引入作用域的惯用方式，允许调用 <code>bits</code> 方法来检索类型的位数大小。</p>
<pre><code class="language-cairo">use core::num::traits::BitSize;

#[executable]
fn main() {
    let u8_size: usize = BitSize::&lt;u8&gt;::bits();
    println!("A u8 variable has {} bits", u8_size)
}
</code></pre>
<p>{{#label idiomatic-use}} <span class="caption">清单 {{#ref idiomatic-use}}: 以惯用方式将 <code>BitSize</code> trait 引入作用域</span></p>
<p>这种习惯没有什么强烈的理由：这只是 Rust 社区中出现的惯例，人们已经习惯了以这种方式阅读和编写 Rust 代码。由于 Cairo 共享许多 Rust 的惯名词，我们也遵循这个惯例。</p>
<p>这个惯用语法的例外是如果我们使用 <code>use</code> 语句将两个同名的项引入作用域，因为 Cairo 不允许这样做。</p>
<h3 id="使用-as-关键字提供新名称"><a class="header" href="#使用-as-关键字提供新名称">使用 <code>as</code> 关键字提供新名称</a></h3>
<p>对于使用 <code>use</code> 将两个同名类型引入同一作用域的问题，还有另一种解决方案：在路径之后，我们可以指定 <code>as</code> 和一个新的本地名称，或类型的 <em>别名 (alias)</em>。清单 {{#ref as-keyword}} 展示了如何使用 <code>as</code> 重命名导入：</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo">use core::array::ArrayTrait as Arr;

#[executable]
fn main() {
    let mut arr = Arr::new(); // ArrayTrait was renamed to Arr
    arr.append(1);
}
</code></pre>
<p>{{#label as-keyword}} <span class="caption">清单 {{#ref as-keyword}}:
使用 <code>as</code> 关键字将 trait 引入作用域时重命名它</span></p>
<p>在这里，我们将 <code>ArrayTrait</code> 引入作用域，别名为 <code>Arr</code>。我们现在可以使用 <code>Arr</code> 标识符访问该 trait 的方法。</p>
<h3 id="从同一模块导入多个项"><a class="header" href="#从同一模块导入多个项">从同一模块导入多个项</a></h3>
<p>当你想从同一个模块导入多个项（如函数、结构体或枚举）时，你可以使用花括号 <code>{}</code> 列出你想导入的所有项。这有助于保持你的代码整洁易读，避免一长串单独的 <code>use</code> 语句。</p>
<p>从同一模块导入多个项的一般语法是：</p>
<pre><code class="language-cairo">use module::{item1, item2, item3};
</code></pre>
<p>这是一个我们从同一个模块导入三个结构的例子：</p>
<pre><code class="language-cairo">// Assuming we have a module called `shapes` with the structures `Square`, `Circle`, and `Triangle`.
mod shapes {
    #[derive(Drop)]
    pub struct Square {
        pub side: u32,
    }

    #[derive(Drop)]
    pub struct Circle {
        pub radius: u32,
    }

    #[derive(Drop)]
    pub struct Triangle {
        pub base: u32,
        pub height: u32,
    }
}

// We can import the structures `Square`, `Circle`, and `Triangle` from the `shapes` module like
// this:
use shapes::{Circle, Square, Triangle};

// Now we can directly use `Square`, `Circle`, and `Triangle` in our code.
#[executable]
fn main() {
    let sq = Square { side: 5 };
    let cr = Circle { radius: 3 };
    let tr = Triangle { base: 5, height: 2 };
    // ...
}
</code></pre>
<p>{{#label multiple-imports}} <span class="caption">清单
{{#ref multiple-imports}}: 从同一模块导入多个项</span></p>
<h2 id="在模块文件中重导出名称"><a class="header" href="#在模块文件中重导出名称">在模块文件中重导出名称</a></h2>
<p>当我们使用 <code>use</code> 关键字将名称引入作用域时，新作用域中可用的名称可以像在该代码作用域中定义的一样被导入。这种技术称为 <em>重导出 (re-exporting)</em>，因为我们将一个项引入作用域，但也通过 <code>pub</code> 关键字使该项可供其他人引入他们的作用域。</p>
<p>例如，让我们在餐厅示例中重导出 <code>add_to_waitlist</code> 函数：</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
</code></pre>
<p>{{#label reexporting}} <span class="caption">清单 {{#ref reexporting}}:
使用 <code>pub use</code> 使名称可供任何代码从新作用域使用</span></p>
<p>在此更改之前，外部代码必须使用路径 <code>restaurant::front_of_house::hosting::add_to_waitlist()</code> 调用 <code>add_to_waitlist</code> 函数。现在 <code>pub use</code> 已经从根模块重导出了 <code>hosting</code> 模块，外部代码现在可以使用路径 <code>restaurant::hosting::add_to_waitlist()</code>。</p>
<p>当你的代码的内部结构与调用你的代码的程序员对领域的思考方式不同时，重导出很有用。例如，在这个餐厅隐喻中，经营餐厅的人会考虑“前厅”和“后厨”。但是访问餐厅的顾客可能不会用这些术语来思考餐厅的部分。使用 <code>pub use</code>，我们可以用一种结构编写代码，但暴露另一种结构。这样做使我们的库对于处理库的程序员和调用库的程序员来说都组织良好。</p>
<h2 id="使用-scarb-在-cairo-中使用外部包"><a class="header" href="#使用-scarb-在-cairo-中使用外部包">使用 Scarb 在 Cairo 中使用外部包</a></h2>
<p>你可能需要使用外部包来利用社区提供的功能。Scarb 允许你通过从 Git 仓库克隆包来使用依赖项。要在 Scarb 项目中使用外部包，只需在 <em>Scarb.toml</em> 配置文件中的专用 <code>[dependencies]</code> 部分中声明你要添加的依赖项的 Git 仓库 URL。请注意，URL 可能对应于 main 分支，或任何特定的提交、分支或标签。为此，你需要分别传递额外的 <code>rev</code>、<code>branch</code> 或 <code>tag</code> 字段。例如，以下代码从 <em>alexandria</em> 包导入 <em>alexandria_math</em> crate 的 main 分支：</p>
<pre><code class="language-cairo">[dependencies]
alexandria_math = { git = "https://github.com/keep-starknet-strange/alexandria.git" }
</code></pre>
<p>而由于以下代码导入特定分支（已弃用，不应使用）：</p>
<pre><code class="language-cairo">[dependencies]
alexandria_math = { git = "https://github.com/keep-starknet-strange/alexandria.git", branch = "cairo-v2.3.0-rc0" }
</code></pre>
<p>如果你想在项目中导入多个包，你只需要创建一个 <code>[dependencies]</code> 部分并在其下列出所有所需的包。你也可以通过声明 <code>[dev-dependencies]</code> 部分来指定开发依赖项。</p>
<p>之后，只需运行 <code>scarb build</code> 即可获取所有外部依赖项并编译包含所有依赖项的包。</p>
<p>注意，也可以使用 <code>scarb add</code> 命令添加依赖项，该命令会自动为你编辑 <em>Scarb.toml</em> 文件。对于开发依赖项，只需使用 <code>scarb add --dev</code> 命令。</p>
<p>要删除依赖项，只需从 <em>Scarb.toml</em> 文件中删除相应的行，或使用 <code>scarb rm</code> 命令。</p>
<h2 id="glob-运算符"><a class="header" href="#glob-运算符">Glob 运算符</a></h2>
<p>如果我们想将通过路径定义的所有公共项引入作用域，我们可以指定该路径后跟 <code>*</code> glob 运算符：</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use core::num::traits::*;
<span class="boring">}</span></code></pre>
<p>这个 <code>use</code> 语句将 <code>core::num::traits</code> 中定义的所有公共项引入当前作用域。使用 glob 运算符时要小心！Glob 会使你更难分辨哪些名称在作用域内，以及程序中使用的名称是在哪里定义的。</p>
<p>Glob 运算符通常在测试时用于将所有测试内容引入 <code>tests</code> 模块；我们将在第 {{#chap how-to-write-tests}} 章的 <a href="#如何编写测试">“如何编写测试”</a> 一节中讨论这一点。</p>
<p>{{#quiz ../quizzes/ch07-04-bringing-paths-into-scope.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="将模块分离到不同文件"><a class="header" href="#将模块分离到不同文件">将模块分离到不同文件</a></h1>
<p>到目前为止，本章中的所有示例都在一个文件中定义了多个模块。当模块变大时，你可能希望将它们的定义移动到单独的文件中，以使代码更易于浏览。</p>
<p>例如，让我们从清单 {{#ref use-keyword}} 中的代码开始，它有多个餐厅模块。我们将把模块提取到文件中，而不是将所有模块定义在 crate 根文件中。在这种情况下，crate 根文件是 <em>src/lib.cairo</em>。</p>
<p>首先，我们将把 <code>front_of_house</code> 模块提取到它自己的文件中。删除 <code>front_of_house</code> 模块花括号内的代码，只保留 <code>mod front_of_house;</code> 声明，以便 <em>src/lib.cairo</em> 包含清单 {{#ref front-extraction}} 中显示的代码。注意，在我们创建 <em>src/front_of_house.cairo</em> 文件之前，这不会编译。</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo noplayground">mod front_of_house;
use crate::front_of_house::hosting;

fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
</code></pre>
<p>{{#label front-extraction}} <span class="caption">清单
{{#ref front-extraction}}: 声明 <code>front_of_house</code> 模块，其主体将位于 <em>src/front_of_house.cairo</em> 中</span></p>
<p>接下来，将花括号中的代码放入名为 <em>src/front_of_house.cairo</em> 的新文件中，如清单 {{#ref module-foh}} 所示。编译器知道在这个文件中查找，因为它在 crate 根目录中遇到了名为 <code>front_of_house</code> 的模块声明。</p>
<p><span class="filename">文件名: src/front_of_house.cairo</span></p>
<pre><code class="language-cairo noplayground">pub mod hosting {
    pub fn add_to_waitlist() {}
}
</code></pre>
<p>{{#label module-foh}} <span class="caption">清单 {{#ref module-foh}}:
<em>src/front_of_house.cairo</em> 中 <code>front_of_house</code> 模块内的定义</span></p>
<p>注意，在你的模块树中，你也只需要使用 <code>mod</code> 声明加载一次文件。一旦编译器知道该文件是项目的一部分（并且知道代码位于模块树中的何处，因为你放置了 <code>mod</code> 语句），项目中的其他文件应该使用指向其声明位置的路径来引用加载文件的代码，这在 <a href="#引用模块树中项的路径">“引用模块树中项的路径”</a> 一章中已涵盖。换句话说，<code>mod</code> <em>不是</em> 你可能在其他编程语言中看到的“包含”操作。</p>
<p>接下来，我们将把 <code>hosting</code> 模块提取到它自己的文件中。过程有点不同，因为 <code>hosting</code> 是 <code>front_of_house</code> 的子模块，而不是根模块的子模块。我们将把 <code>hosting</code> 的文件放在一个以此模块树中的祖先命名的新目录中，在这种情况下是 <em>src/front_of_house/</em>。</p>
<p>开始移动 <code>hosting</code>，我们更改 <em>src/front_of_house.cairo</em> 以仅包含 <code>hosting</code> 模块的声明：</p>
<p><span class="filename">文件名: src/front_of_house.cairo</span></p>
<pre><code class="language-cairo noplayground">pub mod hosting;
</code></pre>
<p>然后我们创建一个 <em>src/front_of_house</em> 目录和一个文件 <em>hosting.cairo</em> 来包含 <code>hosting</code> 模块中的定义：</p>
<p><span class="filename">文件名: src/front_of_house/hosting.cairo</span></p>
<pre><code class="language-cairo noplayground">pub fn add_to_waitlist() {}
</code></pre>
<p>如果我们把 <em>hosting.cairo</em> 放在 <em>src</em> 目录中，编译器会期望 <em>hosting.cairo</em> 代码位于 crate 根目录声明的 <code>hosting</code> 模块中，而不是声明为 <code>front_of_house</code> 模块的子模块。编译器关于检查哪些文件以获取哪些模块代码的规则意味着目录和文件更紧密地匹配模块树。</p>
<p>我们将每个模块的代码移动到了单独的文件中，模块树保持不变。<code>eat_at_restaurant</code> 中的函数调用无需任何修改即可工作，即使定义位于不同的文件中。这种技术允许你在模块大小增长时将模块移动到新文件中。</p>
<p>注意 <em>src/lib.cairo</em> 中的 <code>use crate::front_of_house::hosting;</code> 语句也没有改变，<code>use</code> 对作为 crate 一部分编译的文件也没有任何影响。<code>mod</code> 关键字声明模块，Cairo 会在与模块同名的文件中查找进入该模块的代码。</p>
<h2 id="总结-3"><a class="header" href="#总结-3">总结</a></h2>
<p>Cairo 允许你将一个包拆分为多个 crate，将一个 crate 拆分为多个模块，以便你可以从另一个模块引用一个模块中定义的项。你可以通过指定绝对路径或相对路径来做到这一点。这些路径可以使用 <code>use</code> 语句引入作用域，以便你可以在该作用域中多次使用该项时使用更短的路径。模块代码默认是 <strong>私有</strong> 的。</p>
<p>{{#quiz ../quizzes/ch07-05-separate-modules.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="泛型类型和-traits"><a class="header" href="#泛型类型和-traits">泛型类型和 Traits</a></h1>
<p>每种编程语言都有有效处理概念重复的工具。在 Cairo 中，泛型 (generics) 就是这样一个工具：具体类型或其他属性的抽象替代品。我们可以在不知道编译和运行代码时具体是什么类型的情况下，表达泛型的行为或它们与其他泛型的关系。</p>
<p>函数可以接受某种泛型类型的参数，而不是像 <code>u32</code> 或 <code>bool</code> 这样的具体类型，就像函数接受具有未知值的参数以在多个具体值上运行相同的代码一样。事实上，我们已经在 <a href="#the-option-enum-and-its-advantages">第 {{#chap enums-and-pattern-matching}} 章</a> 中使用了 <code>Option&lt;T&gt;</code> 的泛型。</p>
<p>在本章中，你将探索如何定义你自己的带有泛型的类型、函数和 traits。</p>
<p>泛型允许我们用代表多种类型的占位符替换特定类型，以消除代码重复。编译时，编译器会为替换泛型类型的每个具体类型创建一个新定义，从而减少程序员的开发时间，但编译级别的代码重复仍然存在。如果你正在编写 Starknet 合约并为多种类型使用泛型，这可能很重要，因为这将导致合约大小增加。</p>
<p>然后你将学习如何使用 traits 以通用的方式定义行为。你可以将 traits 与泛型类型结合使用，以约束泛型类型只接受那些具有特定行为的类型，而不仅仅是任何类型。</p>
<h2 id="通过提取函数消除重复"><a class="header" href="#通过提取函数消除重复">通过提取函数消除重复</a></h2>
<p>泛型允许我们用代表多种类型的占位符替换特定类型，以消除代码重复。在深入研究泛型语法之前，让我们首先看看如何通过提取一个用代表多个值的占位符替换特定值的函数，以一种不涉及泛型类型的方式消除重复。然后我们将应用相同的技术来提取一个泛型函数！通过学习如何识别可以提取到函数中的重复代码，你将开始认识到可以使用泛型来减少重复的情况。</p>
<p>我们从一个寻找 <code>u8</code> 数组中最大数字的简短程序开始：</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut number_list: Array&lt;u8&gt; = array![34, 50, 25, 100, 65];

    let mut largest = number_list.pop_front().unwrap();

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
}
</code></pre>
<p>我们将一个 <code>u8</code> 数组存储在变量 <code>number_list</code> 中，并将数组中的第一个数字提取到名为 <code>largest</code> 的变量中。然后我们遍历数组中的所有数字，如果当前数字大于存储在 <code>largest</code> 中的数字，我们更新 <code>largest</code> 的值。但是，如果当前数字小于或等于目前看到的最大数字，变量不会改变，代码将继续处理列表中的下一个数字。在考虑了数组中的所有数字后，<code>largest</code> 应该包含最大的数字，在这个例子中是 100。</p>
<p>现在的任务是在两个不同的数字数组中找到最大的数字。为此，我们可以选择重复之前的代码，并在程序的两个不同位置使用相同的逻辑，如下所示：</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut number_list: Array&lt;u8&gt; = array![34, 50, 25, 100, 65];

    let mut largest = number_list.pop_front().unwrap();

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);

    let mut number_list: Array&lt;u8&gt; = array![102, 34, 255, 89, 54, 2, 43, 8];

    let mut largest = number_list.pop_front().unwrap();

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
}
</code></pre>
<p>虽然这段代码有效，但复制代码既乏味又容易出错。当我们想更改代码时，咱们还必须记住在多个地方更新代码。</p>
<p>为了消除这种重复，我们将通过定义一个对参数中传入的任何 <code>u8</code> 数组进行操作的函数来创建一个抽象。这个解决方案使我们的代码更清晰，并让我们能够抽象地表达在数组中寻找最大数字的概念。</p>
<p>为此，我们将寻找最大数字的代码提取到一个名为 <code>largest</code> 的函数中。然后我们调用该函数来查找两个数组中的最大数字。我们也可以在将来可能拥有的任何其他 <code>u8</code> 值数组上使用该函数。</p>
<pre><code class="language-cairo">fn largest(ref number_list: Array&lt;u8&gt;) -&gt; u8 {
    let mut largest = number_list.pop_front().unwrap();

    for number in number_list.span() {
        if *number &gt; largest {
            largest = *number;
        }
    }

    largest
}

#[executable]
fn main() {
    let mut number_list = array![34, 50, 25, 100, 65];

    let result = largest(ref number_list);
    println!("The largest number is {}", result);

    let mut number_list = array![102, 34, 255, 89, 54, 2, 43, 8];

    let result = largest(ref number_list);
    println!("The largest number is {}", result);
}
</code></pre>
<p>largest 函数有一个名为 <code>number_list</code> 的参数，通过引用传递，它代表我们可以传递给函数的任何具体的 <code>u8</code> 值数组。结果，当我们调用该函数时，代码在我们传入的特定值上运行。</p>
<p>总之，这是我们要更改代码所采取的步骤：</p>
<ul>
<li>识别重复代码。</li>
<li>将重复代码提取到函数体中，并在函数签名中指定该代码的输入和返回值。</li>
<li>更新重复代码的两个实例以改为调用该函数。</li>
</ul>
<p>接下来，我们将对泛型使用相同的步骤来减少代码重复。就像函数体可以对抽象的 <code>Array&lt;T&gt;</code> 而不是特定的 <code>u8</code> 值进行操作一样，泛型允许代码对抽象类型进行操作。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="泛型数据类型"><a class="header" href="#泛型数据类型">泛型数据类型</a></h1>
<p>我们使用泛型来为项声明（如结构体和函数）创建定义，然后我们可以将它们与许多不同的具体数据类型一起使用。在 Cairo 中，我们可以在定义函数、结构体、枚举、traits、实现和方法时使用泛型。在本章中，我们将看看如何有效地对所有这些使用泛型类型。</p>
<p>泛型允许我们编写适用于多种类型的可重用代码，从而避免代码重复，同时增强代码的可维护性。</p>
<h2 id="泛型函数"><a class="header" href="#泛型函数">泛型函数</a></h2>
<p>使函数泛型化意味着它可以对不同类型进行操作，从而避免了需要多个特定于类型的实现。这就导致了显着的代码减少并增加了代码的灵活性。</p>
<p>在定义使用泛型的函数时，我们将泛型放在函数签名中，我们通常会在那里指定参数和返回值的数据类型。例如，想象我们想要创建一个函数，给定两个项的 <code>Array</code>，它将返回最大的那个。如果我们需对不同类型的列表执行此操作，那么我们将不得不每次重新定义该函数。幸运的是，我们可以使用泛型一次性实现该函数，然后继续处理其他任务。</p>
<pre><code class="language-cairo">// Specify generic type T between the angulars
fn largest_list&lt;T&gt;(l1: Array&lt;T&gt;, l2: Array&lt;T&gt;) -&gt; Array&lt;T&gt; {
    if l1.len() &gt; l2.len() {
        l1
    } else {
        l2
    }
}

#[executable]
fn main() {
    let mut l1 = array![1, 2];
    let mut l2 = array![3, 4, 5];

    // There is no need to specify the concrete type of T because
    // it is inferred by the compiler
    let l3 = largest_list(l1, l2);
}
</code></pre>
<p><code>largest_list</code> 函数比较两个相同类型的列表，并返回元素较多的那个，并删除另一个。如果你编译前面的代码，你会注意到它会因错误而失败，说没有定义用于删除泛型类型数组的 traits。发生这种情况是因为编译器在执行 <code>main</code> 函数时无法保证 <code>Array&lt;T&gt;</code> 是可删除的 (droppable)。为了删除 <code>T</code> 的数组，编译器必须首先知道如何删除 <code>T</code>。这可以通过在 <code>largest_list</code> 的函数签名中指定 <code>T</code> 必须实现 <code>Drop</code> trait 来修复。<code>largest_list</code> 的正确函数定义如下：</p>
<pre><code class="language-cairo">fn largest_list&lt;T, impl TDrop: Drop&lt;T&gt;&gt;(l1: Array&lt;T&gt;, l2: Array&lt;T&gt;) -&gt; Array&lt;T&gt; {
    if l1.len() &gt; l2.len() {
        l1
    } else {
        l2
    }
}
</code></pre>
<p>新的 <code>largest_list</code> 函数在其定义中包含了要求：无论放在那里的泛型类型是什么，它必须是可删除的。这就是我们要说的 <em>trait 约束 (trait bounds)</em>。<code>main</code> 函数保持不变，编译器足够聪明，可以推断出正在使用哪种具体类型以及它是否实现了 <code>Drop</code> trait。</p>
<h3 id="泛型类型的约束"><a class="header" href="#泛型类型的约束">泛型类型的约束</a></h3>
<p>在定义泛型类型时，拥有关于它们的信息很有用。知道泛型类型实现了哪些 trait 允许我们在函数的逻辑中更有效地使用它，代价是约束可以与函数一起使用的泛型类型。我们之前通过将 <code>TDrop</code> 实现添加为 <code>largest_list</code> 的泛型参数的一部分来看到了这一点的示例。虽然添加 <code>TDrop</code> 是为了满足编译器的要求，但我们也可以添加约束以使我们的函数逻辑受益。</p>
<p>想象我们有一个某种泛型类型 <code>T</code> 的元素列表，我们想在其中找到最小的元素。最初，我们知道对于类型 <code>T</code> 的元素是可比较的，它必须实现 <code>PartialOrd</code> trait。结果函数将是：</p>
<pre><code class="language-cairo">// Given a list of T get the smallest one
// The PartialOrd trait implements comparison operations for T
fn smallest_element&lt;T, impl TPartialOrd: PartialOrd&lt;T&gt;&gt;(list: @Array&lt;T&gt;) -&gt; T {
    // This represents the smallest element through the iteration
    // Notice that we use the desnap (*) operator
    let mut smallest = *list[0];

    // The index we will use to move through the list
    let mut index = 1;

    // Iterate through the whole list storing the smallest
    while index &lt; list.len() {
        if *list[index] &lt; smallest {
            smallest = *list[index];
        }
        index = index + 1;
    }

    smallest
}

#[executable]
fn main() {
    let list: Array&lt;u8&gt; = array![5, 3, 10];

    // We need to specify that we are passing a snapshot of `list` as an argument
    let s = smallest_element(@list);
    assert!(s == 3);
}
</code></pre>
<p><code>smallest_element</code> 函数使用实现 <code>PartialOrd</code> trait 的泛型类型 <code>T</code>，接受 <code>Array&lt;T&gt;</code> 的快照作为参数并返回最小元素的副本。因为参数是 <code>@Array&lt;T&gt;</code> 类型，我们不再需要在执行结束时删除它，所以我们不需要为 <code>T</code> 也实现 <code>Drop</code> trait。那为什么它不能编译呢？</p>
<p>在 <code>list</code> 上索引时，结果值是索引元素的快照，除非为 <code>@T</code> 实现了 <code>PartialOrd</code>，否则我们需要使用 <code>*</code> 除快照 (desnap) 元素。<code>*</code> 操作需要从 <code>@T</code> 复制到 <code>T</code>，这意味着 <code>T</code> 需要实现 <code>Copy</code> trait。将类型 <code>@T</code> 的元素复制到 <code>T</code> 后，现在有了需要删除的类型 <code>T</code> 的变量，这就要求 <code>T</code> 也实现 <code>Drop</code> trait。我们必须添加 <code>Drop</code> 和 <code>Copy</code> traits 实现以使函数正确。更新 <code>smallest_element</code> 函数后，结果代码将是：</p>
<pre><code class="language-cairo">fn smallest_element&lt;T, impl TPartialOrd: PartialOrd&lt;T&gt;, impl TCopy: Copy&lt;T&gt;, impl TDrop: Drop&lt;T&gt;&gt;(
    list: @Array&lt;T&gt;,
) -&gt; T {
    let mut smallest = *list[0];
    let mut index = 1;

    while index &lt; list.len() {
        if *list[index] &lt; smallest {
            smallest = *list[index];
        }
        index = index + 1;
    }

    smallest
}
</code></pre>
<h3 id="匿名泛型实现参数--运算符"><a class="header" href="#匿名泛型实现参数--运算符">匿名泛型实现参数 (<code>+</code> 运算符)</a></h3>
<p>到目前为止，我们总是为每个需要的泛型 trait 实现指定一个名称：<code>TPartialOrd</code> 对应 <code>PartialOrd&lt;T&gt;</code>，<code>TDrop</code> 对应 <code>Drop&lt;T&gt;</code>，<code>TCopy</code> 对应 <code>Copy&lt;T&gt;</code>。</p>
<p>然而，大多数时候，我们在函数​​体内不使用实现；我们只将其用作约束。在这些情况下，我们可以使用 <code>+</code> 运算符来指定泛型类型必须实现一个 trait，而无需命名该实现。这被称为 <em>匿名泛型实现参数 (anonymous generic implementation parameter)</em>。</p>
<p>例如，<code>+PartialOrd&lt;T&gt;</code> 等价于 <code>impl TPartialOrd: PartialOrd&lt;T&gt;</code>。</p>
<p>我们可以如下重写 <code>smallest_element</code> 函数签名：</p>
<pre><code class="language-cairo">&lt;!-- Warning: Anchor '1' not found in lib.cairo --&gt;
</code></pre>
<h2 id="结构体"><a class="header" href="#结构体">结构体</a></h2>
<p>我们还可以定义结构体以对一个或多个字段使用泛型类型参数，使用 <code>&lt;&gt;</code> 语法，类似于函数定义。首先，我们在结构体名称后面的尖括号内声明类型参数的名称。然后我们在结构体定义中使用泛型类型，否则我们会指定具体数据类型。下一个代码示例展示了定义 <code>Wallet&lt;T&gt;</code>，它有一个类型为 <code>T</code> 的 <code>balance</code> 字段。</p>
<pre><code class="language-cairo">#[derive(Drop)]
struct Wallet&lt;T&gt; {
    balance: T,
}

#[executable]
fn main() {
    let w = Wallet { balance: 3 };
}
</code></pre>
<p>上述代码自动为 <code>Wallet</code> 类型派生 <code>Drop</code> trait。它等效于编写以下代码：</p>
<pre><code class="language-cairo">struct Wallet&lt;T&gt; {
    balance: T,
}

impl WalletDrop&lt;T, +Drop&lt;T&gt;&gt; of Drop&lt;Wallet&lt;T&gt;&gt;;

#[executable]
fn main() {
    let w = Wallet { balance: 3 };
}
</code></pre>
<p>我们避免对 <code>Wallet</code> 的 <code>Drop</code> 实现使用 <code>derive</code> 宏，而是定义我们自己的 <code>WalletDrop</code> 实现。注意，就像函数一样，我们必须为 <code>WalletDrop</code> 定义一个额外的泛型类型，说明 <code>T</code> 也实现了 <code>Drop</code> trait。我们基本上是在说，只要 <code>T</code> 也是可删除的，结构体 <code>Wallet&lt;T&gt;</code> 就是可删除的。</p>
<p>最后，如果我们想向 <code>Wallet</code> 添加一个表示其地址的字段，并且我们希望该字段与 <code>T</code> 不同但也通用的，我们可以简单地在 <code>&lt;&gt;</code> 之间添加另一个泛型类型：</p>
<pre><code class="language-cairo">#[derive(Drop)]
struct Wallet&lt;T, U&gt; {
    balance: T,
    address: U,
}

#[executable]
fn main() {
    let w = Wallet { balance: 3, address: 14 };
}
</code></pre>
<p>我们向 <code>Wallet</code> 结构体定义添加了一个新的泛型类型 <code>U</code>，然后将此类型分配给新的字段成员 <code>address</code>。注意 <code>Drop</code> trait 的 <code>derive</code> 属性对 <code>U</code>也有效。</p>
<h2 id="枚举-1"><a class="header" href="#枚举-1">枚举</a></h2>
<p>正如我们对结构体所做的那样，我们可以定义枚举以在其变体中持有泛型数据类型。例如 Cairo 核心库提供的 <code>Option&lt;T&gt;</code> 枚举：</p>
<pre><code class="language-cairo noplayground">enum Option&lt;T&gt; {
    Some: T,
    None,
}
</code></pre>
<p><code>Option&lt;T&gt;</code> 枚举在类型 <code>T</code> 上是泛型的，并且有两个变体：<code>Some</code>，它持有一个类型为 <code>T</code> 的值，以及 <code>None</code>，它不持有任何值。通过使用 <code>Option&lt;T&gt;</code> 枚举，我们可以表达可选值的抽象概念，并且因为该值具有泛型类型 <code>T</code>，我们可以将此抽象与任何类型一起使用。</p>
<p>枚举也可以使用多个泛型类型，就像核心库提供的 <code>Result&lt;T, E&gt;</code> 枚举的定义一样：</p>
<pre><code class="language-cairo noplayground">enum Result&lt;T, E&gt; {
    Ok: T,
    Err: E,
}
</code></pre>
<p><code>Result&lt;T, E&gt;</code> 枚举有两个泛型类型 <code>T</code> 和 <code>E</code>，以及两个变体：<code>Ok</code> 持有类型 <code>T</code> 的值，<code>Err</code> 持有类型 <code>E</code> 的值。这个定义使得在任何我们有一个可能成功（通过返回类型 <code>T</code> 的值）或失败（通过返回类型 <code>E</code> 的值）的操作的地方使用 <code>Result</code> 枚举变得方便。</p>
<h2 id="泛型方法"><a class="header" href="#泛型方法">泛型方法</a></h2>
<p>我们可以在结构体和枚举上实现方法，并在其定义中也使用泛型类型。使用我们之前的 <code>Wallet&lt;T&gt;</code> 结构体定义，我们为它定义一个 <code>balance</code> 方法：</p>
<pre><code class="language-cairo">#[derive(Copy, Drop)]
struct Wallet&lt;T&gt; {
    balance: T,
}

trait WalletTrait&lt;T&gt; {
    fn balance(self: @Wallet&lt;T&gt;) -&gt; T;
}

impl WalletImpl&lt;T, +Copy&lt;T&gt;&gt; of WalletTrait&lt;T&gt; {
    fn balance(self: @Wallet&lt;T&gt;) -&gt; T {
        return *self.balance;
    }
}

#[executable]
fn main() {
    let w = Wallet { balance: 50 };
    assert!(w.balance() == 50);
}
</code></pre>
<p>我们首先定义 <code>WalletTrait&lt;T&gt;</code> trait，使用泛型类型 <code>T</code> 定义一个返回 <code>Wallet</code> 中 <code>balance</code> 字段值的方法。然后在 <code>WalletImpl&lt;T&gt;</code> 中给出该 trait 的实现。注意，你需要在 trait 和实现的定义中都包含泛型类型。</p>
<p>在类型上定义方法时，我们还可以指定对泛型类型的约束。例如，我们可以只为 <code>Wallet&lt;u128&gt;</code> 实例实现方法，而不是为 <code>Wallet&lt;T&gt;</code> 实现。在代码示例中，我们为 <code>balance</code> 字段具有具体类型 <code>u128</code> 的钱包定义了一个实现。</p>
<pre><code class="language-cairo">#[derive(Copy, Drop)]
struct Wallet&lt;T&gt; {
    balance: T,
}

/// Generic trait for wallets
trait WalletTrait&lt;T&gt; {
    fn balance(self: @Wallet&lt;T&gt;) -&gt; T;
}

impl WalletImpl&lt;T, +Copy&lt;T&gt;&gt; of WalletTrait&lt;T&gt; {
    fn balance(self: @Wallet&lt;T&gt;) -&gt; T {
        return *self.balance;
    }
}

/// Trait for wallets of type u128
trait WalletReceiveTrait {
    fn receive(ref self: Wallet&lt;u128&gt;, value: u128);
}

impl WalletReceiveImpl of WalletReceiveTrait {
    fn receive(ref self: Wallet&lt;u128&gt;, value: u128) {
        self.balance += value;
    }
}

#[executable]
fn main() {
    let mut w = Wallet { balance: 50 };
    assert!(w.balance() == 50);

    w.receive(100);
    assert!(w.balance() == 150);
}
</code></pre>
<p>新方法 <code>receive</code> 增加了任何 <code>Wallet&lt;u128&gt;</code> 实例的 <code>balance</code> 大小。注意我们更改了 <code>main</code> 函数，使 <code>w</code> 成为可变变量，以便它能够更新其余额。如果我们通过更改 <code>balance</code> 的类型来更改 <code>w</code> 的初始化，之前的代码将无法编译。</p>
<p>Cairo 也允许我们在泛型 trait 中定义泛型方法。使用过去 <code>Wallet&lt;U, V&gt;</code> 的实现，我们将定义一个 trait，它选择两个不同泛型类型的钱包并创建一个具有每种泛型类型的新钱包。首先，让我们重写结构体定义：</p>
<pre><code class="language-cairo noplayground">struct Wallet&lt;T, U&gt; {
    balance: T,
    address: U,
}
</code></pre>
<p>接下来，我们将天真地定义 mixup trait 和实现：</p>
<pre><code class="language-cairo noplayground">// This does not compile!
trait WalletMixTrait&lt;T1, U1&gt; {
    fn mixup&lt;T2, U2&gt;(self: Wallet&lt;T1, U1&gt;, other: Wallet&lt;T2, U2&gt;) -&gt; Wallet&lt;T1, U2&gt;;
}

impl WalletMixImpl&lt;T1, U1&gt; of WalletMixTrait&lt;T1, U1&gt; {
    fn mixup&lt;T2, U2&gt;(self: Wallet&lt;T1, U1&gt;, other: Wallet&lt;T2, U2&gt;) -&gt; Wallet&lt;T1, U2&gt; {
        Wallet { balance: self.balance, address: other.address }
    }
}

</code></pre>
<p>我们创建了一个带有 <code>mixup&lt;T2, U2&gt;</code> 方法的 trait <code>WalletMixTrait&lt;T1, U1&gt;</code>，给定 <code>Wallet&lt;T1, U1&gt;</code> 和 <code>Wallet&lt;T2, U2&gt;</code> 的实例，它创建一个新的 <code>Wallet&lt;T1, U2&gt;</code>。正如 <code>mixup</code> 签名所指定的，<code>self</code> 和 <code>other</code> 都在函数结束时被删除，这就是为什么这段代码无法编译的原因。如果你从一开始就跟随到现在，你会知道我们必须为所有泛型类型添加一个要求，指定它们将实现 <code>Drop</code> trait，以便编译器知道如何删除 <code>Wallet&lt;T, U&gt;</code> 的实例。更新后的实现如下：</p>
<pre><code class="language-cairo">trait WalletMixTrait&lt;T1, U1&gt; {
    fn mixup&lt;T2, +Drop&lt;T2&gt;, U2, +Drop&lt;U2&gt;&gt;(
        self: Wallet&lt;T1, U1&gt;, other: Wallet&lt;T2, U2&gt;,
    ) -&gt; Wallet&lt;T1, U2&gt;;
}

impl WalletMixImpl&lt;T1, +Drop&lt;T1&gt;, U1, +Drop&lt;U1&gt;&gt; of WalletMixTrait&lt;T1, U1&gt; {
    fn mixup&lt;T2, +Drop&lt;T2&gt;, U2, +Drop&lt;U2&gt;&gt;(
        self: Wallet&lt;T1, U1&gt;, other: Wallet&lt;T2, U2&gt;,
    ) -&gt; Wallet&lt;T1, U2&gt; {
        Wallet { balance: self.balance, address: other.address }
    }
}
</code></pre>
<p>我们在 <code>WalletMixImpl</code> 声明中为 <code>T1</code> 和 <code>U1</code> 添加了可删除的要求。然后我们为 <code>T2</code> 和 <code>U2</code> 做同样的事情，这次是作为 <code>mixup</code> 签名的一部分。我们现在可以尝试 <code>mixup</code> 函数：</p>
<pre><code class="language-cairo noplayground">#[executable]
fn main() {
    let w1: Wallet&lt;bool, u128&gt; = Wallet { balance: true, address: 10 };
    let w2: Wallet&lt;felt252, u8&gt; = Wallet { balance: 32, address: 100 };

    let w3 = w1.mixup(w2);

    assert!(w3.balance);
    assert!(w3.address == 100);
}
</code></pre>
<p>我们首先创建两个实例：一个 <code>Wallet&lt;bool, u128&gt;</code> 和另一个 <code>Wallet&lt;felt252, u8&gt;</code>。然后，我们调用 <code>mixup</code> 并创建一个新的 <code>Wallet&lt;bool, u8&gt;</code> 实例。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cairo-中的-traits"><a class="header" href="#cairo-中的-traits">Cairo 中的 Traits</a></h1>
<p>Trait 定义了某种类型可以实现的一组方法。当此 trait 被实现时，可以在该类型的实例上调用这些方法。Trait 与泛型类型结合，定义了某种特定类型具有并可以与其他类型共享的功能。我们可以使用 traits 以抽象的方式定义共享行为。我们可以使用 <em>trait 约束 (trait bounds)</em> 来指定泛型类型可以是任何具有特定行为的类型。</p>
<blockquote>
<p>注意：Traits 类似于其他语言中常称为接口 (interfaces) 的功能，尽管有一些差异。</p>
</blockquote>
<p>虽然编写 traits 可以不接受泛型类型，但当与泛型类型一起使用时，它们最有用。我们在 <a href="#泛型数据类型">上一章</a> 已经涵盖了泛型，我们将在本章中使用它们来演示如何使用 traits 来定义泛型类型的共享行为。</p>
<h2 id="定义-trait"><a class="header" href="#定义-trait">定义 Trait</a></h2>
<p>一个类型的行为由我们可以对该类型调用的方法组成。如果我们可以在所有那些类型上调用相同的方法，则不同的类型共享相同的行为。Trait 定义是一种将方法签名组合在一起的方法，以定义实现某些目的所需的一组行为。</p>
<p>例如，通过在特定位置持有新闻故事，比方说我们有一个结构体 <code>NewsArticle</code>。我们可以定义一个 trait <code>Summary</code>，它描述了可以总结 <code>NewsArticle</code> 类型的东西的行为。</p>
<pre><code class="language-cairo noplayground">pub trait Summary {
    fn summarize(self: @NewsArticle) -&gt; ByteArray;
}
</code></pre>
<p>{{#label first_trait_signature}} <span class="caption"> 清单
{{#ref first_trait_signature}}: 一个 <code>Summary</code> trait，由 <code>summarize</code> 方法提供的行为组成</span></p>
<p>在清单 {{#ref first_trait_signature}} 中，我们使用 <code>trait</code> 关键字声明一个 trait，然后是 trait 的名称，在本例中为 <code>Summary</code>。我们还将 trait 声明为 <code>pub</code>，以便依赖此 crate 的 crate 也可以使用此 trait，我们将在几个示例中看到。</p>
<p>在花括号内，我们声明描述实现此 trait 的类型的行为的方法签名，在这个例子中是 <code>fn summarize(self: @NewsArticle) -&gt; ByteArray;</code>。在方法签名之后，我们不提供花括号内的实现，而是使用分号。</p>
<blockquote>
<p>注意：<code>ByteArray</code> 类型是 Cairo 中用于表示字符串的类型。</p>
</blockquote>
<p>由于 trait 不是泛型的，<code>self</code> 参数也不是泛型的，并且是 <code>@NewsArticle</code> 类型。这意味着 <code>summarize</code> 方法只能在 <code>NewsArticle</code> 的实例上调用。</p>
<p>现在，考虑我们想制作一个名为 <em>aggregator</em> 的媒体聚合器库 crate，它可以显示可能存储在 <code>NewsArticle</code> 或 <code>Tweet</code> 实例中的数据的摘要。为此，我们需要每种类型的摘要，我们将通过在该类型的实例上调用 summarize 方法来请求该摘要。通过在泛型类型 <code>T</code> 上定义 <code>Summary</code> trait，我们可以在任何我们想要能够总结的类型上实现 <code>summarize</code> 方法。</p>
<pre><code class="language-cairo noplayground">    pub trait Summary&lt;T&gt; {
        fn summarize(self: @T) -&gt; ByteArray;
    }
</code></pre>
<p>{{#label trait_signature}} <span class="caption"> 清单
{{#ref trait_signature}}: 一个 <code>Summary</code> trait，由泛型类型的 <code>summarize</code> 方法提供的行为组成</span></p>
<p>每个实现此 trait 的类型都必须为方法体提供自己的自定义行为。编译器将强制要求任何实现 <code>Summary</code> trait 的类型都由完全具有此签名的方法 <code>summarize</code> 定义。</p>
<p>一个 trait 可以在其主体中有多个方法：方法签名每行一个，每行以分号结尾。</p>
<h2 id="在类型上实现-trait"><a class="header" href="#在类型上实现-trait">在类型上实现 Trait</a></h2>
<p>现在我们已经定义了 <code>Summary</code> trait 方法所需的签名，我们可以在我们的媒体聚合器中的类型上实现它。以下代码展示了 <code>Summary</code> trait 在 <code>NewsArticle</code> 结构体上的实现，它使用标题、作者和位置来创建 <code>summarize</code> 的返回值。对于 <code>Tweet</code> 结构体，我们将 <code>summarize</code> 定义为用户名后跟推文的全部文本，假设推文内容已被限制为 280 个字符。</p>
<pre><code class="language-cairo noplayground">    #[derive(Drop)]
    pub struct NewsArticle {
        pub headline: ByteArray,
        pub location: ByteArray,
        pub author: ByteArray,
        pub content: ByteArray,
    }

    impl NewsArticleSummary of Summary&lt;NewsArticle&gt; {
        fn summarize(self: @NewsArticle) -&gt; ByteArray {
            format!("{} by {} ({})", self.headline, self.author, self.location)
        }
    }

    #[derive(Drop)]
    pub struct Tweet {
        pub username: ByteArray,
        pub content: ByteArray,
        pub reply: bool,
        pub retweet: bool,
    }

    impl TweetSummary of Summary&lt;Tweet&gt; {
        fn summarize(self: @Tweet) -&gt; ByteArray {
            format!("{}: {}", self.username, self.content)
        }
    }
</code></pre>
<p>{{#label trait_impl}} <span class="caption"> 清单 {{#ref trait_impl}}:
<code>Summary</code> trait 在 <code>NewsArticle</code> 和 <code>Tweet</code> 上的实现</span></p>
<p>在类型上实现 trait 类似于实现常规方法。区别在于，在 <code>impl</code> 之后，我们为实现放一个名称，然后使用 <code>of</code> 关键字，然后指定我们要为其编写实现的 trait 的名称。如果实现是针对泛型类型的，我们将泛型类型名称放在 trait 名称后的尖括号中。</p>
<p>注意，为了使 trait 方法可访问，必须有从调用方法的范围可见的该 trait 的实现。如果 trait 是 <code>pub</code> 而实现不是，并且实现从调用 trait 方法的范围不可见，这将导致编译错误。</p>
<p>在 <code>impl</code> 块中，我们放置 trait 定义已定义的方法签名。我们不使用分号结束每个签名，而是使用花括号，并在方法体中填写我们希望 trait 方法对特定类型具有的特定行为。</p>
<p>现在库已经在 <code>NewsArticle</code> 和 <code>Tweet</code> 上实现了 <code>Summary</code> trait，crate 的用户可以像调用常规方法一样在 <code>NewsArticle</code> 和 <code>Tweet</code> 的实例上调用 trait 方法。唯一的区别是用户必须将 trait 以及类型引入作用域。这是一个 crate 如何使用我们的 <code>aggregator</code> crate 的示例：</p>
<pre><code class="language-cairo">use aggregator::{NewsArticle, Summary, Tweet};

#[executable]
fn main() {
    let news = NewsArticle {
        headline: "Cairo has become the most popular language for developers",
        location: "Worldwide",
        author: "Cairo Digger",
        content: "Cairo is a new programming language for zero-knowledge proofs",
    };

    let tweet = Tweet {
        username: "EliBenSasson",
        content: "Crypto is full of short-term maximizing projects. \n @Starknet and @StarkWareLtd are about long-term vision maximization.",
        reply: false,
        retweet: false,
    }; // Tweet instantiation

    println!("New article available! {}", news.summarize());
    println!("New tweet! {}", tweet.summarize());
}
</code></pre>
<p>{{#label trait_main}}</p>
<p>这段代码打印以下内容：</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_15_traits v0.1.0 (listings/ch08-generic-types-and-traits/no_listing_15_traits/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing no_listing_15_traits
New article available! Cairo has become the most popular language for developers by Cairo Digger (Worldwide)
New tweet! EliBenSasson: Crypto is full of short-term maximizing projects. 
 @Starknet and @StarkWareLtd are about long-term vision maximization.


</code></pre>
<p>依赖 <em>aggregator</em> crate 的其他 crate 也可以将 <code>Summary</code> trait 引入作用域，以在它们自己的类型上实现 <code>Summary</code>。</p>
<h2 id="默认实现"><a class="header" href="#默认实现">默认实现</a></h2>
<p>有时，为 trait 中的某些或所有方法提供默认行为，而不是要求在每种类型上实现所有方法，这很有用。然后，当我们在特定类型上实现 trait 时，我们可以保留或覆盖每个方法的默认行为。</p>
<p>在清单 {{#ref default_impl}} 中，我们要为 <code>Summary</code> trait 的 <code>summarize</code> 方法指定一个默认字符串，而不是仅定义方法签名，就像我们在清单 {{#ref trait_signature}} 中所做的那样。</p>
<p><span class="caption">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo">    pub trait Summary&lt;T&gt; {
        fn summarize(self: @T) -&gt; ByteArray {
            "(Read more...)"
        }
    }
</code></pre>
<p>{{#label default_impl}} <span class="caption"> 清单 {{#ref default_impl}}:
定义一个带有 <code>summarize</code> 方法默认实现的 <code>Summary</code> trait</span></p>
<p>要使用默认实现总结 <code>NewsArticle</code> 的实例，我们指定一个空的 <code>impl</code> 块 <code>impl NewsArticleSummary of Summary&lt;NewsArticle&gt; {}</code>。</p>
<p>即使我们不再直接在 <code>NewsArticle</code> 上定义 <code>summarize</code> 方法，我们已经提供了一个默认实现，并指定 <code>NewsArticle</code> 实现了 <code>Summary</code> trait。因此，我们仍然可以在 <code>NewsArticle</code> 的实例上调用 <code>summarize</code> 方法，如下所示：</p>
<pre><code class="language-cairo">use aggregator::{NewsArticle, Summary};

#[executable]
fn main() {
    let news = NewsArticle {
        headline: "Cairo has become the most popular language for developers",
        location: "Worldwide",
        author: "Cairo Digger",
        content: "Cairo is a new programming language for zero-knowledge proofs",
    };

    println!("New article available! {}", news.summarize());
}
</code></pre>
<p>这段代码打印 <code>New article available! (Read more...)</code>。</p>
<p>创建默认实现不需要我们更改关于 <code>Tweet</code> 上 <code>Summary</code> 的先前实现的任何内容。原因是覆盖默认实现的语法与实现没有默认实现的 trait 方法的语法相同。</p>
<p>默认实现可以调用同一 trait 中的其他方法，即使那些其他方法没有默认实现。通过这种方式，trait 可以提供许多有用的功能，并且只需要实现者指定其中的一小部分。例如，我们可以定义 <code>Summary</code> trait 有一个 <code>summarize_author</code> 方法，其实现是必需的，然后定义一个 <code>summarize</code> 方法，该方法具有调用 <code>summarize_author</code> 方法的默认实现：</p>
<pre><code class="language-cairo">    pub trait Summary&lt;T&gt; {
        fn summarize(
            self: @T,
        ) -&gt; ByteArray {
            format!("(Read more from {}...)", Self::summarize_author(self))
        }
        fn summarize_author(self: @T) -&gt; ByteArray;
    }
</code></pre>
<p>要使用这个版本的 <code>Summary</code>，我们在类型上实现该 trait 时只需要定义 <code>summarize_author</code>：</p>
<pre><code class="language-cairo">    impl TweetSummary of Summary&lt;Tweet&gt; {
        fn summarize_author(self: @Tweet) -&gt; ByteArray {
            format!("@{}", self.username)
        }
    }
</code></pre>
<p>在定义了 <code>summarize_author</code> 后，我们可以在 <code>Tweet</code> 结构体的实例上调用 <code>summarize</code>，<code>summarize</code> 的默认实现将调用我们提供的 <code>summarize_author</code> 定义。因为我们已经实现了 <code>summarize_author</code>，<code>Summary</code> trait 给了我们 <code>summarize</code> 方法的行为，而不需要我们编写更多代码。</p>
<pre><code class="language-cairo">use aggregator::{Summary, Tweet};

#[executable]
fn main() {
    let tweet = Tweet {
        username: "EliBenSasson",
        content: "Crypto is full of short-term maximizing projects. \n @Starknet and @StarkWareLtd are about long-term vision maximization.",
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}
</code></pre>
<p>这段代码打印 <code>1 new tweet: (Read more from @EliBenSasson...)</code>。</p>
<p>注意，无法从同一方法的覆盖实现中调用默认实现。</p>
<!-- TODO: NOT AVAILABLE IN CAIRO FOR NOW move traits as parameters here -->
<!-- ## Traits as parameters
 
 Now that you know how to define and implement traits, we can explore how to use
 traits to define functions that accept many different types. We'll use the
 `Summary` trait we implemented on the `NewsArticle` and `Tweet` types to define a `notify` function that calls the `summarize` method
 on its `item` parameter, which is of some type that implements the `Summary` trait. To do this, we use the `impl Trait` syntax.
 
 Instead of a concrete type for the `item` parameter, we specify the `impl`
 keyword and the trait name. This parameter accepts any type that implements the
 specified trait. In the body of `notify`, we can call any methods on `item`
 that come from the `Summary` trait, such as `summarize`. We can call `notify`
 and pass in any instance of `NewsArticle` or `Tweet`. Code that calls the
 function with any other type, such as a `String` or an `i32`, won’t compile
 because those types don’t implement `Summary`. -->
<!-- TODO NOT AVAILABLE IN CAIRO FOR NOW Using trait bounds to conditionally implement methods -->
<h2 id="管理和使用外部-trait"><a class="header" href="#管理和使用外部-trait">管理和使用外部 Trait</a></h2>
<p>要使用 trait 方法，你需要确保障导入了正确的 traits/实现。在某些情况下，如果 trait 和实现是在单独的模块中声明的，你可能不仅需要导入 trait，还需要导入实现。如果 <code>CircleGeometry</code> 实现位于名为 <em>circle</em> 的单独模块/文件中，那么为了在 <code>Circle</code> 结构体上定义 <code>boundary</code> 方法，我们需要在 <em>circle</em> 模块中导入 <code>ShapeGeometry</code> trait。</p>
<p>如果代码像清单 {{#ref external_trait}} 那样组织成模块，其中 trait 的实现定义在与 trait 本身不同的模块中，则需要显式导入相关的 trait 或实现。</p>
<pre><code class="language-cairo noplayground">// Here T is an alias type which will be provided during implementation
pub trait ShapeGeometry&lt;T&gt; {
    fn boundary(self: T) -&gt; u64;
    fn area(self: T) -&gt; u64;
}

mod rectangle {
    // Importing ShapeGeometry is required to implement this trait for Rectangle
    use super::ShapeGeometry;

    #[derive(Copy, Drop)]
    pub struct Rectangle {
        pub height: u64,
        pub width: u64,
    }

    // Implementation RectangleGeometry passes in &lt;Rectangle&gt;
    // to implement the trait for that type
    impl RectangleGeometry of ShapeGeometry&lt;Rectangle&gt; {
        fn boundary(self: Rectangle) -&gt; u64 {
            2 * (self.height + self.width)
        }
        fn area(self: Rectangle) -&gt; u64 {
            self.height * self.width
        }
    }
}

mod circle {
    // Importing ShapeGeometry is required to implement this trait for Circle
    use super::ShapeGeometry;

    #[derive(Copy, Drop)]
    pub struct Circle {
        pub radius: u64,
    }

    // Implementation CircleGeometry passes in &lt;Circle&gt;
    // to implement the imported trait for that type
    impl CircleGeometry of ShapeGeometry&lt;Circle&gt; {
        fn boundary(self: Circle) -&gt; u64 {
            (2 * 314 * self.radius) / 100
        }
        fn area(self: Circle) -&gt; u64 {
            (314 * self.radius * self.radius) / 100
        }
    }
}
use circle::Circle;
use rectangle::Rectangle;

#[executable]
fn main() {
    let rect = Rectangle { height: 5, width: 7 };
    println!("Rectangle area: {}", ShapeGeometry::area(rect)); //35
    println!("Rectangle boundary: {}", ShapeGeometry::boundary(rect)); //24

    let circ = Circle { radius: 5 };
    println!("Circle area: {}", ShapeGeometry::area(circ)); //78
    println!("Circle boundary: {}", ShapeGeometry::boundary(circ)); //31
}
</code></pre>
<p>{{#label external_trait}} <span class="caption"> 清单
{{#ref external_trait}}: 实现外部 trait</span></p>
<p>注意，在清单 {{#ref external_trait}} 中，<code>CircleGeometry</code> 和 <code>RectangleGeometry</code> 实现不需要声明为 <code>pub</code>。事实上，公有的 <code>ShapeGeometry</code> trait 用于在 <code>main</code> 函数中打印结果。无论实现的可见性如何，编译器都会为 <code>ShapeGeometry</code> 公有 trait 找到合适的实现。</p>
<h2 id="impl-别名"><a class="header" href="#impl-别名">Impl 别名</a></h2>
<p>实现在导入时可以使用别名。当你想用具体类型实例化泛型实现时，这最有用。例如，假设我们定义了一个用于为类型 <code>T</code> 返回值 <code>2</code> 的 trait <code>Two</code>。我们可以通过简单地加上两倍的 <code>one</code> 值并返回它，为所有实现 <code>One</code> trait 的类型编写 <code>Two</code> 的微不足道的泛型实现。然而，在我们的公共 API 中，我们可能只想暴露 <code>u8</code> 和 <code>u128</code> 类型的 <code>Two</code> 实现。</p>
<pre><code class="language-cairo noplayground">trait Two&lt;T&gt; {
    fn two() -&gt; T;
}

mod one_based {
    pub impl TwoImpl&lt;
        T, +Copy&lt;T&gt;, +Drop&lt;T&gt;, +Add&lt;T&gt;, impl One: core::num::traits::One&lt;T&gt;,
    &gt; of super::Two&lt;T&gt; {
        fn two() -&gt; T {
            One::one() + One::one()
        }
    }
}

pub impl U8Two = one_based::TwoImpl&lt;u8&gt;;
pub impl U128Two = one_based::TwoImpl&lt;u128&gt;;
</code></pre>
<p>{{#label impl-aliases}} <span class="caption"> 清单 {{#ref impl-aliases}}:
使用 impl 别名用具体类型实例化泛型 impl</span></p>
<p>我们可以在私有模块中定义泛型实现，使用 impl 别名为这两个具体类型实例化泛型实现，并使这两个实现公有，同时保持泛型实现私有且不暴露。这样，我们可以避免使用泛型实现的代码重复，同时保持公共 API 的干净和简单。</p>
<h2 id="负实现-negative-impls"><a class="header" href="#负实现-negative-impls">负实现 (Negative Impls)</a></h2>
<blockquote>
<p>注意：这仍然是一个实验性功能，只有在你的 <em>Scarb.toml</em> 文件的 <code>[package]</code> 部分下启用 <code>experimental-features = ["negative_impls"]</code> 才能使用。</p>
</blockquote>
<p>负实现，也称为负 traits 或负约束，是一种允许你在定义泛型类型的 trait 实现时表达类型 <em>不</em> 实现某个 trait 的机制。负 impl 使你能够编写仅在当前范围内不存在另一个实现时才适用的实现。</p>
<p>例如，假设我们有一个 trait <code>Producer</code> 和一个 trait <code>Consumer</code>，我们想定义一个泛型行为，其中所有类型默认实现 <code>Consumer</code> trait。然而，我们要确保没有类型既可以作为 <code>Consumer</code> 又可以作为 <code>Producer</code>。我们可以使用负 impl 来表达此限制。</p>
<p>在清单 {{#ref negative-impls}} 中，我们定义了一个实现 <code>Producer</code> trait 的 <code>ProducerType</code>，以及另外两个不实现 <code>Producer</code> trait 的类型 <code>AnotherType</code> 和 <code>AThirdType</code>。然后我们使用负 impl 为所有不实现 <code>Producer</code> trait 的类型创建 <code>Consumer</code> trait 的默认实现。</p>
<pre><code class="language-cairo">#[derive(Drop)]
struct ProducerType {}

#[derive(Drop, Debug)]
struct AnotherType {}

#[derive(Drop, Debug)]
struct AThirdType {}

trait Producer&lt;T&gt; {
    fn produce(self: T) -&gt; u32;
}

trait Consumer&lt;T&gt; {
    fn consume(self: T, input: u32);
}

impl ProducerImpl of Producer&lt;ProducerType&gt; {
    fn produce(self: ProducerType) -&gt; u32 {
        42
    }
}

impl TConsumerImpl&lt;T, +core::fmt::Debug&lt;T&gt;, +Drop&lt;T&gt;, -Producer&lt;T&gt;&gt; of Consumer&lt;T&gt; {
    fn consume(self: T, input: u32) {
        println!("{:?} consumed value: {}", self, input);
    }
}

#[executable]
fn main() {
    let producer = ProducerType {};
    let another_type = AnotherType {};
    let third_type = AThirdType {};
    let production = producer.produce();

    // producer.consume(production); Invalid: ProducerType does not implement Consumer
    another_type.consume(production);
    third_type.consume(production);
}
</code></pre>
<p>{{#label negative-impls}} <span class="caption"> 清单
{{#ref negative-impls}}: 使用负 impl 强制类型不能同时实现 <code>Producer</code> 和 <code>Consumer</code> traits</span></p>
<p>在 <code>main</code> 函数中，我们创建 <code>ProducerType</code>、<code>AnotherType</code> 和 <code>AThirdType</code> 的实例。然后我们在 <code>producer</code> 实例上调用 <code>produce</code> 方法，并将结果传递给 <code>another_type</code> 和 <code>third_type</code> 实例上的 <code>consume</code> 方法。最后，我们尝试在 <code>producer</code> 实例上调用 <code>consume</code> 方法，这会导致编译时错误，因为 <code>ProducerType</code> 没有实现 <code>Consumer</code> trait。</p>
<h2 id="关联项上的约束-traits"><a class="header" href="#关联项上的约束-traits">关联项上的约束 traits</a></h2>
<blockquote>
<p>目前，关联项被认为是一项实验性功能。为了使用它们，你需要在你的 <code>Scarb.toml</code> 的 <code>[package]</code> 部分下添加以下内容：
<code>experimental-features = ["associated_item_constraints"]</code>。</p>
</blockquote>
<p>在某些情况下，你可能希望根据泛型参数的类约束 trait 的 <a href="#关联项-associated-items">关联项</a>。你可以在 trait 约束后使用 <code>[AssociatedItem: ConstrainedValue]</code> 语法来做到这一点。</p>
<p>假设你想为集合实现一个 <code>extend</code> 方法。此方法接受一个迭代器并将其元素添加到集合中。为了确保类型安全，我们要让迭代器的元素与集合的元素类型匹配。我们可以通过约束 <code>Iterator::Item</code> 关联类型与集合的类型匹配来实现这一点。</p>
<p>在清单 {{#ref associated-items-constraints}} 中，我们通过定义一个 trait <code>Extend&lt;T, A&gt;</code> 并在 <code>extend</code> 函数的 trait 约束上使用 <code>[Item: A]</code> 作为约束来实现这一点。此外，我们使用 <code>Destruct</code> trait 确保迭代器被消耗，并展示了 <code>Extend&lt;Array&lt;T&gt;, T&gt;</code> 的示例实现。</p>
<pre><code class="language-cairo">trait Extend&lt;T, A&gt; {
    fn extend&lt;I, +core::iter::Iterator&lt;I&gt;[Item: A], +Destruct&lt;I&gt;&gt;(ref self: T, iterator: I);
}

impl ArrayExtend&lt;T, +Drop&lt;T&gt;&gt; of Extend&lt;Array&lt;T&gt;, T&gt; {
    fn extend&lt;I, +core::iter::Iterator&lt;I&gt;[Item: T], +Destruct&lt;I&gt;&gt;(ref self: Array&lt;T&gt;, iterator: I) {
        for item in iterator {
            self.append(item);
        }
    }
}
</code></pre>
<p>{{#label associated-items-constraints}} <span class="caption"> 清单
{{#ref associated-items-constraints}}: 使用关联项约束确保类型与另一种类型的关联类型匹配</span></p>
<h2 id="用于类型相等约束的-typeequal-trait"><a class="header" href="#用于类型相等约束的-typeequal-trait">用于类型相等约束的 <code>TypeEqual</code> Trait</a></h2>
<p>来自 <code>core::metaprogramming</code> 模块的 <code>TypeEqual</code> trait 让你能够基于类型相等创建约束。在大多数情况下，你不需要 <code>+TypeEqual</code>，你可以仅使用泛型参数和关联类型约束来实现相同的目的，但 <code>TypeEqual</code> 在某些高级场景中可能很有用。</p>
<p>第一个用例是为匹配特定条件的所有类型实现一个 trait，但排除特定类型。我们通过在 <code>TypeEqual</code> trait 上使用负实现来做到这一点。</p>
<p>在清单 {{#ref type-equal-negative-constraints}} 中，我们创建一个 <code>SafeDefault</code> trait 并为实现 <code>Default</code> 的任何类型 <code>T</code> 实现它。但是，我们使用 <code>-TypeEqual&lt;T, SensitiveData&gt;</code> 排除 <code>SensitiveData</code> 类型。</p>
<pre><code class="language-cairo">trait SafeDefault&lt;T&gt; {
    fn safe_default() -&gt; T;
}

#[derive(Drop, Default)]
struct SensitiveData {
    secret: felt252,
}

// Implement SafeDefault for all types EXCEPT SensitiveData
impl SafeDefaultImpl&lt;
    T, +Default&lt;T&gt;, -core::metaprogramming::TypeEqual&lt;T, SensitiveData&gt;,
&gt; of SafeDefault&lt;T&gt; {
    fn safe_default() -&gt; T {
        Default::default()
    }
}

#[executable]
fn main() {
    let _safe: u8 = SafeDefault::safe_default();
    let _unsafe: SensitiveData = Default::default(); // Allowed
    // This would cause a compile error:
// let _dangerous: SensitiveData = SafeDefault::safe_default();
}
</code></pre>
<p>{{#label type-equal-negative-constraints}} <span class="caption"> 清单
{{#ref type-equal-negative-constraints}}: 使用 <code>TypeEqual</code> trait 从实现中排除特定类型</span></p>
<p>第二个用例是确保两种类型相等，在处理 <a href="#associated-types">关联类型</a> 时特别有用。</p>
<p>在清单 {{#ref type-equal-constraints}} 中，我们用一个具有关联类型 <code>State</code> 的 <code>StateMachine</code> trait 来展示这一点。我们创建两个类型，<code>TA</code> 和 <code>TB</code>，都使用 <code>StateCounter</code> 作为它们的 <code>State</code>。然后我们实现一个 <code>combine</code> 函数，该函数仅在两个状态机具有相同的状态类型时才工作，使用约束 <code>TypeEqual&lt;A::State, B::State&gt;</code>。</p>
<pre><code class="language-cairo">trait StateMachine {
    type State;
    fn transition(ref state: Self::State);
}

#[derive(Copy, Drop)]
struct StateCounter {
    counter: u8,
}

impl TA of StateMachine {
    type State = StateCounter;
    fn transition(ref state: StateCounter) {
        state.counter += 1;
    }
}

impl TB of StateMachine {
    type State = StateCounter;
    fn transition(ref state: StateCounter) {
        state.counter *= 2;
    }
}

fn combine&lt;
    impl A: StateMachine,
    impl B: StateMachine,
    +core::metaprogramming::TypeEqual&lt;A::State, B::State&gt;,
&gt;(
    ref self: A::State,
) {
    A::transition(ref self);
    B::transition(ref self);
}

#[executable]
fn main() {
    let mut initial = StateCounter { counter: 0 };
    combine::&lt;TA, TB&gt;(ref initial);
}
</code></pre>
<p>{{#label type-equal-constraints}} <span class="caption"> 清单
{{#ref type-equal-constraints}}: 使用 <code>TypeEqual</code> trait 确保两种类型具有匹配的关联类型</span></p>
<p>{{#quiz ../quizzes/ch08-02-traits.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h1>
<p>在本章中，我们将探索 Cairo 提供的各种错误处理技术，这不仅允许你解决代码中的潜在问题，还使创建适应性强且可维护的程序变得更加容易。通过检查管理错误的不同方法，例如使用 <code>Result</code> 枚举进行模式匹配，使用 <code>?</code> 运算符进行更符合人体工程学的错误传播，以及使用 <code>unwrap</code> 或 <code>expect</code> 方法处理可恢复错误，你将深入了解 Cairo 的错误处理功能。这些概念对于构建可以有效处理意外情况的健壮应用程序至关重要，从而确保你的代码为生产环境做好准备。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="使用-panic-处理不可恢复错误"><a class="header" href="#使用-panic-处理不可恢复错误">使用 <code>panic</code> 处理不可恢复错误</a></h1>
<p>在 Cairo 中，程序执行期间可能会出现意外问题，从而导致运行时错误。虽然核心库中的 <code>panic</code> 函数无法解决这些错误，但它确实承认了它们的发生并终止程序。在 Cairo 中触发 panic 主要有两种方式：无意中，通过导致代码 panic 的操作（例如，访问超出其边界的数组）；或者故意，通过调用 <code>panic</code> 函数。</p>
<p>当 panic 发生时，它会导致程序突然终止。<code>panic</code> 函数接受一个数组作为参数，该数组可用于提供错误消息并执行展开 (unwind) 过程，其中所有变量都被删除，字典被压缩 (squashed)，以确保程序的安全性以安全地终止执行。</p>
<p>这是我们如何从程序内部调用 <code>panic</code> 并返回错误代码 <code>2</code> 的方法：</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo">// TAG: does_not_run

#[executable]
fn main() {
    let mut data = array![2];

    if true {
        panic(data);
    }
    println!("This line isn't reached");
}
</code></pre>
<p>运行该程序将产生以下输出：</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_01_panic v0.1.0 (listings/ch09-error-handling/no_listing_01_panic/Scarb.toml)
    Finished `dev` profile target(s) in 1 second
   Executing no_listing_01_panic
error: Panicked with 0x2.

</code></pre>
<p>正如你在输出中注意到的那样，永远不会到达对 <code>println!</code> 宏的调用，因为程序在遇到 <code>panic</code> 语句后终止。</p>
<p>在 Cairo 中处理 panic 的另一种更惯用的方法是使用 <code>panic_with_felt252</code> 函数。此函数充当数组定义过程的抽象，并且由于其更清晰、更简洁的意图表达而通常是首选。通过使用 <code>panic_with_felt252</code>，开发人员可以通过提供 <code>felt252</code> 错误消息作为参数在一行代码中 panic，从而使代码更具可读性和可维护性。</p>
<p>让我们看一个例子：</p>
<pre><code class="language-cairo">// TAG: does_not_run

use core::panic_with_felt252;

#[executable]
fn main() {
    panic_with_felt252(2);
}
</code></pre>
<p>执行此程序将产生与之前相同的错误消息。在那种情况下，如果不需要在错误中返回数组和多个值，<code>panic_with_felt252</code> 是一个更简洁的替代方案。</p>
<h2 id="panic-宏"><a class="header" href="#panic-宏"><code>panic!</code> 宏</a></h2>
<p><code>panic!</code> 宏真的很有帮助。之前返回错误代码 <code>2</code> 的示例展示了 <code>panic!</code> 宏是多么方便。不需要像使用 <code>panic</code> 函数那样创建一个数组并将其作为参数传递。</p>
<pre><code class="language-cairo">// TAG: does_not_run

#[executable]
fn main() {
    if true {
        panic!("2");
    }
    println!("This line isn't reached");
}
</code></pre>
<p>与 <code>panic_with_felt252</code> 函数不同，使用 <code>panic!</code> 允许输入（最终是 panic 错误）是长度超过 31 字节的字面量。这是因为 <code>panic!</code> 接受一个字符串作为参数。例如，以下代码行将成功编译：</p>
<pre><code class="language-cairo noplayground">panic!("the error for panic! macro is not limited to 31 characters anymore");
</code></pre>
<h2 id="nopanic-标记"><a class="header" href="#nopanic-标记"><code>nopanic</code> 标记</a></h2>
<p>你可以使用 <code>nopanic</code> 标记来指示一个函数永远不会 panic。只有 <code>nopanic</code> 函数才能在被注释为 <code>nopanic</code> 的函数中调用。</p>
<p>这是一个例子：</p>
<pre><code class="language-cairo noplayground">fn function_never_panic() -&gt; felt252 nopanic {
    42
}
</code></pre>
<p>此函数将始终返回 <code>42</code>，并且保证永远不会 panic。
相反，以下函数不能保证永远不会 panic：</p>
<pre><code class="language-cairo noplayground">fn function_never_panic() nopanic {
    assert!(1 == 1, "what");
}
</code></pre>
<p>如果你尝试编译此包含可能 panic 的代码的函数，你将收到以下错误：</p>
<pre><code class="language-shell">$ scarb execute 
   Compiling no_listing_04_nopanic_wrong v0.1.0 (listings/ch09-error-handling/no_listing_05_nopanic_wrong/Scarb.toml)
error: Function is declared as nopanic but calls a function that may panic.
 --&gt; listings/ch09-error-handling/no_listing_05_nopanic_wrong/src/lib.cairo:4:13
    assert!(1 == 1, "what");
            ^^^^^^

error: Function is declared as nopanic but calls a function that may panic.
 --&gt; listings/ch09-error-handling/no_listing_05_nopanic_wrong/src/lib.cairo:4:5
    assert!(1 == 1, "what");
    ^^^^^^^^^^^^^^^^^^^^^^^

error: could not compile `no_listing_04_nopanic_wrong` due to previous error
error: `scarb` command exited with error

</code></pre>
<p>注意这里有两个可能 panic 的函数：<code>assert</code> 和使用 <code>==</code> 的相等性检查。我们在实践中通常不使用 <code>assert</code> 函数，而是使用 <code>assert!</code> 宏。我们将在 <a href="#checking-results-with-the-assert-macro">测试 Cairo 程序</a> 一章中更详细地讨论 <code>assert!</code> 宏。</p>
<h2 id="panic_with-属性"><a class="header" href="#panic_with-属性"><code>panic_with</code> 属性</a></h2>
<p>你可以使用 <code>panic_with</code> 属性来标记返回 <code>Option</code> 或 <code>Result</code> 的函数。此属性接受两个参数，即作为 panic 原因传递的数据以及包装函数的名称。如果函数返回 <code>None</code> 或 <code>Err</code>，它将为你的带注释函数创建一个包装器，该包装器将使用给定的数据作为 panic 错误进行 panic。</p>
<p>例子：</p>
<pre><code class="language-cairo">// TAG: does_not_run

#[panic_with('value is 0', wrap_not_zero)]
fn wrap_if_not_zero(value: u128) -&gt; Option&lt;u128&gt; {
    if value == 0 {
        None
    } else {
        Some(value)
    }
}

#[executable]
fn main() {
    wrap_if_not_zero(0); // this returns None
    wrap_not_zero(0); // this panics with 'value is 0'
}
</code></pre>
<p>{{#quiz ../quizzes/ch09-01-unrecoverable-errors-with-panic.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="使用-result-处理可恢复错误"><a class="header" href="#使用-result-处理可恢复错误">使用 <code>Result</code> 处理可恢复错误</a></h1>
<p>大多数错误并没有严重到需要程序完全停止。有时，当函数失败时，这是出于你可以轻松解释和响应的原因。例如，如果你尝试将两个大整数相加，并且由于总和超过了最大可表示值而导致操作溢出，你可能希望返回错误或包装的结果，而不是导致未定义的行为或终止进程。</p>
<h2 id="result-枚举"><a class="header" href="#result-枚举"><code>Result</code> 枚举</a></h2>
<p>回忆一下 <a href="#enums">第 {{#chap generic-types-and-traits}} 章中的泛型数据类型</a> 部分，<code>Result</code> 枚举定义为具有两个变体，<code>Ok</code> 和 <code>Err</code>，如下所示：</p>
<pre><code class="language-cairo noplayground">enum Result&lt;T, E&gt; {
    Ok: T,
    Err: E,
}
</code></pre>
<p><code>Result&lt;T, E&gt;</code> 枚举有两个泛型类型 <code>T</code> 和 <code>E</code>，以及两个变体：<code>Ok</code> 持有类型 <code>T</code> 的值，<code>Err</code> 持有类型 <code>E</code> 的值。这个定义使得在任何我们有一个可能成功（通过返回类型 <code>T</code> 的值）或失败（通过返回类型 <code>E</code> 的值）的操作的地方使用 <code>Result</code> 枚举变得方便。</p>
<h2 id="resulttrait"><a class="header" href="#resulttrait"><code>ResultTrait</code></a></h2>
<p><code>ResultTrait</code> trait 提供了用于处理 <code>Result&lt;T, E&gt;</code> 枚举的方法，例如解包值、检查 <code>Result</code> 是 <code>Ok</code> 还是 <code>Err</code> 以及使用自定义消息 panic。<code>ResultTraitImpl</code> 实现定义了这些方法的逻辑。</p>
<pre><code class="language-cairo noplayground">trait ResultTrait&lt;T, E&gt; {
    fn expect&lt;+Drop&lt;E&gt;&gt;(self: Result&lt;T, E&gt;, err: felt252) -&gt; T;

    fn unwrap&lt;+Drop&lt;E&gt;&gt;(self: Result&lt;T, E&gt;) -&gt; T;

    fn expect_err&lt;+Drop&lt;T&gt;&gt;(self: Result&lt;T, E&gt;, err: felt252) -&gt; E;

    fn unwrap_err&lt;+Drop&lt;T&gt;&gt;(self: Result&lt;T, E&gt;) -&gt; E;

    fn is_ok(self: @Result&lt;T, E&gt;) -&gt; bool;

    fn is_err(self: @Result&lt;T, E&gt;) -&gt; bool;
}
</code></pre>
<p><code>expect</code> 和 <code>unwrap</code> 方法类似，它们都试图在 <code>Result&lt;T, E&gt;</code> 处于 <code>Ok</code> 变体时从中提取类型 <code>T</code> 的值。如果 <code>Result</code> 是 <code>Ok(x)</code>，这两种方法都返回以此值 <code>x</code>。然而，这两种方法之间的关键区别在于当 <code>Result</code> 处于 <code>Err</code> 变体时的行为。<code>expect</code> 方法允许你提供自定义错误消息（作为 <code>felt252</code> 值），该消息将在 panic 时使用，从而让你对 panic 有更多的控制和上下文。另一方面，<code>unwrap</code> 方法使用默认错误消息 panic，提供的关于 panic 原因的信息较少。</p>
<p><code>expect_err</code> 和 <code>unwrap_err</code> 方法具有完全相反的行为。如果 <code>Result</code> 是 <code>Err(x)</code>，这两种方法都返回以此值 <code>x</code>。然而，这两种方法之间的关键区别在于 <code>Ok()</code> 的情况。<code>expect_err</code> 方法允许你提供自定义错误消息（作为 <code>felt252</code> 值），该消息将在 panic 时使用，从而让你对 panic 有更多的控制和上下文。另一方面，<code>unwrap_err</code> 方法使用默认错误消息 panic，提供的关于 panic 原因的信息较少。</p>
<p>细心的读者可能已经注意到前四个方法签名中的 <code>&lt;+Drop&lt;T&gt;&gt;</code> 和 <code>&lt;+Drop&lt;E&gt;&gt;</code>。这种语法表示 Cairo 语言中的泛型类型约束，如上一章所示。这些约束表明，关联函数分别需要泛型类型 <code>T</code> 和 <code>E</code> 的 <code>Drop</code> trait 实现。</p>
<p>最后，<code>is_ok</code> 和 <code>is_err</code> 方法是 <code>ResultTrait</code> trait 提供的实用函数，用于检查 <code>Result</code> 枚举值的变体。</p>
<ul>
<li><code>is_ok</code> 接受 <code>Result&lt;T, E&gt;</code> 值的快照，如果 <code>Result</code> 是 <code>Ok</code> 变体（意味着操作成功），则返回 <code>true</code>。如果 <code>Result</code> 是 <code>Err</code> 变体，则返回 <code>false</code>。</li>
<li><code>is_err</code> 接受 <code>Result&lt;T, E&gt;</code> 值的快照，如果 <code>Result</code> 是 <code>Err</code> 变体（意味着操作遇到错误），则返回 <code>true</code>。如果 <code>Result</code> 是 <code>Ok</code> 变体，则返回 <code>false</code>。</li>
</ul>
<p>当你想要检查操作的成功或失败而不消耗 <code>Result</code> 值时，这些方法很有帮助，允许你在不解包它的情况下执行其他操作或根据变体做出决定。</p>
<p>你可以在 <a href="https://github.com/starkware-libs/cairo/blob/main/corelib/src/result.cairo#L20">这里</a> 找到 <code>ResultTrait</code> 的实现。</p>
<p>用例子总是更容易理解。看看这个函数签名：</p>
<pre><code class="language-cairo noplayground">fn u128_overflowing_add(a: u128, b: u128) -&gt; Result&lt;u128, u128&gt;;
</code></pre>
<p>它接受两个 <code>u128</code> 整数 <code>a</code> 和 <code>b</code>，并返回一个 <code>Result&lt;u128, u128&gt;</code>，如果加法不溢出，<code>Ok</code> 变体持有总和，如果加法溢出，则 <code>Err</code> 变体持有溢出的值。</p>
<p>现在，我们可以在其他地方使用这个函数。例如：</p>
<pre><code class="language-cairo noplayground">fn u128_checked_add(a: u128, b: u128) -&gt; Option&lt;u128&gt; {
    match u128_overflowing_add(a, b) {
        Ok(r) =&gt; Some(r),
        Err(r) =&gt; None,
    }
}

</code></pre>
<p>在这里，它接受两个 <code>u128</code> 整数 <code>a</code> 和 <code>b</code>，并返回一个 <code>Option&lt;u128&gt;</code>。它使用 <code>u128_overflowing_add</code> 返回的 <code>Result</code> 来确定加法操作的成功或失败。<code>match</code> 表达式检查来自 <code>u128_overflowing_add</code> 的 <code>Result</code>。如果结果是 <code>Ok(r)</code>，它返回包含总和的 <code>Some(r)</code>。如果结果是 <code>Err(r)</code>，它返回 <code>None</code> 以指示由于溢出而导致操作失败。该函数在溢出的情况下不会 panic。</p>
<p>让我们再举一个例子：</p>
<pre><code class="language-cairo noplayground">fn parse_u8(s: felt252) -&gt; Result&lt;u8, felt252&gt; {
    match s.try_into() {
        Some(value) =&gt; Ok(value),
        None =&gt; Err('Invalid integer'),
    }
}
</code></pre>
<p>在这个例子中，<code>parse_u8</code> 函数接受一个 <code>felt252</code> 并尝试使用 <code>try_into</code> 方法将其转换为 <code>u8</code> 整数。如果成功，它返回 <code>Ok(value)</code>，否则返回 <code>Err('Invalid integer')</code>。</p>
<p>我们的两个测试用例是：</p>
<pre><code class="language-cairo noplayground">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_felt252_to_u8() {
        let number: felt252 = 5;
        // should not panic
        let res = parse_u8(number).unwrap();
    }

    #[test]
    #[should_panic]
    fn test_felt252_to_u8_panic() {
        let number: felt252 = 256;
        // should panic
        let res = parse_u8(number).unwrap();
    }
}
</code></pre>
<p>现在不要担心 <code>#[cfg(test)]</code> 属性。我们将在下一章 <a href="#如何编写测试">测试 Cairo 程序</a> 中更详细地解释它的含义。</p>
<p><code>#[test]</code> 属性意味着该函数是一个测试函数，<code>#[should_panic]</code> 属性意味着如果测试执行 panic，则该测试将通过。</p>
<p>第一个测试从 <code>felt252</code> 到 <code>u8</code> 的有效转换，期望 <code>unwrap</code> 方法不 panic。第二个测试函数尝试转换超出 <code>u8</code> 范围的值，期望 <code>unwrap</code> 方法使用错误消息 <code>Invalid integer</code> panic。</p>
<h2 id="传播错误"><a class="header" href="#传播错误">传播错误</a></h2>
<p>当函数的实现调用可能会失败的东西时，你可以将错误返回给调用代码，以便它可以决定要做什么，而不是在函数本身内部处理错误。这被称为 <em>传播 (propagating)</em> 错误，并赋予调用代码更多的控制权，因为调用代码中可能有比你在代码上下文中可用的更多的信息或逻辑来决定应该如何处理错误。</p>
<p>例如，清单 {{#ref match-example}} 展示了一个函数的实现，它尝试将数字解析为 <code>u8</code> 并使用 match 表达式来处理潜在的错误。</p>
<pre><code class="language-cairo noplayground">// A hypothetical function that might fail
fn parse_u8(input: felt252) -&gt; Result&lt;u8, felt252&gt; {
    let input_u256: u256 = input.into();
    if input_u256 &lt; 256 {
        Result::Ok(input.try_into().unwrap())
    } else {
        Result::Err('Invalid Integer')
    }
}

fn mutate_byte(input: felt252) -&gt; Result&lt;u8, felt252&gt; {
    let input_to_u8 = match parse_u8(input) {
        Result::Ok(num) =&gt; num,
        Result::Err(err) =&gt; { return Result::Err(err); },
    };
    let res = input_to_u8 - 1;
    Result::Ok(res)
}
</code></pre>
<p>{{#label match-example}} <span class="caption">清单 {{#ref match-example}}:
使用 <code>match</code> 表达式将错误返回给调用代码的函数。</span></p>
<p>调用此 <code>parse_u8</code> 的代码将处理获取包含数字的 <code>Ok</code> 值或包含错误消息的 <code>Err</code> 值。由调用代码决定如何处理这些值。如果调用代码获得 <code>Err</code> 值，它可以调用 <code>panic!</code> 并使程序崩溃，或者使用默认值。我们就调用代码实际上试图做什么没有足够的信息，所以我们将所有成功或错误信息向上传播，以便它可以适当地处理。</p>
<p>这种传播错误的模式在 Cairo 中非常常见，以至于 Cairo 提供了问号运算符 <code>?</code> 来使其更容易。</p>
<h2 id="传播错误的快捷方式-运算符"><a class="header" href="#传播错误的快捷方式-运算符">传播错误的快捷方式：<code>?</code> 运算符</a></h2>
<p>清单 {{#ref question-operator}} 展示了 <code>mutate_byte</code> 的实现，它具有与清单 {{#ref match-example}} 中的功能相同的功能，但使用 <code>?</code> 运算符来优雅地处理错误。</p>
<pre><code class="language-cairo noplayground">fn mutate_byte(input: felt252) -&gt; Result&lt;u8, felt252&gt; {
    let input_to_u8: u8 = parse_u8(input)?;
    let res = input_to_u8 - 1;
    Ok(res)
}
</code></pre>
<p>{{#label question-operator}} <span class="caption">清单
{{#ref question-operator}}: 使用 <code>?</code> 运算符将错误返回给调用代码的函数。</span></p>
<p>放置在 <code>Result</code> 值之后的 <code>?</code> 被定义为与我们在清单 1 中定义的用于处理 <code>Result</code> 值的 <code>match</code> 表达式几乎相同的方式工作。如果 <code>Result</code> 的值是 <code>Ok</code>，则 <code>Ok</code> 内部的值将从该表达式返回，并且程序将继续。如果值是 <code>Err</code>，则 <code>Err</code> 将从整个函数返回，就像我们使用了 <code>return</code> 关键字一样，以便错误值传播到调用代码。</p>
<p>在清单 2 的上下文中，<code>parse_u8</code> 调用末尾的 <code>?</code> 将把 <code>Ok</code> 内部的值返回给变量 <code>input_to_u8</code>。如果发生错误，<code>?</code> 运算符将提前退出整个函数并将任何 <code>Err</code> 值提供给调用代码。</p>
<p><code>?</code> 运算符消除了大量的样板代码，并使该函数的实现更简单且更符合人体工程学。</p>
<h3 id="可以在哪里使用--运算符"><a class="header" href="#可以在哪里使用--运算符">可以在哪里使用 <code>?</code> 运算符</a></h3>
<p><code>?</code> 运算符只能在返回类型与 <code>?</code> 作用的值兼容的函数中使用。这是因为 <code>?</code> 运算符被定义为从函数中提前返回一个值，这与我们在清单 {{#ref match-example}} 中定义的 <code>match</code> 表达式的方式相同。在清单 {{#ref match-example}} 中，<code>match</code> 使用的是 <code>Result</code> 值，并且提前返回分支返回了一个 <code>Err(e)</code> 值。函数的返回类型必须是 <code>Result</code>，以便它与此返回兼容。</p>
<p>在清单 {{#ref question-operator-wrong-return}} 中，让我们看看如果我们在这个返回类型与我们使用 <code>?</code> 的值的类型不兼容的函数中使用 <code>?</code> 运算符会得到什么错误。</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let some_num = parse_u8(258)?;
}
</code></pre>
<p>{{#label question-operator-wrong-return}} <span class="caption">清单
{{#ref question-operator-wrong-return}}: 尝试在返回 <code>()</code> 的 <code>main</code> 函数中使用 <code>?</code> 将无法编译。</span></p>
<p>这段代码调用了一个可能会失败的函数。<code>?</code> 运算符跟在 <code>parse_u8</code> 返回的 <code>Result</code> 值之后，但这 <code>main</code> 函数的返回类型是 <code>()</code>，而不是 <code>Result</code>。当我们编译这段代码时，我们会得到类似这样的错误消息：</p>
<pre><code class="language-text">$ scarb build 
   Compiling listing_invalid_qmark v0.1.0 (listings/ch09-error-handling/listing_invalid_qmark/Scarb.toml)
error: `?` can only be used in a function with `Option` or `Result` return type.
 --&gt; listings/ch09-error-handling/listing_invalid_qmark/src/lib.cairo:6:20
    let some_num = parse_u8(258)?;
                   ^^^^^^^^^^^^^^

warn[E0001]: Unused variable. Consider ignoring by prefixing with `_`.
 --&gt; listings/ch09-error-handling/listing_invalid_qmark/src/lib.cairo:6:9
    let some_num = parse_u8(258)?;
        ^^^^^^^^

error: could not compile `listing_invalid_qmark` due to previous error

</code></pre>
<p>此错误指出我们只允许在返回 <code>Result</code> 或 <code>Option</code> 的函数中使用 <code>?</code> 运算符。</p>
<p>要修复此错误，你有两个选择。一种选择是将函数的返回类型更改为与你使用 <code>?</code> 运算符的值兼容，只要你没有阻止这样做的限制。另一种选择是使用 <code>match</code> 以任何合适的方式处理 <code>Result&lt;T, E&gt;</code>。</p>
<p>错误消息还提到 <code>?</code> 也可以与 <code>Option&lt;T&gt;</code> 值一起使用。与在 <code>Result</code> 上使用 <code>?</code> 一样，你只能在返回 <code>Option</code> 的函数中在 <code>Option</code> 上使用 <code>?</code>。在 <code>Option&lt;T&gt;</code> 上调用时，<code>?</code> 运算符的行为与其在 <code>Result&lt;T, E&gt;</code> 上调用时的行为类似：如果值是 <code>None</code>，则 <code>None</code> 将在那时从函数中提前返回。如果值是 <code>Some</code>，则 <code>Some</code> 内部的值是表达式的结果值，并且函数继续。</p>
<h3 id="总结-4"><a class="header" href="#总结-4">总结</a></h3>
<p>我们看到可以使用 <code>Result</code> 枚举在 Cairo 中处理可恢复错误，该枚举有两个变体：<code>Ok</code> 和 <code>Err</code>。<code>Result&lt;T, E&gt;</code> 枚举是泛型的，类型 <code>T</code> 和 <code>E</code> 分别代表成功和错误值。<code>ResultTrait</code> 提供了用于处理 <code>Result&lt;T, E&gt;</code> 的方法，例如解包值、检查结果是 <code>Ok</code> 还是 <code>Err</code> 以及使用自定义消息 panic。</p>
<p>为了处理可恢复错误，函数可以返回 <code>Result</code> 类型并使用模式匹配来处理操作的成功或失败。<code>?</code> 运算符可用于通过传播错误或解包成功值来隐式处理错误。这允许更简洁和清晰的错误处理，其中调用者负责管理被调用函数引发的错误。</p>
<p>{{#quiz ../quizzes/ch09-02-error-handling-result.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="测试-cairo-程序"><a class="header" href="#测试-cairo-程序">测试 Cairo 程序</a></h1>
<p>程序的正确性是指代码按预期执行的程度。Cairo 在设计时就高度关注程序的正确性，但正确性是一个复杂且难以证明的问题。Cairo 的线性类型系统承担了这一重担的很大一部分，但类型系统无法捕获所有错误。因此，Cairo 包含了对编写测试的支持。</p>
<p>测试是一项复杂的技能：虽然我们无法在一章中涵盖有关如何编写良好测试的所有细节，但我们将讨论 Cairo 测试机制。我们将讨论编写测试时可用的注释和宏、运行测试时提供的默认行为和选项，以及如何将测试组织成单元测试和集成测试。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="如何编写测试"><a class="header" href="#如何编写测试">如何编写测试</a></h1>
<h2 id="测试函数的解剖结构"><a class="header" href="#测试函数的解剖结构">测试函数的解剖结构</a></h2>
<p>测试是 Cairo 函数，用于验证非测试代码是否按预期方式运行。测试函数的主体通常执行以下三个操作：</p>
<ul>
<li>设置任何所需的数据或状态。</li>
<li>运行你想要测试的代码。</li>
<li>断言结果是否符合你的预期。</li>
</ul>
<p>让我们看看 Cairo 提供的用于编写执行这些操作的测试的功能，其中包括：</p>
<ul>
<li><code>#[test]</code> 属性。</li>
<li><code>assert!</code> 宏。</li>
<li><code>assert_eq!</code>, <code>assert_ne!</code>, <code>assert_lt!</code>, <code>assert_le!</code>, <code>assert_gt!</code> 和 <code>assert_ge!</code> 宏。为了使用它们，如果你使用的是旧版本，可能需要添加 <code>assert_macros</code> 依赖，但在最新版本中通常已包含（注：原文提到 dev dependency，视具体 Scarb 版本而定）。</li>
<li><code>#[should_panic]</code> 属性。</li>
</ul>
<blockquote>
<p>注意：确在创建项目时选择 Starknet Foundry 作为测试运行器。</p>
</blockquote>
<h3 id="测试函数的解剖结构-1"><a class="header" href="#测试函数的解剖结构-1">测试函数的解剖结构</a></h3>
<p>最简单地说，Cairo 中的测试是一个带有 <code>#[test]</code> 属性注释的函数。属性是关于 Cairo 代码片段的元数据；一个例子是我们在 <a href="#定义并实例化结构体">第 {{#chap using-structs-to-structure-related-data}} 章</a> 中对结构体使用的 <code>#[derive()]</code> 属性。要将函数更改为测试函数，请在 <code>fn</code> 之前的一行添加 <code>#[test]</code>。当你使用 <code>scarb test</code> 命令运行测试时，Scarb 会运行 Starknet Foundry 的测试运行器二进制文件，该文件运行带注释的函数并报告每个测试函数是通过还是失败。</p>
<p>让我们使用 Scarb 创建一个名为 <em>adder</em> 的新项目，命令为 <code>scarb new adder</code>。删除 <em>tests</em> 文件夹。</p>
<pre><code class="language-shell">adder
├── Scarb.toml
└── src
    └── lib.cairo
</code></pre>
<p>在 <em>lib.cairo</em> 中，让我们删除现有内容并添加一个包含第一个测试的 <code>tests</code> 模块，如清单 {{#ref first-test}} 所示。</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo noplayground">pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}
</code></pre>
<p>{{#label first-test}} <span class="caption">清单 {{#ref first-test}}: 一个简单的测试函数</span></p>
<p>注意 <code>#[test]</code> 注释：此属性指示这是一个测试函数，因此测试运行器知道将此函数视为测试。我们可能还有非测试函数来帮助设置常见场景或执行常见操作，因此我们总是需要指明哪些函数是测试。</p>
<p>我们需要对 <code>tests</code> 模块使用 <code>#[cfg(test)]</code> 属性，以便编译器知道它包含的代码只需在运行测试时编译。这实际上不是一个选项：如果你在 <em>lib.cairo</em> 文件中放置一个带有 <code>#[test]</code> 属性的简单测试，它将不会编译。我们将在下一节 <a href="#测试组织">测试组织</a> 中更多地讨论 <code>#[cfg(test)]</code> 属性。</p>
<p>示例函数体使用了 <code>assert_eq!</code> 宏，它断言 2 加 2 的结果等于 4。此断言用作典型测试格式的示例。我们稍后将在本章中更详细地解释 <code>assert_eq!</code> 的工作原理。让我们运行它看看这个测试是否通过。</p>
<p><code>scarb test</code> 命令运行在我们的项目中找到的所有测试，并显示以下输出：</p>
<pre><code class="language-shell">$ scarb test 
     Running test listing_10_01 (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listing_10_01_unittest) listing_10_01 v0.1.0 (listings/ch10-testing-cairo-programs/listing_10_01/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 2 test(s) from listing_10_01 package
Running 2 test(s) from src/
[PASS] listing_10_01::other_tests::exploration (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
[PASS] listing_10_01::tests::it_works (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 2 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p><code>scarb test</code> 编译并运行了测试。我们看到行 <code>Collected 1 test(s) from adder package</code> 后面是行 <code>Running 1 test(s) from src/</code>。下一行显示了称为 <code>it_works</code> 的测试函数的名称，并且该测试的运行结果是 <code>ok</code>。测试运行器还提供了 Gas 消耗的估算。总体摘要显示所有测试都已通过，<code>1 passed; 0 failed</code> 部分统计了通过或失败的测试数量。</p>
<p>可以将测试标记为忽略，以便它不会在特定实例中运行；我们将在本章稍后的 <a href="#ignoring-some-tests-unless-specifically-requested">除非特别请求，否则忽略某些测试</a> 部分中介绍这一点。因为我们在这里没有这样做，所以摘要显示 <code>0 ignored</code>。我们还可以向 <code>scarb test</code> 命令传递参数，以仅运行名称与字符串匹配的测试；这称为过滤，我们将在 <a href="#running-single-tests">运行单个测试</a> 部分中介绍这一点。由于我们没有过滤正在运行的测试，因此摘要末尾显示 <code>0 filtered out</code>。</p>
<p>让我们开始根据我们自己的需求自定义测试。首先将 <code>it_works</code> 函数的名称更改为不同的名称，例如 <code>exploration</code>，如下所示：</p>
<pre><code class="language-cairo noplayground">    #[test]
    fn exploration() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
</code></pre>
<p>然后再次运行 <code>scarb test</code>。现在的输出显示 <code>exploration</code> 而不是 <code>it_works</code>：</p>
<pre><code class="language-shell">$ scarb test 
     Running test listing_10_01 (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listing_10_01_unittest) listing_10_01 v0.1.0 (listings/ch10-testing-cairo-programs/listing_10_01/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 2 test(s) from listing_10_01 package
Running 2 test(s) from src/
[PASS] listing_10_01::other_tests::exploration (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
[PASS] listing_10_01::tests::it_works (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 2 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p>现在我们将添加另一个测试，但这次我们将制作一个失败的测试！当测试函数中的某些内容 panic 时，测试失败。每个测试都在新线程中运行，当主线程看到测试线程已死亡时，测试被标记为失败。输入名为 <code>another</code> 的新测试作为函数，以便你的 <em>src/lib.cairo</em> 文件看起来像清单 {{#ref second-test}} 中那样。</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }

    #[test]
    fn another() {
        let result = 2 + 2;
        assert!(result == 6, "Make this test fail");
    }
}
</code></pre>
<p>{{#label second-test}} <span class="caption">清单 {{#ref second-test}}:
在 <em>lib.cairo</em> 中添加第二个将失败的测试</span></p>
<p>运行 <code>scarb test</code>，你将看到以下输出：</p>
<pre><code class="language-shell">Collected 2 test(s) from adder package
Running 2 test(s) from src/
[FAIL] adder::tests::another

Failure data:
    "Make this test fail"

[PASS] adder::tests::exploration (gas: ~1)
Tests: 1 passed, 1 failed, 0 skipped, 0 ignored, 0 filtered out

Failures:
    adder::tests::another
</code></pre>
<p><code>adder::tests::another</code> 行显示的不是 <code>[PASS]</code>，而是 <code>[FAIL]</code>。一个新的部分出现在单个结果和摘要之间。它显示了每个测试失败的详细原因。在这种情况下，我们得到的细节是 <code>another</code> 失败了，因为它使用 <code>"Make this test fail"</code> 错误 panic 了。</p>
<p>之后，显示摘要行：我们有一个测试通过，一个测试失败。最后，我们看到失败测试的列表。</p>
<p>现在你已经看到了测试结果在不同场景下的样子，让我们看看一些在测试中有用的函数。</p>
<h2 id="使用-assert-宏检查结果"><a class="header" href="#使用-assert-宏检查结果">使用 <code>assert!</code> 宏检查结果</a></h2>
<p>Cairo 提供的 <code>assert!</code> 宏在你想要确保测试中的某些条件评估为 <code>true</code> 时很有用。我们给 <code>assert!</code> 宏的第一个参数评估为布尔值。如果值为 <code>true</code>，则不发生任何事情，测试通过。如果值为 <code>false</code>，则 <code>assert!</code> 宏调用 <code>panic()</code> 导致测试失败，并带有我们定义为第二个参数的消息。使用 <code>assert!</code> 宏有助于我们检查代码是否按我们预期的方式运行。</p>
<p>还记得在 <a href="#方法语法">第 {{#chap using-structs-to-structure-related-data}} 章</a> 中，我们使用了 <code>Rectangle</code> 结构体和 <code>can_hold</code> 方法，这里在清单 {{#ref rectangle}} 中重复。让我们将此代码放在 <em>src/lib.cairo</em> 文件中，然后使用 <code>assert!</code> 宏为它编写一些测试。</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo noplayground">#[derive(Drop)]
struct Rectangle {
    width: u64,
    height: u64,
}

trait RectangleTrait {
    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool;
}

impl RectangleImpl of RectangleTrait {
    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool {
        *self.width &gt; *other.width &amp;&amp; *self.height &gt; *other.height
    }
}
</code></pre>
<p>{{#label rectangle}} <span class="caption">清单 {{#ref rectangle}}: 使用 <a href="#定义并实例化结构体">第 {{#chap using-structs-to-structure-related-data}} 章</a> 中的 <code>Rectangle</code> 结构体及其 <code>can_hold</code> 方法</span></p>
<p><code>can_hold</code> 方法返回一个 <code>bool</code>，这意味着它是 <code>assert!</code> 宏的完美用例。我们可以通过创建一个宽度为 <code>8</code> 高度为 <code>7</code> 的 <code>Rectangle</code> 实例，并断言它可以容纳另一个宽度为 <code>5</code> 高度为 <code>1</code> 的 <code>Rectangle</code> 实例来编写一个测试来练习 <code>can_hold</code> 方法。</p>
<pre><code class="language-cairo noplayground">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle { height: 7, width: 8 };
        let smaller = Rectangle { height: 1, width: 5 };

        assert!(larger.can_hold(@smaller), "rectangle cannot hold");
    }
}
</code></pre>
<p>注意 <code>tests</code> 模块内的 <code>use super::*;</code> 行。<code>tests</code> 模块是一个常规模块，它遵循我们在第 {{#chap paths-for-referring-to-an-item-in-the-module-tree}} 章的 <a href="#引用模块树中项的路径">“引用模块树中项目的路径”</a><!-- ignore --> 部分中介绍的常规可见性规则。因为 <code>tests</code> 模块是一个内部模块，我们需要将外部模块中的待测试代码引入内部模块的范围。我们在这里使用了一个 glob，所以我们在外部模块中定义的任何东西都对此 <code>tests</code> 模块可用。</p>
<p>如果你没有将测试模块命名为 <code>tests</code>，你可能不需要 <code>use super::*;</code>，但这取决于你的模块结构。</p>
<p>我们将测试命名为 <code>larger_can_hold_smaller</code>，并创建了我们需要的两个 <code>Rectangle</code> 实例。然后我们调用 <code>assert!</code> 宏并传递调用 <code>larger.can_hold(@smaller)</code> 的结果。此表达式应该返回 <code>true</code>，所以我们的测试应该通过。让我们来看看！</p>
<pre><code class="language-shell">$ scarb test 
     Running test listing_10_03 (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listing_10_03_unittest) listing_10_03 v0.1.0 (listings/ch10-testing-cairo-programs/listing_10_03/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 2 test(s) from listing_10_03 package
Running 2 test(s) from src/
[PASS] listing_10_03::tests2::smaller_cannot_hold_larger (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
[PASS] listing_10_03::tests::larger_can_hold_smaller (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 2 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p>它确实通过了！让我们添加另一个测试，这次断言一个较小的矩形不能容纳一个较大的矩形：</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo noplayground">    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle { height: 7, width: 8 };
        let smaller = Rectangle { height: 1, width: 5 };

        assert!(!smaller.can_hold(@larger), "rectangle cannot hold");
    }
</code></pre>
<p>{{#label another-test}} <span class="caption">清单 {{#ref another-test}}:
在 <em>lib.cairo</em> 中添加另一个将通过的测试</span></p>
<p>因为在这种情况下 <code>can_hold</code> 方法的正确结果是 <code>false</code>，我们需要在将其传递给 <code>assert!</code> 宏之前否定该结果。因此，如果 <code>can_hold</code> 返回 <code>false</code>，我们的测试将通过：</p>
<pre><code class="language-shell">$ scarb test 
     Running test listing_10_03 (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listing_10_03_unittest) listing_10_03 v0.1.0 (listings/ch10-testing-cairo-programs/listing_10_03/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 2 test(s) from listing_10_03 package
Running 2 test(s) from src/
[PASS] listing_10_03::tests2::smaller_cannot_hold_larger (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
[PASS] listing_10_03::tests::larger_can_hold_smaller (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 2 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p>两个测试都通过了！现在让我们看看当我们在代码中引入错误时，我们的测试记过会发生什么。我们将通过在比较宽度时将 <code>&gt;</code> 符号替换为 <code>&lt;</code> 符号来更改 <code>can_hold</code> 方法的实现：</p>
<pre><code class="language-cairo noplayground">impl RectangleImpl of RectangleTrait {
    fn can_hold(self: @Rectangle, other: @Rectangle) -&gt; bool {
        *self.width &lt; *other.width &amp;&amp; *self.height &gt; *other.height
    }
}
</code></pre>
<p>现在运行测试会产生以下结果：</p>
<pre><code class="language-shell">$ scarb test 
     Running test no_listing_01_wrong_can_hold_impl (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(no_listing_01_wrong_can_hold_impl_unittest) no_listing_01_wrong_can_hold_impl v0.1.0 (listings/ch10-testing-cairo-programs/no_listing_01_wrong_can_hold_impl/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 2 test(s) from no_listing_01_wrong_can_hold_impl package
Running 2 test(s) from src/
[FAIL] no_listing_01_wrong_can_hold_impl::tests::larger_can_hold_smaller

Failure data:
    "rectangle cannot hold"

[PASS] no_listing_01_wrong_can_hold_impl::tests2::smaller_cannot_hold_larger (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 1 passed, 1 failed, 0 ignored, 0 filtered out

Failures:
    no_listing_01_wrong_can_hold_impl::tests::larger_can_hold_smaller

</code></pre>
<p>我们的测试捕获了错误！因为 <code>larger.width</code> 是 <code>8</code> 且 <code>smaller.width</code> 是 <code>5</code>，在 <code>larger_can_hold_smaller</code> 测试中，<code>can_hold</code> 中的宽度比较现在返回 <code>false</code>（<code>8</code> 不小于 <code>5</code>）。注意 <code>smaller_cannot_hold_larger</code> 测试仍然通过：要使此测试失败，高度比较也应该在 <code>can_hold</code> 方法中修改，将 <code>&gt;</code> 符号替换为 <code>&lt;</code> 符号。</p>
<h2 id="使用-assert_xx-宏测试相等性和比较"><a class="header" href="#使用-assert_xx-宏测试相等性和比较">使用 <code>assert_xx!</code> 宏测试相等性和比较</a></h2>
<h3 id="assert_eq-和-assert_ne-宏"><a class="header" href="#assert_eq-和-assert_ne-宏"><code>assert_eq!</code> 和 <code>assert_ne!</code> 宏</a></h3>
<p>验证功能的常用方法是测试被测代码的结果与你期望代码返回的值之间的相等性。你可以使用 <code>assert!</code> 宏并传递一个使用 <code>==</code> 运算符的表达式来做到这一点。然而，这是一个如此常见的测试，以至于标准库提供了一对宏 —— <code>assert_eq!</code> 和 <code>assert_ne!</code> —— 以更方便地执行此测试。这些宏分别比较两个参数的相等性或不相等性。如果断言失败，它们还会打印这两个值，这使得更容易看出 <em>为什么</em> 测试失败；相反，<code>assert!</code> 宏仅指示它得到了 <code>==</code> 表达式的 <code>false</code> 值，而不打印导致 <code>false</code> 值的值。</p>
<p>在清单 {{#ref add_two}} 中，我们编写了一个名为 <code>add_two</code> 的函数，它将 <code>2</code> 添加到其参数，然后我们使用 <code>assert_eq!</code> 和 <code>assert_ne!</code> 宏测试此函数。</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo noplayground">pub fn add_two(a: u32) -&gt; u32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn wrong_check() {
        assert_ne!(0, add_two(2));
    }
}
</code></pre>
<p>{{#label add_two}} <span class="caption">清单 {{#ref add_two}}: 使用 <code>assert_eq!</code> 和 <code>assert_ne!</code> 宏测试函数 <code>add_two</code></span></p>
<p>让我们检查它是否通过！</p>
<pre><code class="language-shell">$ scarb test 
     Running test listing_10_04 (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listing_10_04_unittest) listing_10_04 v0.1.0 (listings/ch10-testing-cairo-programs/listing_10_04/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 2 test(s) from listing_10_04 package
Running 2 test(s) from src/
[PASS] listing_10_04::tests::wrong_check (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
[PASS] listing_10_04::tests::it_adds_two (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 2 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p>在 <code>it_adds_two</code> 测试中，我们将 <code>4</code> 作为参数传递给 <code>assert_eq!</code> 宏，它等于调用 <code>add_two(2)</code> 的结果。此测试的行是 <code>[PASS] adder::tests::it_adds_two (gas: ~1)</code>。</p>
<p>在 <code>wrong_check</code> 测试中，我们将 <code>0</code> 作为参数传递给 <code>assert_ne!</code> 宏，它不等于调用 <code>add_two(2)</code> 的结果。如果我们给出的两个值 <em>不</em> 相等，使用 <code>assert_ne!</code> 宏的测试将通过，如果它们相等则失败。当我们不确定值 <em>将</em> 是什么，但我们知道值绝对 <em>不应该</em> 是什么时，此宏最有用。例如，如果我们正在测试一个保证以某种方式更改其输入的函数，但输入的更改方式取决于我们运行测试的星期几，那么最好的断言可能是函数的输出不等于输入。</p>
<p>让我们在代码中引入一个错误，看看 <code>assert_eq!</code> 在失败时是什么样子的。将 <code>add_two</code> 函数的实现更改为加 <code>3</code>：</p>
<pre><code class="language-cairo noplayground">pub fn add_two(a: u32) -&gt; u32 {
    a + 3
}
</code></pre>
<p>再次运行测试：</p>
<pre><code class="language-shell">$ scarb test 
     Running test listing_10_04_wong_add (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listing_10_04_wong_add_unittest) listing_10_04_wong_add v0.1.0 (listings/ch10-testing-cairo-programs/listing_10_04_wong_add/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 1 test(s) from listing_10_04_wong_add package
Running 1 test(s) from src/
[FAIL] listing_10_04_wong_add::tests::it_adds_two

Failure data:
    "assertion `4 == add_two(2)` failed.
    4: 4
    add_two(2): 5"

Tests: 0 passed, 1 failed, 0 ignored, 0 filtered out

Failures:
    listing_10_04_wong_add::tests::it_adds_two

</code></pre>
<p>我们的测试捕获了错误！<code>it_adds_two</code> 测试失败，并显示以下消息：<code>"assertion `4 == add_two(2)` failed</code>。它告诉我们失败的断言是 <code> "assertion `left == right` failed</code>，并且 <code>left</code> 和 <code>right</code> 值打印在下一行，为 <code>left: left_value</code> 和 <code>right: right_value</code>。这有助于我们开始调试：<code>left</code> 参数是 <code>4</code>，但 <code>right</code> 参数（我们有 <code>add_two(2)</code> 的地方）是 <code>5</code>。你可以想象，当我们进行大量测试时，这将特别有帮助。</p>
<p>注意，在某些语言和测试框架中，相等断言函数的参数称为 <code>expected</code> 和 <code>actual</code>，并且我们指定参数的顺序很重要。然而，在 Cairo 中，它们被称为 <code>left</code> 和 <code>right</code>，并且我们指定我们期望的值和代码产生的值的顺序并不重要。我们可以将此测试中的断言写为 <code>assert_eq!(add_two(2), 4)</code>，这将导致显示相同的失败消息 <code>assertion failed: `(left == right)`</code>。</p>
<p>这是一个比较两个结构体的简单示例，展示了如何使用 <code>assert_eq!</code> 和 <code>assert_ne!</code> 宏：</p>
<pre><code class="language-cairo noplayground">#[derive(Drop, Debug, PartialEq)]
struct MyStruct {
    var1: u8,
    var2: u8,
}

#[cfg(test)]
#[test]
fn test_struct_equality() {
    let first = MyStruct { var1: 1, var2: 2 };
    let second = MyStruct { var1: 1, var2: 2 };
    let third = MyStruct { var1: 1, var2: 3 };

    assert_eq!(first, second);
    assert_eq!(first, second, "{:?},{:?} should be equal", first, second);
    assert_ne!(first, third);
    assert_ne!(first, third, "{:?},{:?} should not be equal", first, third);
}
</code></pre>
<p>在表面之下，<code>assert_eq!</code> 和 <code>assert_ne!</code> 宏分别使用运算符 <code>==</code> 和 <code>!=</code>。它们都接受值的快照作为参数。当断言失败时，这些宏使用调试格式化（<code>{:?}</code> 语法）打印它们的参数，这意味着被比较的值必须实现 <code>PartialEq</code> 和 <code>Debug</code> traits。所有原始类型和大多数核心库类型都实现了这些 traits。对于你自己定义的结构体和枚举，你需要实现 <code>PartialEq</code> 来断言那些类型的相等性。你还需要实现 <code>Debug</code> 以在断言失败时打印值。因为这两个 traits 都是可派生的，所以这通常就像将 <code>#[derive(Drop, Debug, PartialEq)]</code> 注释添加到你的结构体或枚举定义一样简单。有关这些和其他可派生 traits 的更多详细信息，请参阅 <a href="#附录-c---可派生-traits">附录 C</a>。</p>
<h3 id="assert_lt-assert_le-assert_gt-和-assert_ge-宏"><a class="header" href="#assert_lt-assert_le-assert_gt-和-assert_ge-宏"><code>assert_lt!</code>, <code>assert_le!</code>, <code>assert_gt!</code> 和 <code>assert_ge!</code> 宏</a></h3>
<p>测试中的比较可以使用 <code>assert_xx!</code> 宏完成：</p>
<ul>
<li><code>assert_lt!</code> 检查给定值是否小于另一个值，否则回滚。</li>
<li><code>assert_le!</code> 检查给定值是否小于或等于另一个值，否则回滚。</li>
<li><code>assert_gt!</code> 检查给定值是否大于另一个值，否则回滚。</li>
<li><code>assert_ge!</code> 检查给定值是否大于或等于另一个值，否则回滚。</li>
</ul>
<p>清单 {{#ref assert_macros}} 演示了如何使用这些宏：</p>
<pre><code class="language-cairo noplayground">#[derive(Drop, Copy, Debug, PartialEq)]
struct Dice {
    number: u8,
}

impl DicePartialOrd of PartialOrd&lt;Dice&gt; {
    fn lt(lhs: Dice, rhs: Dice) -&gt; bool {
        lhs.number &lt; rhs.number
    }

    fn le(lhs: Dice, rhs: Dice) -&gt; bool {
        lhs.number &lt;= rhs.number
    }

    fn gt(lhs: Dice, rhs: Dice) -&gt; bool {
        lhs.number &gt; rhs.number
    }

    fn ge(lhs: Dice, rhs: Dice) -&gt; bool {
        lhs.number &gt;= rhs.number
    }
}

#[cfg(test)]
#[test]
fn test_struct_equality() {
    let first_throw = Dice { number: 5 };
    let second_throw = Dice { number: 2 };
    let third_throw = Dice { number: 6 };
    let fourth_throw = Dice { number: 5 };

    assert_gt!(first_throw, second_throw);
    assert_ge!(first_throw, fourth_throw);
    assert_lt!(second_throw, third_throw);
    assert_le!(
        first_throw, fourth_throw, "{:?},{:?} should be lower or equal", first_throw, fourth_throw,
    );
}
</code></pre>
<p>{{#label assert_macros}} <span class="caption">清单 {{#ref assert_macros}}:
使用 <code>assert_xx!</code> 宏进行比较的测试示例</span></p>
<p>在这个例子中，我们多次掷 <code>Dice</code> 结构体并比较结果。我们需要为我们的结构体手动实现 <code>PartialOrd</code> trait，以便我们可以使用 <code>lt</code>, <code>le</code>, <code>gt</code> 和 <code>ge</code> 函数比较 <code>Dice</code> 实例，这些函数分别被 <code>assert_lt!</code>, <code>assert_le!</code>, <code>assert_gt!</code> 和 <code>assert_ge!</code> 宏使用。我们还需要在我们的 <code>Dice</code> 结构体上派生 <code>Copy</code> trait，以便多次使用实例化的结构体，因为比较函数会获取变量的所有权。</p>
<h2 id="添加自定义失败消息"><a class="header" href="#添加自定义失败消息">添加自定义失败消息</a></h2>
<p>你还可以作为 <code>assert!</code>, <code>assert_eq!</code> 和 <code>assert_ne!</code> 宏的可选参数，添加要与失败消息一起打印的自定义消息。在所需参数之后指定的任何参数都会传递给 <code>format!</code> 宏（在 <a href="#formatting">打印</a> 一章中讨论），因此你可以传递一个包含 <code>{}</code> 占位符的格式字符串以及要放入这些占位符的值。自定义消息对于记录断言的含义很有用；当测试失败时，你将更好地了解代码的问题所在。</p>
<p>让我们添加一个自定义失败消息，该消息由一个格式字符串组成，其中包含一个占位符，该占位符填充了我们从上一个 <code>add_two</code> 函数获得的实际值：</p>
<pre><code class="language-cairo noplayground">    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2), "Expected {}, got add_two(2)={}", 4, add_two(2));
    }
</code></pre>
<p>现在当我们运行测试时，我们将得到更具信息量的错误消息：</p>
<pre><code class="language-shell">$ scarb test 
     Running test no_listing_02_custom_messages (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(no_listing_02_custom_messages_unittest) no_listing_02_custom_messages v0.1.0 (listings/ch10-testing-cairo-programs/no_listing_02_custom_messages/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 1 test(s) from no_listing_02_custom_messages package
Running 1 test(s) from src/
[FAIL] no_listing_02_custom_messages::tests::it_adds_two

Failure data:
    "assertion `4 == add_two(2)` failed: Expected 4, got add_two(2)=5
    4: 4
    add_two(2): 5"

Tests: 0 passed, 1 failed, 0 ignored, 0 filtered out

Failures:
    no_listing_02_custom_messages::tests::it_adds_two

</code></pre>
<p>我们可以在测试输出中看到我们实际得到的值，这将有助于我们调试发生的事情，而不是我们期望发生的事情。</p>
<h2 id="使用-should_panic-检查-panics"><a class="header" href="#使用-should_panic-检查-panics">使用 <code>should_panic</code> 检查 panics</a></h2>
<p>除了检查返回值外，检查我们的代码是否按预期处理错误条件也很重要。例如，考虑清单 {{#ref guess}} 中的 <code>Guess</code> 类型：</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo noplayground">#[derive(Drop)]
struct Guess {
    value: u64,
}

pub trait GuessTrait {
    fn new(value: u64) -&gt; Guess;
}

impl GuessImpl of GuessTrait {
    fn new(value: u64) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!("Guess must be &gt;= 1 and &lt;= 100");
        }

        Guess { value }
    }
}
</code></pre>
<p>{{#label guess}} <span class="caption">清单 {{#ref guess}}: <code>Guess</code> 结构体及其 <code>new</code> 方法</span></p>
<p>其他使用 <code>Guess</code> 的代码依赖于 <code>Guess</code> 实例将仅包含 <code>1</code> 和 <code>100</code> 之间的值这一保证。我们可以编写一个测试，通过调用 <code>Guess::new</code> 来确保尝试创建一个值超出该范围的 <code>Guess</code> 实例会 panic。</p>
<p>我们通过向我们的测试函数添加属性 <code>should_panic</code> 来做到这一点。如果函数内的代码 panic，则测试通过；如果函数内的代码不 panic，则测试失败。</p>
<pre><code class="language-cairo noplayground">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        GuessTrait::new(200);
    }
}
</code></pre>
<p>我们将 <code>#[should_panic]</code> 属性放在 <code>#[test]</code> 属性之后和它应用的测试函数之前。让我们看看结果，看看这个测试是否通过：</p>
<pre><code class="language-shell">$ scarb test 
     Running test listing_09_08 (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listing_09_08_unittest) listing_09_08 v0.1.0 (listings/ch10-testing-cairo-programs/listing_10_05/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 1 test(s) from listing_09_08 package
Running 1 test(s) from src/
[PASS] listing_09_08::tests::greater_than_100 (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 1 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p>看起来不错！现在让我们通过删除 <code>new</code> 函数在值大于 <code>100</code> 时会 panic 的条件，在我们的代码中引入一个错误：</p>
<pre><code class="language-cairo noplayground">impl GuessImpl of GuessTrait {
    fn new(value: u64) -&gt; Guess {
        if value &lt; 1 {
            panic!("Guess must be &gt;= 1 and &lt;= 100");
        }

        Guess { value }
    }
}
</code></pre>
<p>当我们运行测试时，它将失败：</p>
<pre><code class="language-shell">$ scarb test 
     Running test no_listing_03_wrong_new_impl (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(no_listing_03_wrong_new_impl_unittest) no_listing_03_wrong_new_impl v0.1.0 (listings/ch10-testing-cairo-programs/no_listing_03_wrong_new_impl/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 1 test(s) from no_listing_03_wrong_new_impl package
Running 1 test(s) from src/
[FAIL] no_listing_03_wrong_new_impl::tests::greater_than_100

Failure data:
    Expected to panic, but no panic occurred

Tests: 0 passed, 1 failed, 0 ignored, 0 filtered out

Failures:
    no_listing_03_wrong_new_impl::tests::greater_than_100

</code></pre>
<p>在这种情况下，我们没有得到非常有用的消息，但是当我们查看测试函数时，我们看到它用 <code>#[should_panic]</code> 属性进行了注释。我们得到的失败意味着测试函数中的代码没有导致 panic。</p>
<p>使用 <code>should_panic</code> 的测试可能不精确。如果测试由于与我们预期的原因不同的原因而 panic，<code>should_panic</code> 测试也会通过。为了使 <code>should_panic</code> 测试更精确，我们可以向 <code>#[should_panic]</code> 属性添加一个可选的 <code>expected</code> 参数。测试工具将确保失败消息包含提供的文本。例如，考虑清单 {{#ref guess-2}} 中 <code>GuessImpl</code> 的修改后的代码，其中 <code>new</code> 函数根据值是太小还是太大而使用不同的消息 panic：</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo noplayground">impl GuessImpl of GuessTrait {
    fn new(value: u64) -&gt; Guess {
        if value &lt; 1 {
            panic!("Guess must be &gt;= 1");
        } else if value &gt; 100 {
            panic!("Guess must be &lt;= 100");
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected: "Guess must be &lt;= 100")]
    fn greater_than_100() {
        GuessTrait::new(200);
    }
}
</code></pre>
<p>{{#label guess-2}} <span class="caption">清单 {{#ref guess-2}}: <code>new</code>
使用不同错误消息 panic 的实现</span></p>
<p>测试将通过，因为我们在 <code>should_panic</code> 属性的 <code>expected</code> 参数中放置的值是 <code>Guess::new</code> 方法 panic 所用的字符串。我们需要指定我们期望的整个 panic 消息。</p>
<p>为了看看当带有预期消息的 <code>should_panic</code> 测试失败时会发生什么，让我们再次通过交换 <code>if value &lt; 1</code> 和 <code>else if value &gt; 100</code> 块的主体来在我们的代码中引入错误：</p>
<pre><code class="language-cairo noplayground">impl GuessImpl of GuessTrait {
    fn new(value: u64) -&gt; Guess {
        if value &lt; 1 {
            panic!("Guess must be &lt;= 100");
        } else if value &gt; 100 {
            panic!("Guess must be &gt;= 1");
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected: "Guess must be &lt;= 100")]
    fn greater_than_100() {
        GuessTrait::new(200);
    }
}
</code></pre>
<p>这次当我们运行 <code>should_panic</code> 测试时，它将失败：</p>
<pre><code class="language-shell">$ scarb test 
     Running test no_listing_04_new_bug (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(no_listing_04_new_bug_unittest) no_listing_04_new_bug v0.1.0 (listings/ch10-testing-cairo-programs/no_listing_04_new_bug/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 1 test(s) from no_listing_04_new_bug package
Running 1 test(s) from src/
[FAIL] no_listing_04_new_bug::tests::greater_than_100

Failure data:
    Incorrect panic data
    Actual:    [0x46a6158a16a947e5916b2a2ca68501a45e93d7110e81aa2d6438b1c57c879a3, 0x0, 0x4775657373206d757374206265203e3d2031, 0x12] (Guess must be &gt;= 1)
    Expected:  [0x46a6158a16a947e5916b2a2ca68501a45e93d7110e81aa2d6438b1c57c879a3, 0x0, 0x4775657373206d757374206265203c3d20313030, 0x14] (Guess must be &lt;= 100)

Tests: 0 passed, 1 failed, 0 ignored, 0 filtered out

Failures:
    no_listing_04_new_bug::tests::greater_than_100

</code></pre>
<p>失败消息表明此测试确实如我们预期的那样 panic 了，但 panic 消息不包含预期的字符串。我们在这种情况下得到的 panic 消息是 <code>Guess must be &gt;= 1</code>。现在我们可以开始找出我们的错误在哪里了！</p>
<h2 id="运行单个测试"><a class="header" href="#运行单个测试">运行单个测试</a></h2>
<p>有时，运行完整的测试套件可能需要很长时间。如果你正在处理特定区域的代码，你可能只想运行属于该代码的测试。你可以通过将你想运行的测试的名称作为参数传递给 <code>scarb test</code> 来选择要运行的测试。</p>
<p>为了演示如何运行单个测试，我们将首先创建两个测试函数，如清单 {{#ref two-tests}} 所示，并选择要运行的测试。</p>
<p><span class="filename">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn add_two_and_two() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }

    #[test]
    fn add_three_and_two() {
        let result = 3 + 2;
        assert!(result == 5, "result is not 5");
    }
}
</code></pre>
<p>{{#label two-tests}} <span class="caption">清单 {{#ref two-tests}}: 两个具有不同名称的测试</span></p>
<p>我们可以将任何测试函数的名称传递给 <code>scarb test</code> 以仅运行该测试：</p>
<pre><code class="language-shell">$ scarb test add_two_and_two
     Running test listing_10_07 (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listing_10_07_unittest) listing_10_07 v0.1.0 (listings/ch10-testing-cairo-programs/listing_10_07/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 1 test(s) from listing_10_07 package
Running 1 test(s) from src/
[PASS] listing_10_07::tests::add_two_and_two (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 1 passed, 0 failed, 0 ignored, 1 filtered out


</code></pre>
<p>只有名为 <code>add_two_and_two</code> 的测试运行了；另一个测试不匹配该名称。测试输出让我们知道我们还有一个未运行的测试，在末尾显示 <code>1 filtered out;</code>。</p>
<p>我们还可以指定测试名称的一部分，任何名称包含该值的测试都将运行。</p>
<h2 id="除非特别请求否则忽略某些测试"><a class="header" href="#除非特别请求否则忽略某些测试">除非特别请求，否则忽略某些测试</a></h2>
<p>有时一些特定的测试执行起来非常耗时，因此你可能希望在大多数 <code>scarb test</code> 运行期间排除它们。除了将所有你想要运行的测试列为参数外，你还可以使用 <code>#[ignore]</code> 属性注释耗时的测试以排除它们，如下所示：</p>
<pre><code class="language-cairo noplayground">pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }

    #[test]
    #[ignore]
    fn expensive_test() { // code that takes an hour to run
    }
}
</code></pre>
<p>在 <code>#[test]</code> 之后，我们将 <code>#[ignore]</code> 行添加到我们想要排除的测试中。现在当我们运行测试时，<code>it_works</code> 运行，但 <code>expensive_test</code> 不运行：</p>
<pre><code class="language-shell">$ scarb test 
     Running test no_listing_05_ignore_tests (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(no_listing_05_ignore_tests_unittest) no_listing_05_ignore_tests v0.1.0 (listings/ch10-testing-cairo-programs/no_listing_05_ignore_tests/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 2 test(s) from no_listing_05_ignore_tests package
Running 2 test(s) from src/
[IGNORE] no_listing_05_ignore_tests::tests::expensive_test
[PASS] no_listing_05_ignore_tests::tests::it_works (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 1 passed, 0 failed, 1 ignored, 0 filtered out


</code></pre>
<p><code>expensive_test</code> 函数被列为已忽略。</p>
<p>当你只想检查被忽略测试的结果并且有时间等待结果时，你可以运行 <code>scarb test --include-ignored</code> 来运行所有测试，无论它们是否被忽略。</p>
<h2 id="测试递归函数或循环"><a class="header" href="#测试递归函数或循环">测试递归函数或循环</a></h2>
<p>在测试递归函数或循环时，测试默认使用它可以消耗的最大 Gas 量实例化。这可以防止运行无限循环或消耗过多的 Gas，并可以帮助你对实现的效率进行基准测试。假设这个值足够大，但你可以通过向测试函数添加 <code>#[available_gas(&lt;Number&gt;)]</code> 属性来覆盖它。以下示例显示了如何使用它：</p>
<pre><code class="language-cairo noplayground">fn sum_n(n: usize) -&gt; usize {
    let mut i = 0;
    let mut sum = 0;
    while i &lt;= n {
        sum += i;
        i += 1;
    }
    sum
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[available_gas(l2_gas: 2000000)]
    fn test_sum_n() {
        let result = sum_n(10);
        assert!(result == 55, "result is not 55");
    }
}
</code></pre>
<h2 id="对-cairo-程序进行基准测试"><a class="header" href="#对-cairo-程序进行基准测试">对 Cairo 程序进行基准测试</a></h2>
<p>Starknet Foundry 包含一个性能分析功能，可用于分析和优化 Cairo 程序的性能。</p>
<p><a href="https://foundry-rs.github.io/starknet-foundry/snforge-advanced-features/profiling.html">profiling</a> 功能为成功的测试生成执行跟踪，用于创建配置文件输出。这允许你对代码的特定部分进行基准测试。</p>
<p>要使用分析器，你需要：</p>
<ol>
<li>从 Software Mansion 安装 <a href="https://github.com/software-mansion/cairo-profiler">Cairo Profiler</a>。</li>
<li>安装 <a href="https://go.dev/doc/install">Go</a>, <a href="https://www.graphviz.org/download/">Graphviz</a> 和 <a href="https://github.com/google/pprof?tab=readme-ov-file#building-pprof">pprof</a>，它们都需要用来可视化生成的配置文件输出。</li>
<li>运行 <code>snforge test --build-profile</code> 命令，该命令为每个通过的测试生成一个跟踪文件，存储在你项目的 <em>snfoundry_trace</em> 目录中。此命令还在 <em>profile</em> 目录中生成相应的输出文件。</li>
<li>运行 <code>go tool pprof -http=":8000" path/to/profile/output.pb.gz</code> 来分析配置文件。这将在指定端口启动 Web 服务器。</li>
</ol>
<p>让我们重用上面研究的 <code>sum_n</code> 函数：</p>
<pre><code class="language-cairo noplayground">fn sum_n(n: usize) -&gt; usize {
    let mut i = 0;
    let mut sum = 0;
    while i &lt;= n {
        sum += i;
        i += 1;
    }
    sum
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[available_gas(l2_gas: 2000000)]
    fn test_sum_n() {
        let result = sum_n(10);
        assert!(result == 55, "result is not 55");
    }
}
</code></pre>
<p>在生成跟踪文件和配置文件输出后，在你的项目中运行 <code>go tool pprof</code> 将启动 Web 服务器，你可以在其中找到有关你运行的测试的许多有用信息：</p>
<ul>
<li>
<p>测试包括一个函数调用，对应于对测试函数的调用。在测试函数中多次调用 <code>sum_n</code> 仍将返回 1 次调用。这是因为 <code>snforge</code> 在执行测试时模拟合约调用。</p>
</li>
<li>
<p><code>sum_n</code> 函数执行使用 256 个 Cairo 步骤：</p>
</li>
</ul>
<div align="center">
    <img src="pprof-steps.png" alt="pprof number of steps" width="800px" />
</div>

<p>其他信息也可用，例如内存空洞（即未使用的内存单元）或内置函数的使用。Cairo Profiler 正在积极开发中，未来将提供许多其他功能。</p>
<p>{{#quiz ../quizzes/ch10-01-how_to_write_tests.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="测试组织"><a class="header" href="#测试组织">测试组织</a></h1>
<p>我们将从两个主要类别来考虑测试：单元测试和集成测试。单元测试很小且更专注，一次独立测试一个模块，并且可以测试私有函数。集成测试以与其他外部代码相同的方式使用你的代码，仅使用公共接口，并且每个测试可能练习多个模块。</p>
<p>编写这两种测试对于确保你的库的各个部分分别和一起按预期工作都很重要。</p>
<h2 id="单元测试"><a class="header" href="#单元测试">单元测试</a></h2>
<p>单元测试的目的是将每个代码单元与其余代码隔离进行测试，以快速查明代码在何处按预期工作，在何处不工作。你会将单元测试放在每个文件的 <code>src</code> 目录中，与它们正在测试的代码在一起。</p>
<p>惯例是在每个文件中创建一个名为 <code>tests</code> 的模块以包含测试函数，并使用 <code>#[cfg(test)]</code> 属性注释该模块。</p>
<h3 id="测试模块和-cfgtest"><a class="header" href="#测试模块和-cfgtest">测试模块和 <code>#[cfg(test)]</code></a></h3>
<p>测试模块上的 <code>#[cfg(test)]</code> 注释告诉 Cairo 仅在运行 <code>scarb test</code> 时编译和运行测试代码，而不是在运行 <code>scarb build</code> 时。当你只想构建项目时，这可以节省编译时间，并节省生成的已编译工件中的空间，因为测试不包含在内。你会看到，因为集成测试在不同的目录中，它们不需要 <code>#[cfg(test)]</code> 注释。但是，因为单元测试与代码位于相同的文件中，你将使用 <code>#[cfg(test)]</code> 来指定它们不应包含在已编译的结果中。</p>
<p>回想一下，当我们于本章第一节创建新的 <code>adder</code> 项目时，我们编写了这第一个测试：</p>
<pre><code class="language-cairo">pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}
</code></pre>
<p>属性 <code>cfg</code> 代表 <em>配置 (configuration)</em> ，并告诉 Cairo 只有在给定的配置选项下才应包含以下项目。在这种情况下，配置选项是 <code>test</code>，这是 Cairo 用于编译和运行测试的。通过使用 <code>cfg</code> 属性，只有当我们使用 <code>scarb test</code> 积极运行测试时，Cairo 才会编译我们的测试代码。这包括可能在此模块内的任何辅助函数，以及用 <code>#[test]</code> 注释的函数。</p>
<h3 id="测试私有函数"><a class="header" href="#测试私有函数">测试私有函数</a></h3>
<p>测试社区内关于是否应该直接测试私有函数存在争议，其他语言使得测试私有函数变得困难或不可能。无论你坚持哪种测试意识形态，Cairo 的隐私规则确实允许你测试私有函数。
考虑下面带有私有函数 <code>internal_adder</code> 的代码。</p>
<p><span class="caption">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo noplayground">pub fn add(a: u32, b: u32) -&gt; u32 {
    internal_adder(a, 2)
}

fn internal_adder(a: u32, b: u32) -&gt; u32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
</code></pre>
<p>{{#label test_internal}} <span class="caption">清单 {{#ref test_internal}}:
测试私有函数</span></p>
<p>注意 <code>internal_adder</code> 函数没有被标记为 <code>pub</code>。测试只是 Cairo 代码，测试模块只是另一个模块。正如我们在 <a href="#引用模块树中项的路径">“引用模块树中项目的路径”</a> 部分中讨论的那样，子模块中的项目可以使用其祖先模块中的项目。在这个测试中，我们将 <code>tests</code> 模块的父级 <code>internal_adder</code> 引入范围 <code>use super::internal_adder;</code>，然后测试可以调用 <code>internal_adder</code>。如果你不认为应该测试私有函数，Cairo 中没有任何东西会强迫你这样做。</p>
<h2 id="集成测试"><a class="header" href="#集成测试">集成测试</a></h2>
<p>集成测试以与其他代码相同的方式使用你的库。它们的目的是测试你的库的许多部分是否可以正确地协同工作。单独工作正常的代码单元在集成时可能会出现问题，因此集成代码的测试覆盖率也很重要。要创建集成测试，你首先需要一个 <em>tests</em> 目录。</p>
<h3 id="tests-目录"><a class="header" href="#tests-目录"><em>tests</em> 目录</a></h3>
<p>我们在项目目录的顶层创建一个 <em>tests</em> 目录，在 <em>src</em> 旁边。Scarb 知道要在此目录中查找集成测试文件。然后我们可以制作任意数量的测试文件，Scarb 将把每个文件编译为一个单独的 crate。</p>
<p>让我们创建一个集成测试。在 <em>src/lib.cairo</em> 文件中仍然保留清单 {{#ref test_internal}} 中的代码的情况下，创建一个 <em>tests</em> 目录，并创建一个名为 <em>tests/integration_test.cairo</em> 的新文件。你的目录结构应如下所示：</p>
<pre><code class="language-shell">adder
├── Scarb.lock
├── Scarb.toml
├── src
│   └── lib.cairo
└── tests
    └── integration_tests.cairo

</code></pre>
<p>将清单 {{#ref test_integration}} 中的代码输入到 <em>tests/integration_test.cairo</em> 文件中：</p>
<p><span class="caption">文件名: tests/integration_tests.cairo</span></p>
<pre><code class="language-cairo noplayground">use adder::add_two;

#[test]
fn it_adds_two() {
    assert_eq!(4, add_two(2));
}
</code></pre>
<p>{{#label test_integration}} <span class="caption">清单
{{#ref test_integration}}: <code>adder</code> crate 中函数的一个集成测试</span></p>
<p><code>tests</code> 目录中的每个文件都是一个单独的 crate，因此我们需要将我们的库引入每个测试 crate 的范围。因为这个原因，我们在代码顶部添加 <code>use adder::add_two</code>，我们在单元测试中不需要这样做。</p>
<p>我们不需要用 <code>#[cfg(test)]</code> 注释 <em>tests/integration_test.cairo</em> 中的任何代码。Scarb 会特殊对待 tests 目录，并且仅在我们运行 <code>scarb test</code> 时才编译此目录中的文件。现在运行 <code>scarb test</code>：</p>
<pre><code class="language-shell">$ scarb test 
     Running test adder (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(adder_unittest) adder v0.1.0 (listings/ch10-testing-cairo-programs/no_listing_09_integration_test/Scarb.toml)
   Compiling test(adder_integrationtest) adder_integrationtest v0.1.0 (listings/ch10-testing-cairo-programs/no_listing_09_integration_test/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 2 test(s) from adder package
Running 1 test(s) from tests/
[PASS] adder_integrationtest::integration_tests::it_adds_two (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Running 1 test(s) from src/
[PASS] adder::tests::internal (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 2 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p>输出的两个部分包括单元测试和集成测试。注意，如果某个部分中的任何测试失败，则不会运行后续部分。例如，如果单元测试失败，则通过不会有集成测试的任何输出，因为只有在所有单元测试都通过的情况下才会运行这些测试。</p>
<p>显示的第一个部分是针对集成测试的。每个集成测试文件都有自己的部分，因此如果我们在 <em>tests</em> 目录中添加更多文件，就会有更多集成测试部分。</p>
<p>显示的第二部分与我们可以看到的一样：每个单元测试一行（我们刚刚在上面添加的名叫 add 的那个），然后是单元测试的摘要行。</p>
<p>我们仍然可以通过将测试函数的名称作为 <code>scarb test</code> 的 <code>-f</code> 选项的参数来运行特定的集成测试函数，例如 <code>scarb test -f integration_tests::internal</code>。要运行特定集成测试文件中的所有测试，我们使用相同的 <code>scarb test</code> 选项，但仅使用文件名。</p>
<p>然后，要运行我们所有的集成测试，我们可以只添加一个过滤器来仅运行路径包含 <em>integration_tests</em> 的测试。</p>
<pre><code class="language-shell">$ scarb test -f integration_tests
     Running test adder (snforge test)

</code></pre>
<p>我们看到在单元测试的第二部分中，有 1 个被过滤掉了，因为它不在 <em>integration_tests</em> 文件中。</p>
<h3 id="集成测试中的子模块"><a class="header" href="#集成测试中的子模块">集成测试中的子模块</a></h3>
<p>当你添加更多集成测试时，你可能希望在 <em>tests</em> 目录中制作更多文件以帮助组织它们；例如，你可以按它们测试的功能对测试函数进行分组。如前所述，tests 目录中的每个文件都被编译为自己的单独 crate，这对于创建单独的范围以更紧密地模仿最终用户使用你的 crate 的方式很有用。然而，这意味着 tests 目录中的文件不像 <em>src</em> 中的文件那样共享相同的行为，正如你在第 {{#chap packages-and-crates}} 章中关于如何将代码分离到模块和文件中所学到的那样。</p>
<p>当你有一组要在多个集成测试文件中使用的辅助函数，并尝试遵循第 {{#chap packages-and-crates}} 章的 <a href="#将模块分离到不同文件">将模块分离到不同文件</a> 部分中的步骤将它们提取到一个通用模块时，测试目录文件的不同行为最为明显。例如，如果我们创建 <em>tests/common.cairo</em> 并在其中放置一个名为 <code>setup</code> 的函数，我们可以向 <code>setup</code> 添加一些代码，我们希望从多个测试文件中的多个测试函数调用这些代码：</p>
<p><span class="caption">文件名: tests/common.cairo</span></p>
<pre><code class="language-cairo noplayground">pub fn setup() {
    println!("Setting up tests...");
}
</code></pre>
<p><span class="caption">文件名: tests/integration_tests.cairo</span></p>
<pre><code class="language-cairo noplayground">use adder::it_adds_two;

#[test]
fn internal() {
    assert!(it_adds_two(2, 2) == 4, "internal_adder failed");
}
</code></pre>
<p><span class="caption">文件名: src/lib.cairo</span></p>
<pre><code class="language-cairo noplayground">pub fn it_adds_two(a: u8, b: u8) -&gt; u8 {
    a + b
}

#[cfg(test)]
mod tests {
    #[test]
    fn add() {
        assert_eq!(4, super::it_adds_two(2, 2));
    }
}
</code></pre>
<p>当我们使用 <code>scarb test</code> 运行测试时，我们将在测试输出中看到 <em>common.cairo</em> 文件的一个新部分，即使此文件不包含任何测试函数，我们也未从任何地方调用 setup 函数：</p>
<pre><code class="language-shell">$ scarb test 
     Running test adder (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(adder_unittest) adder v0.1.0 (listings/ch10-testing-cairo-programs/no_listing_12_submodules/Scarb.toml)
   Compiling test(adder_integrationtest) adder_integrationtest v0.1.0 (listings/ch10-testing-cairo-programs/no_listing_12_submodules/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 2 test(s) from adder package
Running 1 test(s) from tests/
[PASS] adder_integrationtest::integration_tests::internal (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Running 1 test(s) from src/
[PASS] adder::tests::add (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 2 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p>为了避免系统地为 <em>tests</em> 文件夹的每个文件获取一个部分，我们还可以选择通过添加 <code>tests/lib.cairo</code> 文件使 <code>tests/</code> 目录像常规 crate 一样运行。在这种情况下，<code>tests</code> 目录将不再作为每个文件一个 crate 编译，而是作为整个目录的一个 crate 编译。</p>
<p>让我们创建这个 <em>tests/lib.cairo</em> 文件：</p>
<p><span class="caption">文件名: tests/lib.cairo</span></p>
<pre><code class="language-cairo noplayground">mod common;
mod integration_tests;
</code></pre>
<p>项目目录现在看起来像这样：</p>
<pre><code class="language-shell">adder
├── Scarb.lock
├── Scarb.toml
├── src
│   └── lib.cairo
└── tests
    ├── common.cairo
    ├── integration_tests.cairo
    └── lib.cairo
</code></pre>
<p>当我们再次运行 <code>scarb test</code> 命令时，输出如下：</p>
<pre><code class="language-shell">$ scarb test 
     Running test adder (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(adder_unittest) adder v0.1.0 (listings/ch10-testing-cairo-programs/no_listing_13_single_integration_crate/Scarb.toml)
   Compiling test(adder_tests) adder_tests v0.1.0 (listings/ch10-testing-cairo-programs/no_listing_13_single_integration_crate/Scarb.toml)
    Finished `dev` profile target(s) in 1 second


Collected 2 test(s) from adder package
Running 1 test(s) from tests/
[PASS] adder_tests::integration_tests::internal (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Running 1 test(s) from src/
[PASS] adder::tests::add (l1_gas: ~0, l1_data_gas: ~0, l2_gas: ~40000)
Tests: 2 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p>这样，只有测试函数会被测试，<code>setup</code> 函数可以被导入而无需被测试。</p>
<h2 id="总结-5"><a class="header" href="#总结-5">总结</a></h2>
<p>Cairo 的测试功能提供了一种指定代码应如何运行的方法，以确保即使在你进行更改时它也能按预期继续工作。单元测试分别练习库的不同部分，并可以测试私有实现细节。集成测试检查库的许多部分是否正确地协同工作，并且它们使用库的公共 API 以与外部代码使用它的方式相同的方式测试代码。即使 Cairo 的类型系统和所有权规则有助于防止某些类型的错误，测试对于减少与代码预期行为方式有关的逻辑错误仍然很重要。</p>
<p>{{#quiz ../quizzes/ch10-02-testing-organization.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="函数式语言特性迭代器和闭包"><a class="header" href="#函数式语言特性迭代器和闭包">函数式语言特性：迭代器和闭包</a></h1>
<p>Cairo 的设计深受 Rust 的启发，而 Rust 本身也深受许多现有语言和技术的启发，其中一个重要的影响就是 <em>函数式编程 (functional programming)</em>。以函数式风格编程通常包括将函数作为值（通过作为参数传递、从其他函数返回、将其分配给变量以供稍后执行等）使用。</p>
<p>在本章中，我们不会争论什么是或不是函数式编程的问题，而是将讨论 Cairo 的一些功能，这些功能类似于 Rust 和许多通常被称为函数式的语言中的功能。</p>
<p>更具体地说，我们将涵盖：</p>
<ul>
<li><em>闭包 (Closures)</em>，一种你可以存储在变量中的类似函数的构造</li>
<li><em>迭代器 (Iterators)</em>，一种处理元素序列的方法</li>
</ul>
<p>我们已经涵盖了其他一些 Cairo 功能，例如模式匹配和枚举，它们也受到 Rust 和函数式风格的影响。因为掌握闭包和迭代器是编写惯用、快速 Cairo 代码的重要组成部分，所以我们将把整章都献给它们。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="闭包"><a class="header" href="#闭包">闭包</a></h1>
<p>闭包是可以保存在变量中或作为参数传递给其他函数的匿名函数。你可以在一个地方创建闭包，然后在并在其他地方调用闭包以在不同的上下文中对其进行评估。与函数不同，闭包可以从定义它们的作用域中捕获值。我们将演示这些闭包功能如何允许代码重用和行为自定义。</p>
<blockquote>
<p>注意：闭包是在 Cairo 2.9 中引入的，目前仍在开发中。
一些新功能将在未来的 Cairo 版本中引入，因此本页面将随之发展。</p>
</blockquote>
<h2 id="理解闭包"><a class="header" href="#理解闭包">理解闭包</a></h2>
<p>在编写 Cairo 程序时，你经常需要将行为作为参数传递给另一个函数。闭包提供了一种内联定义此行为的方法，而无需创建单独的命名函数。在处理集合、错误处理以及任何你想要使用函数作为参数自定义函数行为的场景时，它们特别有价值。</p>
<p>考虑一个简单的例子，我们要根据某些条件以不同方式处理数字。我们无需编写多个函数，而是可以使用闭包在需要的地方定义行为：</p>
<pre><code class="language-cairo">    let double = |value| value * 2;
    println!("Double of 2 is {}", double(2_u8));
    println!("Double of 4 is {}", double(4_u8));

    // This won't work because `value` type has been inferred as `u8`.
    //println!("Double of 6 is {}", double(6_u16));

    let sum = |x: u32, y: u32, z: u16| {
        x + y + z.into()
    };
    println!("Result: {}", sum(1, 2, 3));
</code></pre>
<p>闭包的参数在管道符号（<code>|</code>）之间。注意我们不需要指定参数和返回值的类型（参见 <code>double</code> 闭包），它们将从闭包的使用中推断出来，就像对任何变量所做的那样。
当然，如果你使用具有不同类型的闭包，你将得到一个 <code>Type annotations needed</code> 错误，告诉你必须选择并指定闭包参数类型。</p>
<p>主体是一个表达式，可以像 <code>double</code> 一样在一行上没有 <code>{}</code>，或者像 <code>sum</code> 一样在几行上有 <code>{}</code>。</p>
<h2 id="使用闭包捕获环境"><a class="header" href="#使用闭包捕获环境">使用闭包捕获环境</a></h2>
<p>闭包的有趣之处之一是它们可以包含来自其封闭作用域的绑定。</p>
<p>在以下示例中，<code>my_closure</code> 使用对 <code>x</code> 的绑定来计算 <code>x + value * 3</code>。</p>
<pre><code class="language-cairo">    let x = 8;
    let my_closure = |value| {
        x * (value + 3)
    };

    println!("my_closure(1) = {}", my_closure(1));
</code></pre>
<blockquote>
<p>注意，目前闭包仍然不允许捕获可变变量，但这将在未来的 Cairo 版本中得到支持。</p>
</blockquote>
<h2 id="闭包类型推断和注释"><a class="header" href="#闭包类型推断和注释">闭包类型推断和注释</a></h2>
<p>函数和闭包之间还有更多区别。闭包通常不需要像 <code>fn</code> 函数那样注释参数或返回值的类型。函数需要类型注释，因为类型是暴露给用户的显式接口的一部分。严格定义此接口对于确保每个人都就函数使用和返回的值类型达成一致至关重要。另一方面，闭包不用于这样的暴露接口：它们存储在变量中，并在不命名它们且不将它们暴露给我们的库用户的情况下使用。</p>
<p>闭包通常很短，并且仅在狭窄的上下文中相关，而不是在任何任意场景中。在这些有限的上下文中，编译器可以推断参数的类型和返回类型，类似于它能够推断大多数量的类型的方式（在极少数情况下，编译器也需要闭包类型注释）。</p>
<p>与变量一样，如果我们想要增加明确性和清晰度，我们可以添加类型注释，代价是比严格必要的更冗长。闭包的类型注释看起来像清单 {{#ref closure-type}} 中显示的定义。在这个例子中，我们定义了一个闭包并将其存储在变量中，而不是像我们在清单 13-1 中所做的那样在作为参数传递它的地方定义闭包。</p>
<pre><code class="language-cairo">    let expensive_closure = |num: u32| -&gt; u32 {
        num
    };
</code></pre>
<p>{{#label closure-type}} 清单 {{#ref closure-type}}: 在闭包中添加参数和返回值类型的可选类型注释</p>
<p>添加了类型注释后，闭包的语法看起来更类似于函数的语法。这里我们为了比较，定义了一个将其参数加 1 的函数和一个具有相同行为的闭包。我们要添加了一些空格来对齐相关部分。这说明了闭包语法除了使用管道和可选语法的数量外，与函数语法是多么相似：</p>
<pre><code class="language-cairo ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
</code></pre>
<p>第一行显示了一个函数定义，第二行显示了一个完全注释的闭包定义。在第三行中，我们从闭包定义中删除了类型注释。在第四行中，我们删除了方括号，这是可选的，因为闭包主体只有一个表达式。这些都是有效的定义，在调用时会产生相同的行为。<code>add_one_v3</code> 和 <code>add_one_v4</code> 行需要评估闭包才能编译，因为类型将从其使用中推断出来。这类似于 <code>let array = array![];</code> 需要类型注释或某种类型的值插入到 <code>array</code> 中，以便 Cairo 能够推断类型。</p>
<p>对于闭包定义，编译器将为它的每个参数及其返回值推断一个具体类型。例如，清单 {{#ref closure-different-types}} 显示了一个简短闭包的定义，它只是返回它作为参数接收的值。除了用于此示例的目的外，此闭包不是很有用。注意我们在定义中没有添加任何类型注释。因为没有类型注释，我们可以用任何类型调用闭包，我们在这里第一次用 <code>u64</code> 做了这件事。如果我们随后尝试用 <code>32</code> 调用 <code>example_closure</code>，我们将得到一个错误。</p>
<pre><code class="language-cairo noplayground">    let example_closure = |x| x;

    let s = example_closure(5_u64);
    let n = example_closure(5_u32);
</code></pre>
<p>{{#label closure-different-types}} 清单 {{#ref closure-different-types}}:
尝试调用一个类型被推断为两种不同类型的闭包</p>
<p>编译器给出了这个错误：</p>
<pre><code>$ scarb build 
   Compiling listing_closure_different_types v0.1.0 (listings/ch11-functional-features/listing_closure_different_types/Scarb.toml)
warn[E0001]: Unused variable. Consider ignoring by prefixing with `_`.
 --&gt; listings/ch11-functional-features/listing_closure_different_types/src/lib.cairo:7:9
    let s = example_closure(5_u64);
        ^

warn[E0001]: Unused variable. Consider ignoring by prefixing with `_`.
 --&gt; listings/ch11-functional-features/listing_closure_different_types/src/lib.cairo:8:9
    let n = example_closure(5_u32);
        ^

error: Trait has no implementation in context: core::ops::function::Fn::&lt;{closure@listings/ch11-functional-features/listing_closure_different_types/src/lib.cairo:5:27: 5:30}, (core::integer::u32,)&gt;.
 --&gt; listings/ch11-functional-features/listing_closure_different_types/src/lib.cairo:8:13
    let n = example_closure(5_u32);
            ^^^^^^^^^^^^^^^^^^^^^^

error: could not compile `listing_closure_different_types` due to previous error

</code></pre>
<p>我们第一次使用 <code>u64</code> 值调用 <code>example_closure</code> 时，编译器推断 <code>x</code> 的类型和闭包的返回类型为 <code>u64</code>。然后这些类型被锁定在 <code>example_closure</code> 的闭包中，当我们下次尝试使用具有相同闭包的不同类型时，我们会得到类型错误。</p>
<h2 id="将捕获的值移出闭包和-fn-traits"><a class="header" href="#将捕获的值移出闭包和-fn-traits">将捕获的值移出闭包和 <code>Fn</code> Traits</a></h2>
<p>一旦闭包从定义闭包的环境中捕获了引或捕获了值的所有权（从而影响了什么被 <em>移动到</em> 闭包中，如果有的话），闭包主体中的代码定义了稍后评估闭包时对引用或值发生的情况（从而影响了什么被 <em>移出</em> 闭包，如果有的话）。闭包主体可以做以下任何事情：将捕获的值移出闭包，既不移动也不改变值，或者从一开始就不从环境中捕获任何东西。</p>
<p>闭包捕获和处理环境中值的方式会影响闭包实现哪些 traits，而 traits 是函数和结构体指定它们可以使用哪种闭包的方式。闭包将根据闭包的主体如何处理值，以累加的方式自动实现这些 <code>Fn</code> traits 中的一个、两个或全部三个：</p>
<ol>
<li>
<p><code>FnOnce</code> 适用于可以调用一次的闭包。所有闭包都至少实现了这个 trait，因为所有闭包都可以被调用。将捕获的值移出其主体的闭包将仅实现 <code>FnOnce</code> 而不实现其他 <code>Fn</code> traits，因为它只能被调用一次。</p>
</li>
<li>
<p><code>Fn</code> 适用于不将捕获的值移出其主体且不改变捕获的值的闭包，以及不从其环境中捕获任何内容的闭包。这些闭包可以被多次调用而不改变其环境，这在诸如并发多次调用闭包的情况下很重要。</p>
</li>
</ol>
<p>让我们看看我们在清单 13-1 中使用的 <code>OptionTrait&lt;T&gt;</code> 上的 <code>unwrap_or_else</code> 方法的定义：</p>
<pre><code class="language-cairo ignore">pub impl OptionTraitImpl&lt;T&gt; of OptionTrait&lt;T&gt; {
    #[inline]
    fn unwrap_or_else&lt;F, +Drop&lt;F&gt;, impl func: core::ops::FnOnce&lt;F, ()&gt;[Output: T], +Drop&lt;func::Output&gt;&gt;(
        self: Option&lt;T&gt;, f: F,
    ) -&gt; T {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}
</code></pre>
<p>回想一下，<code>T</code> 是表示 <code>Option</code> 的 <code>Some</code> 变体中值类型的泛型类型。该类型 <code>T</code> 也是 <code>unwrap_or_else</code> 函数的返回类型：例如，在 <code>Option&lt;ByteArray&gt;</code> 上调用 <code>unwrap_or_else</code> 的代码将获得 <code>ByteArray</code>。</p>
<p>接下来，注意 <code>unwrap_or_else</code> 函数具有额外的泛型类型参数 <code>F</code>。<code>F</code> 类型是名为 <code>f</code> 的参数的类型，这是我们在调用 <code>unwrap_or_else</code> 时提供的闭包。</p>
<p>在泛型类型 <code>F</code> 上指定的 trait 约束是 <code>impl func: core::ops::FnOnce&lt;F, ()&gt;[Output: T]</code>，这意味着 <code>F</code> 必须能够被调用一次，不接受参数（使用单元类型 <code>()</code>），并返回 <code>T</code> 作为输出。在 trait 约束中使用 <code>FnOnce</code> 表达了 <code>unwrap_or_else</code> 最多只调用 <code>f</code> 一次的约束。在 <code>unwrap_or_else</code> 的主体中，我们可以看到如果 <code>Option</code> 是 <code>Some</code>，则不会调用 <code>f</code>。如果 <code>Option</code> 是 <code>None</code>，则 <code>f</code> 将被调用一次。因为所有闭包都实现了 <code>FnOnce</code>，<code>unwrap_or_else</code> 接受所有三种类型的闭包，并且尽可能灵活。</p>
<p><code>Fn</code> traits 在定义或使用利用闭包的函数或类型时很重要。在下一节中，我们将讨论迭代器。许多迭代器方法接受闭包参数，所以在我们继续时请记住这些闭包细节！</p>
<p>在底层，闭包是通过 <code>FnOnce</code> 和 <code>Fn</code> traits 实现的。
<code>FnOnce</code> 为可能消耗捕获变量的闭包实现，其中 <code>Fn</code> 为仅捕获可复制变量的闭包实现。</p>
<h2 id="使用闭包实现你的函数式编程模式"><a class="header" href="#使用闭包实现你的函数式编程模式">使用闭包实现你的函数式编程模式</a></h2>
<p>闭包的另一个巨大兴趣是，像任何类型的变量一样，你可以将它们作为函数参数传递。这种机制在函数式编程中被大量使用，通过像 <code>map</code>、<code>filter</code> 或 <code>reduce</code> 这样的经典函数。</p>
<p>这是 <code>map</code> 的一个潜在实现，用于将相同的函数应用于数组的所有项目：</p>
<pre><code class="language-cairo noplayground">#[generate_trait]
impl ArrayExt of ArrayExtTrait {
    // Needed in Cairo 2.11.4 because of a bug in inlining analysis.
    #[inline(never)]
    fn map&lt;T, +Drop&lt;T&gt;, F, +Drop&lt;F&gt;, impl func: core::ops::Fn&lt;F, (T,)&gt;, +Drop&lt;func::Output&gt;&gt;(
        self: Array&lt;T&gt;, f: F,
    ) -&gt; Array&lt;func::Output&gt; {
        let mut output: Array&lt;func::Output&gt; = array![];
        for elem in self {
            output.append(f(elem));
        }
        output
    }
}
</code></pre>
<blockquote>
<p>注意，由于内联分析中的错误，应使用 <code>#[inline(never)]</code> 禁用此分析过程。</p>
</blockquote>
<p>在此实现中，你会注意到，虽然 <code>T</code> 是输入数组 <code>self</code> 的元素类型，但输出数组的元素类型由 <code>f</code> 闭包的输出类型（来自 <code>Fn</code> trait 的关联类型 <code>func::Output</code>）定义。</p>
<p>这意味着你的 <code>f</code> 闭包可以返回与以下代码中的 <code>_double</code> 相同类型的元素，或与 <code>_another</code> 相同的任何其他类型的元素：</p>
<pre><code class="language-cairo">    let double = array![1, 2, 3].map(|item: u32| item * 2);
    let another = array![1, 2, 3].map(|item: u32| {
        let x: u64 = item.into();
        x * x
    });

    println!("double: {:?}", double);
    println!("another: {:?}", another);
</code></pre>
<blockquote>
<p>目前，Cairo 2.9 提供了一项实验性功能，允许你使用 <code>Scarb.toml</code> 中的 <code>experimental-features = ["associated_item_constraints"]</code> 指定 trait 的关联类型。</p>
</blockquote>
<p>假设我们要为数组实现 <code>filter</code> 函数，以过滤掉不符合标准的元素。此标准将通过一个闭包提供，该闭包接受一个元素作为输入，如果必须保留该元素则返回 <code>true</code>，否则返回 <code>false</code>。这意味着，我们需要指定闭包必须返回一个 <code>boolean</code>。</p>
<pre><code class="language-cairo noplayground">#[generate_trait]
impl ArrayFilterExt of ArrayFilterExtTrait {
    // Needed in Cairo 2.11.4 because of a bug in inlining analysis.
    #[inline(never)]
    fn filter&lt;
        T,
        +Copy&lt;T&gt;,
        +Drop&lt;T&gt;,
        F,
        +Drop&lt;F&gt;,
        impl func: core::ops::Fn&lt;F, (T,)&gt;[Output: bool],
        +Drop&lt;func::Output&gt;,
    &gt;(
        self: Array&lt;T&gt;, f: F,
    ) -&gt; Array&lt;T&gt; {
        let mut output: Array&lt;T&gt; = array![];
        for elem in self {
            if f(elem) {
                output.append(elem);
            }
        }
        output
    }
}
</code></pre>
<pre><code class="language-cairo">    let even = array![3, 4, 5, 6].filter(|item: u32| item % 2 == 0);
    println!("even: {:?}", even);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="高级特性"><a class="header" href="#高级特性">高级特性</a></h1>
<p>现在，让我们学习 Cairo 提供的更多高级特性。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="自定义数据结构"><a class="header" href="#自定义数据结构">自定义数据结构</a></h1>
<p>当你第一次开始用 Cairo 编程时，你可能会想用数组 (<code>Array&lt;T&gt;</code>) 来存储数据集合。然而，你很快就会意识到数组有一个很大的限制 —— 存储在其中的数据是不可变的。一旦向数组追加了一个值，就不能再修改它。</p>
<p>当你想要使用可变数据结构时，这可能会令人沮丧。例如，假设你正在制作一个游戏，玩家有等级，并且他们可以升级。你可能会尝试将玩家的等级存储在一个数组中：</p>
<pre><code class="language-cairo noplayground">    let mut level_players = array![5, 1, 10];
</code></pre>
<p>但是随后你意识到，一旦设置好，你就无法增加特定索引处的等级。如果玩家死亡，你也无法将其从数组中移除，除非他碰巧在第一个位置。</p>
<p>幸运的是，Cairo 提供了一个方便的内置 <a href="#字典">字典类型</a> 叫做 <code>Felt252Dict&lt;T&gt;</code>，它允许我们模拟可变数据结构的行为。让我们首先探索如何创建一个包含 <code>Felt252Dict&lt;T&gt;</code> 等成员的结构体。</p>
<blockquote>
<p>注意：本章中使用的几个概念在本书前面已经介绍过。如果你需要复习，我们建议查看以下章节：<a href="#使用结构体组织相关数据">结构体</a>、<a href="#方法语法">方法</a>、<a href="#泛型类型和-traits">泛型类型</a>、<a href="#cairo-中的-traits">Traits</a>。</p>
</blockquote>
<h2 id="字典作为结构体成员"><a class="header" href="#字典作为结构体成员">字典作为结构体成员</a></h2>
<p>在 Cairo 中可以将字典定义为结构体成员，但正确地与它们交互可能并不完全无缝。让我们尝试实现一个自定义的 <em>用户数据库</em>，它将允许我们添加用户并查询他们。我们需要定义一个结构体来表示新类型，并定义一个 trait 来定义其功能：</p>
<pre><code class="language-cairo noplayground">struct UserDatabase&lt;T&gt; {
    users_updates: u64,
    balances: Felt252Dict&lt;T&gt;,
}

trait UserDatabaseTrait&lt;T&gt; {
    fn new() -&gt; UserDatabase&lt;T&gt;;
    fn update_user&lt;+Drop&lt;T&gt;&gt;(ref self: UserDatabase&lt;T&gt;, name: felt252, balance: T);
    fn get_balance&lt;+Copy&lt;T&gt;&gt;(ref self: UserDatabase&lt;T&gt;, name: felt252) -&gt; T;
}
</code></pre>
<p>我们的新类型 <code>UserDatabase&lt;T&gt;</code> 表示一个用户数据库。它在用户的余额上是泛型的，为使用我们数据类型的任何人提供了极大的灵活性。它的两个成员是：</p>
<ul>
<li><code>users_updates</code>，字典中用户更新的次数。</li>
<li><code>balances</code>，每个用户到其余额的映射。</li>
</ul>
<p>数据库的核心功能由 <code>UserDatabaseTrait</code> 定义。定义了以下方法：</p>
<ul>
<li><code>new</code> 用于轻松创建新的 <code>UserDatabase</code> 类型。</li>
<li><code>update_user</code> 用于更新数据库中用户的余额。</li>
<li><code>get_balance</code> 用于查找数据库中用户的余额。</li>
</ul>
<p>剩下的唯一步骤是实现 <code>UserDatabaseTrait</code> 中的每个方法，但由于我们正在处理 <a href="#泛型类型和-traits">泛型类型</a>，我们还需要正确建立 <code>T</code> 的要求，以便它可以是一个有效的 <code>Felt252Dict&lt;T&gt;</code> 值类型：</p>
<ol>
<li><code>T</code> 应该实现 <code>Copy&lt;T&gt;</code>，因为从 <code>Felt252Dict&lt;T&gt;</code> 获取值需要它。</li>
<li>字典的所有值类型都实现了 <code>Felt252DictValue&lt;T&gt;</code>，我们的泛型类型也应该这样做。</li>
<li>要插入值，<code>Felt252DictTrait&lt;T&gt;</code> 要求所有值类型都是可丢弃的（实现 <code>Drop&lt;T&gt;</code> trait）。</li>
</ol>
<p>在所有限制到位的情况下，实现将如下所示：</p>
<pre><code class="language-cairo noplayground">impl UserDatabaseImpl&lt;T, +Felt252DictValue&lt;T&gt;&gt; of UserDatabaseTrait&lt;T&gt; {
    // Creates a database
    fn new() -&gt; UserDatabase&lt;T&gt; {
        UserDatabase { users_updates: 0, balances: Default::default() }
    }

    // Get the user's balance
    fn get_balance&lt;+Copy&lt;T&gt;&gt;(ref self: UserDatabase&lt;T&gt;, name: felt252) -&gt; T {
        self.balances.get(name)
    }

    // Add a user
    fn update_user&lt;+Drop&lt;T&gt;&gt;(ref self: UserDatabase&lt;T&gt;, name: felt252, balance: T) {
        self.balances.insert(name, balance);
        self.users_updates += 1;
    }
}
</code></pre>
<p>我们的数据库实现几乎完成了，只有一件事除外：编译器不知道如何让 <code>UserDatabase&lt;T&gt;</code> 离开作用域，因为它没有实现 <code>Drop&lt;T&gt;</code> trait，也没有实现 <code>Destruct&lt;T&gt;</code> trait。因为它有一个 <code>Felt252Dict&lt;T&gt;</code> 作为成员，它不能被丢弃，所以我们被迫手动实现 <code>Destruct&lt;T&gt;</code> trait（有关更多信息，请参阅 <a href="#the-drop-trait">所有权</a> 章节）。在 <code>UserDatabase&lt;T&gt;</code> 定义之上使用 <code>#[derive(Destruct)]</code> 将不起作用，因为结构体定义中使用了 <a href="#泛型类型和-traits">泛型类型</a>。我们需要自己编写 <code>Destruct&lt;T&gt;</code> trait 实现：</p>
<pre><code class="language-cairo noplayground">impl UserDatabaseDestruct&lt;T, +Drop&lt;T&gt;, +Felt252DictValue&lt;T&gt;&gt; of Destruct&lt;UserDatabase&lt;T&gt;&gt; {
    fn destruct(self: UserDatabase&lt;T&gt;) nopanic {
        self.balances.squash();
    }
}
</code></pre>
<p>为 <code>UserDatabase</code> 实现 <code>Destruct&lt;T&gt;</code> 是我们获得功能齐全的数据库的最后一步。我们现在可以试用它：</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut db = UserDatabaseTrait::&lt;u64&gt;::new();

    db.update_user('Alex', 100);
    db.update_user('Maria', 80);

    db.update_user('Alex', 40);
    db.update_user('Maria', 0);

    let alex_latest_balance = db.get_balance('Alex');
    let maria_latest_balance = db.get_balance('Maria');

    assert!(alex_latest_balance == 40, "Expected 40");
    assert!(maria_latest_balance == 0, "Expected 0");
}
</code></pre>
<h2 id="使用字典模拟动态数组"><a class="header" href="#使用字典模拟动态数组">使用字典模拟动态数组</a></h2>
<p>首先，让我们考虑一下我们要让我们的可变动态数组表现得如何。它应该支持哪些操作？</p>
<p>它应该：</p>
<ul>
<li>允许我们在末尾追加项目。</li>
<li>让我们通过索引访问任何项目。</li>
<li>允许设置特定索引处的项目值。</li>
<li>返回当前长度。</li>
</ul>
<p>我们可以在 Cairo 中这样定义这个接口：</p>
<pre><code class="language-cairo noplayground">trait MemoryVecTrait&lt;V, T&gt; {
    fn new() -&gt; V;
    fn get(ref self: V, index: usize) -&gt; Option&lt;T&gt;;
    fn at(ref self: V, index: usize) -&gt; T;
    fn push(ref self: V, value: T) -&gt; ();
    fn set(ref self: V, index: usize, value: T);
    fn len(self: @V) -&gt; usize;
}
</code></pre>
<p>这为我们的动态数组的实现提供了蓝图。我们将其命名为 <em>MemoryVec</em>，因为它类似于 Rust 中的 <code>Vec&lt;T&gt;</code> 数据结构。</p>
<blockquote>
<p>注意：Cairo 的核心库已经包含了一个 <code>Vec&lt;T&gt;</code> 数据结构，严格用作智能合约中的存储类型。为了将我们的数据结构与核心库的数据结构区分开来，我们将我们的实现命名为 <em>MemoryVec</em>。</p>
</blockquote>
<h3 id="在-cairo-中实现动态数组"><a class="header" href="#在-cairo-中实现动态数组">在 Cairo 中实现动态数组</a></h3>
<p>为了存储我们的数据，我们将使用 <code>Felt252Dict&lt;T&gt;</code>，它将索引号 (felts) 映射到值。我们还将存储一个单独的 <code>len</code> 字段来跟踪长度。</p>
<p>这是我们的结构体的样子。我们将类型 <code>T</code> 包装在 <code>Nullable</code> 指针内，以允许在我们的数据结构中使用任何类型 <code>T</code>，如 <a href="#dictionaries-of-types-not-supported-natively">字典</a> 部分所述：</p>
<pre><code class="language-cairo noplayground">struct MemoryVec&lt;T&gt; {
    data: Felt252Dict&lt;Nullable&lt;T&gt;&gt;,
    len: usize,
}
</code></pre>
<p>因为我们再次拥有 <code>Felt252Dict&lt;T&gt;</code> 作为结构体成员，我们需要实现 <code>Destruct&lt;T&gt;</code> trait 来告诉编译器如何让 <code>MemoryVec&lt;T&gt;</code> 离开作用域。</p>
<pre><code class="language-cairo noplayground">impl DestructMemoryVec&lt;T, +Drop&lt;T&gt;&gt; of Destruct&lt;MemoryVec&lt;T&gt;&gt; {
    fn destruct(self: MemoryVec&lt;T&gt;) nopanic {
        self.data.squash();
    }
}
</code></pre>
<p>使这个向量可变的关键是我们可以在字典中插入值来设置或更新我们数据结构中的值。例如，要更新特定索引处的值，我们这样做：</p>
<pre><code class="language-cairo noplayground">    fn set(ref self: MemoryVec&lt;T&gt;, index: usize, value: T) {
        assert!(index &lt; self.len(), "Index out of bounds");
        self.data.insert(index.into(), NullableTrait::new(value));
    }
</code></pre>
<p>这将覆盖字典中该索引处先前存在的值。</p>
<p>虽然数组是不可变的，但字典提供了我们需要的灵活性，用于像向量这样的可修改数据结构。</p>
<p>其余接口的实现很简单。我们接口中定义的所有方法的实现可以如下完成：</p>
<pre><code class="language-cairo noplayground">impl MemoryVecImpl&lt;T, +Drop&lt;T&gt;, +Copy&lt;T&gt;&gt; of MemoryVecTrait&lt;MemoryVec&lt;T&gt;, T&gt; {
    fn new() -&gt; MemoryVec&lt;T&gt; {
        MemoryVec { data: Default::default(), len: 0 }
    }

    fn get(ref self: MemoryVec&lt;T&gt;, index: usize) -&gt; Option&lt;T&gt; {
        if index &lt; self.len() {
            Some(self.data.get(index.into()).deref())
        } else {
            None
        }
    }

    fn at(ref self: MemoryVec&lt;T&gt;, index: usize) -&gt; T {
        assert!(index &lt; self.len(), "Index out of bounds");
        self.data.get(index.into()).deref()
    }

    fn push(ref self: MemoryVec&lt;T&gt;, value: T) -&gt; () {
        self.data.insert(self.len.into(), NullableTrait::new(value));
        self.len.wrapping_add(1_usize);
    }
    // ANCHOR: set
    fn set(ref self: MemoryVec&lt;T&gt;, index: usize, value: T) {
        assert!(index &lt; self.len(), "Index out of bounds");
        self.data.insert(index.into(), NullableTrait::new(value));
    }
    // ANCHOR_END: set
    fn len(self: @MemoryVec&lt;T&gt;) -&gt; usize {
        *self.len
    }
}
</code></pre>
<p><code>MemoryVec</code> 结构的完整实现可以在社区维护的库 <a href="https://github.com/keep-starknet-strange/alexandria/blob/main/packages/data_structures/src/vec.cairo">Alexandria</a> 中找到。</p>
<h2 id="使用字典模拟栈"><a class="header" href="#使用字典模拟栈">使用字典模拟栈</a></h2>
<p>我们现在将看第二个例子及其实现细节：一个栈 (Stack)。</p>
<p>栈是一个后进先出 (LIFO, Last-In, First-Out) 集合。新元素的插入和现有元素的移除发生在同一端，表示为栈顶。</p>
<p>让我们定义我们需要什么操作来创建一个栈：</p>
<ul>
<li>将一个项目推送到栈顶。</li>
<li>从栈顶弹出一个项目。</li>
<li>检查栈中是否还有任何元素。</li>
</ul>
<p>从这些规范中，我们可以定义以下接口：</p>
<pre><code class="language-cairo noplayground">trait StackTrait&lt;S, T&gt; {
    fn push(ref self: S, value: T);
    fn pop(ref self: S) -&gt; Option&lt;T&gt;;
    fn is_empty(self: @S) -&gt; bool;
}
</code></pre>
<h3 id="在-cairo-中实现可变栈"><a class="header" href="#在-cairo-中实现可变栈">在 Cairo 中实现可变栈</a></h3>
<p>要在 Cairo 中创建栈数据结构，我们可以再次使用 <code>Felt252Dict&lt;T&gt;</code> 来存储栈的值，以及一个 <code>usize</code> 字段来跟踪栈的长度以便对其进行迭代。</p>
<p>栈结构体定义为：</p>
<pre><code class="language-cairo noplayground">struct NullableStack&lt;T&gt; {
    data: Felt252Dict&lt;Nullable&lt;T&gt;&gt;,
    len: usize,
}
</code></pre>
<p>接下来，让我们看看我们的主要函数 <code>push</code> 和 <code>pop</code> 是如何实现的。</p>
<pre><code class="language-cairo noplayground">impl NullableStackImpl&lt;T, +Drop&lt;T&gt;, +Copy&lt;T&gt;&gt; of StackTrait&lt;NullableStack&lt;T&gt;, T&gt; {
    fn push(ref self: NullableStack&lt;T&gt;, value: T) {
        self.data.insert(self.len.into(), NullableTrait::new(value));
        self.len += 1;
    }

    fn pop(ref self: NullableStack&lt;T&gt;) -&gt; Option&lt;T&gt; {
        if self.is_empty() {
            return None;
        }
        self.len -= 1;
        Some(self.data.get(self.len.into()).deref())
    }

    fn is_empty(self: @NullableStack&lt;T&gt;) -&gt; bool {
        *self.len == 0
    }
}
</code></pre>
<p>代码使用 <code>insert</code> 和 <code>get</code> 方法来访问 <code>Felt252Dict&lt;T&gt;</code> 中的值。要将元素推送到栈顶，<code>push</code> 函数将元素插入到字典的索引 <code>len</code> 处，并增加栈的 <code>len</code> 字段以跟踪栈顶的位置。要移除值，<code>pop</code> 函数减少 <code>len</code> 的值以更新栈顶的位置，然后检索位置 <code>len</code> 处的最后一个值。</p>
<p>栈的完整实现，以及你可以在代码中使用的更多数据结构，可以在社区维护的 <a href="https://github.com/keep-starknet-strange/alexandria/tree/main/packages/data_structures/src">Alexandria</a> 库的 “data_structures” crate 中找到。</p>
<p>{{#quiz ../quizzes/ch12-01-custom-structs.toml}}</p>
<h2 id="总结-6"><a class="header" href="#总结-6">总结</a></h2>
<p>干得好！现在你已经了解了数组、字典甚至自定义数据结构。虽然 Cairo 的内存模型是不可变的，这可能会使实现可变数据结构变得困难，但幸运的是我们可以使用 <code>Felt252Dict&lt;T&gt;</code> 类型来模拟可变数据结构。这允许我们实现广泛的对许多应用程序有用的数据结构，有效地隐藏了底层内存模型的复杂性。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="智能指针"><a class="header" href="#智能指针">智能指针</a></h1>
<p>指针是一个通用概念，指包含内存地址的变量。此地址引用或“指向”其他一些数据。虽然指针是一个强大的功能，但它们也可能是错误和安全漏洞的来源。例如，指针可以引用未分配的内存单元，这意味着尝试访问该地址处的数据会导致程序崩溃，使其变得不可证明。为了防止此类问题，Cairo 使用 <em>智能指针 (Smart Pointers)</em>。</p>
<p>智能指针是像指针一样行动的数据结构，但也具有额外的元数据和功能。智能指针的概念并非 Cairo 独有：智能指针起源于 C++，并且也存在于像 Rust 这样的其他语言中。在 Cairo 的特定情况下，智能指针通过严格的类型检查和所有权规则提供一种访问内存的安全方式，确保不会以可能导致程序不可证明的不安全方式寻址内存。</p>
<p>虽然我们当时没有这样称呼它们，但我们在本书中已经遇到过一些智能指针，包括 <a href="#常见集合">第 {{#chap common-collections}} 章</a> 中的 <code>Felt252Dict&lt;T&gt;</code> 和 <code>Array&lt;T&gt;</code>。这两种类型都算作智能指针，因为它们拥有一个内存段并允许你操作它。它们还具有元数据和额外的功能或保证。数组跟踪其当前长度，以确保现有元素不被覆盖，并且新元素仅追加到末尾。</p>
<p>Cairo VM 内存由多个可以存储数据的段组成，每个段由唯一索引标识。当你创建一个数组时，你在内存中分配一个新的段来存储未来的元素。数组本身只是一个指向存储元素的那个段的指针。</p>
<h2 id="用于操作指针的-boxt-类型"><a class="header" href="#用于操作指针的-boxt-类型">用于操作指针的 <code>Box&lt;T&gt;</code> 类型</a></h2>
<p>Cairo 中的主要智能指针类型是一个 <em>box</em>，表示为 <code>Box&lt;T&gt;</code>。手动定义 boxes 允许你将数据存储在 Cairo VM 的特定内存段中，称为 <em>boxed segment</em>。此段专门用于存储所有 boxed 值，留在执行段中的只是一个指向 boxed 段的指针。每当你实例化一个新的 <code>Box&lt;T&gt;</code> 类型的指针变量时，你就将 <code>T</code> 类型的数据追加到 boxed 段。</p>
<p>除了将它们的内部值写入 boxed 段外，Boxes 几乎没有性能开销。但它们也没有很多额外的功能。你将在这些情况下最常使用它们：</p>
<ul>
<li>当你有一个在编译时无法知道大小的类型，并且你想要在需要确切大小的上下文中使用该类型的值时</li>
<li>当你有大量数据并且你想要转移所有权但确保在这样做时数据不会被复制时</li>
</ul>
<p>我们将在 <a href="#enabling-recursive-types-with-nullable-boxes">“使用 Boxes 启用递归类型”</a> 部分演示第一种情况。在第二种情况下，转移大量数据的所有权可能需要很长时间，因为数据会在内存中被复制。为了改善这种情况下的性能，我们可以使用 box 类型将大量数据存储在 boxed 段中。然后，只有少量的指针数据在内存中被复制，而它引用的数据则留在 boxed 段的一个地方。</p>
<h3 id="使用-boxt-在-boxed-segment-中存储数据"><a class="header" href="#使用-boxt-在-boxed-segment-中存储数据">使用 <code>Box&lt;T&gt;</code> 在 Boxed Segment 中存储数据</a></h3>
<p>在讨论 <code>Box&lt;T&gt;</code> 的 boxed segment 存储用例之前，我们将介绍语法以及如何与存储在 <code>Box&lt;T&gt;</code> 中的值进行交互。</p>
<p>清单 {{#ref basic_box}} 展示了如何使用 box 在 boxed segment 中存储一个值：</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let b = BoxTrait::new(5_u128);
    println!("b = {}", b.unbox())
}
</code></pre>
<p>{{#label basic_box}} <span class="caption">清单 {{#ref basic_box}}: 使用 box 在 boxed segment 中存储 <code>u128</code> 值</span></p>
<p>我们定义变量 <code>b</code> 具有指向值 <code>5</code> 的 <code>Box</code> 的值，该值存储在 boxed segment 中。该程序将打印 <code>b = 5</code>；在这种情况下，我们可以像访问执行内存中的数据一样访问 box 中的数据。将单个值放在 box 中并不是很有用，所以你不会经常以这种方式单独使用 boxes。像单个 <code>u128</code> 这样的值默认存储在执行内存中，在大多数情况下更合适。让我们看一个例子，其中 boxes 允许我们定义如果没有 boxes 我们将被禁止定义的类型。</p>
<h3 id="使用-boxes-启用递归类型"><a class="header" href="#使用-boxes-启用递归类型">使用 Boxes 启用递归类型</a></h3>
<p>递归类型的值可以拥有相同类型的另一个值作为其自身的一部分。递归类型会带来问题，因为在编译时 Cairo 需要知道一个类型占用多少空间。然而，递归类型的值的嵌套理论上可以无限继续，所以 Cairo 无法知道该值需要多少空间。因为 boxes 有一个已知的大小，我们可以通过在递归类型定义中插入一个 box 来启用递归类型。</p>
<p>作为递归类型的一个例子，让我们探索二叉树的实现。我们将定义的二叉树类型除了递归之外都很简单；因此，我们将使用的示例中的概念在你遇到涉及递归类型的更复杂情况时都会很有用。</p>
<p>二叉树是一种树数据结构，其中每个节点最多有两个子节点，分别称为左子节点和右子节点。分支的最后一个元素是叶子，它是一个没有子节点的节点。</p>
<p>清单 {{#ref recursive_types_wrong}} 显示了实现 <code>u32</code> 值二叉树的尝试。注意这段代码还不能编译，因为 <code>BinaryTree</code> 类型没有已知的大小，我们将演示这一点。</p>
<pre><code class="language-cairo noplayground">//TAG: does_not_compile

#[derive(Copy, Drop)]
enum BinaryTree {
    Leaf: u32,
    Node: (u32, BinaryTree, BinaryTree),
}

#[executable]
fn main() {
    let leaf1 = BinaryTree::Leaf(1);
    let leaf2 = BinaryTree::Leaf(2);
    let leaf3 = BinaryTree::Leaf(3);
    let node = BinaryTree::Node((4, leaf2, leaf3));
    let _root = BinaryTree::Node((5, leaf1, node));
}
</code></pre>
<p>{{#label recursive_types_wrong}} <span class="caption">清单 {{#ref recursive_types_wrong}}: 实现 <code>u32</code> 值二叉树的第一次尝试</span></p>
<blockquote>
<p>注意：为了本示例的目的，我们实现了一个仅保存 u32 值的二叉树。我们可以使用泛型来实现它，正如我们在第 {{#chap generic-types-and-traits}} 章中讨论的那样，来定义一个可以存储任何类型值的二叉树。</p>
</blockquote>
<p>根节点包含 5 和两个子节点。左子节点是一个包含 1 的叶子。右子节点是另一个包含 4 的节点，它反过来又有两个叶子子节点：一个包含 2，另一个包含 3。此结构形成了一个深度为 2 的简单二叉树。</p>
<p>如果我们尝试编译清单 {{#ref recursive_types_wrong}} 中的代码，我们会得到以下错误：</p>
<pre><code class="language-plaintext">$ scarb build 
   Compiling listing_recursive_types_wrong v0.1.0 (listings/ch12-advanced-features/listing_recursive_types_wrong/Scarb.toml)
error: Recursive type "(core::integer::u32, listing_recursive_types_wrong::BinaryTree, listing_recursive_types_wrong::BinaryTree)" has infinite size.
 --&gt; listings/ch12-advanced-features/listing_recursive_types_wrong/src/lib.cairo:6:5
    Node: (u32, BinaryTree, BinaryTree),
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Recursive type "listing_recursive_types_wrong::BinaryTree" has infinite size.
 --&gt; listings/ch12-advanced-features/listing_recursive_types_wrong/src/lib.cairo:11:17
    let leaf1 = BinaryTree::Leaf(1);
                ^^^^^^^^^^^^^^^^^^^

error: Recursive type "(core::integer::u32, listing_recursive_types_wrong::BinaryTree, listing_recursive_types_wrong::BinaryTree)" has infinite size.
 --&gt; listings/ch12-advanced-features/listing_recursive_types_wrong/src/lib.cairo:14:33
    let node = BinaryTree::Node((4, leaf2, leaf3));
                                ^^^^^^^^^^^^^^^^^

error: could not compile `listing_recursive_types_wrong` due to previous error

</code></pre>
<p>错误显示此类型“具有无限大小”。原因是我们将 <code>BinaryTree</code> 定义为具有一个递归的变体：它直接持有自身的另一个值。结果，Cairo 无法弄清楚存储 <code>BinaryTree</code> 值需要多少空间。</p>
<p>希望我们可以通过使用 <code>Box&lt;T&gt;</code> 来存储 <code>BinaryTree</code> 的递归变体来修复此错误。因为 <code>Box&lt;T&gt;</code> 是一个指针，Cairo 总是知道 <code>Box&lt;T&gt;</code> 需要多少空间：指针的大小不会根据它指向的数据量而改变。这意味着我们可以将 <code>Box&lt;T&gt;</code> 放在 <code>Node</code> 变体中，而不是直接放另一个 <code>BinaryTree</code> 值。<code>Box&lt;T&gt;</code> 将指向将存储在它们自己段中的子 <code>BinaryTree</code> 值，而不是在 <code>Node</code> 变体内。从概念上讲，我们仍然有一个二叉树，由持有其他二叉树的二叉树创建，但此实现现在更像是将项目彼此并排放置，而不是彼此嵌套。</p>
<p>我们可以将清单 {{#ref recursive_types_wrong}} 中 <code>BinaryTree</code> 枚举的定义和清单 {{#ref recursive_types_wrong}} 中 <code>BinaryTree</code> 的使用更改为清单 {{#ref recursive_types}} 中的代码，这将可以编译：</p>
<pre><code class="language-cairo">mod display;
use display::DebugBinaryTree;

#[derive(Copy, Drop)]
enum BinaryTree {
    Leaf: u32,
    Node: (u32, Box&lt;BinaryTree&gt;, Box&lt;BinaryTree&gt;),
}


#[executable]
fn main() {
    let leaf1 = BinaryTree::Leaf(1);
    let leaf2 = BinaryTree::Leaf(2);
    let leaf3 = BinaryTree::Leaf(3);
    let node = BinaryTree::Node((4, BoxTrait::new(leaf2), BoxTrait::new(leaf3)));
    let root = BinaryTree::Node((5, BoxTrait::new(leaf1), BoxTrait::new(node)));

    println!("{:?}", root);
}
</code></pre>
<p>{{#label recursive_types}} <span class="caption">清单 {{#ref recursive_types}}: 使用 Boxes 定义递归二叉树</span></p>
<p><code>Node</code> 变体现在持有 <code>(u32, Box&lt;BinaryTree&gt;, Box&lt;BinaryTree&gt;)</code>，表示 <code>Node</code> 变体将存储一个 <code>u32</code> 值和两个 <code>Box&lt;BinaryTree&gt;</code> 值。现在，我们知道 <code>Node</code> 变体将需要 <code>u32</code> 的大小加上两个 <code>Box&lt;BinaryTree&gt;</code> 值的大小。通过使用 box，我们打破了无限的递归链，因此编译器可以计算出存储 <code>BinaryTree</code> 值所需的大小。</p>
<h3 id="使用-boxes-提高性能"><a class="header" href="#使用-boxes-提高性能">使用 Boxes 提高性能</a></h3>
<p>在函数之间传递指针允许你引用数据而无需复制数据本身。使用 boxes 可以提高性能，因为它允许你将指向某些数据的指针从一个函数传递到另一个函数，而无需在执行函数调用之前复制内存中的整个数据。不必在调用函数之前将 <code>n</code> 个值写入内存，只需写入对应于数据指针的单个值。如果存储在 box 中的数据非常大，性能提升可能会很显著，因为你会在每次函数调用前节省 <code>n-1</code> 次内存操作。</p>
<blockquote>
<p>注意：这仅适用于存储在 box 中的数据未被变异（mutated）的情况。如果数据被变异，将创建一个新的 <code>Box&lt;T&gt;</code>，这将需要将数据复制到新 box 中。</p>
</blockquote>
<p>让我们看看清单 {{#ref box}} 中的代码，它展示了向函数传递数据的两种方式：按值和按指针。</p>
<pre><code class="language-cairo">#[derive(Drop)]
struct Cart {
    paid: bool,
    items: u256,
    buyer: ByteArray,
}

fn pass_data(cart: Cart) {
    println!("{} is shopping today and bought {} items", cart.buyer, cart.items);
}

fn pass_pointer(cart: Box&lt;Cart&gt;) {
    let cart = cart.unbox();
    println!("{} is shopping today and bought {} items", cart.buyer, cart.items);
}

#[executable]
fn main() {
    let new_struct = Cart { paid: true, items: 1, buyer: "Eli" };
    pass_data(new_struct);

    let new_box = BoxTrait::new(Cart { paid: false, items: 2, buyer: "Uri" });
    pass_pointer(new_box);
}
</code></pre>
<p>{{#label box}} <span class="caption">清单 {{#ref box}}: 将大量数据存储在 box 中以提高性能。</span></p>
<p><code>main</code> 函数包含 2 个函数调用：</p>
<ul>
<li><code>pass_data</code> 接受一个 <code>Cart</code> 类型的变量。</li>
<li><code>pass_pointer</code> 接受一个 <code>Box&lt;Cart&gt;</code> 类型的指针。</li>
</ul>
<p>当向函数传递数据时，整个数据会在紧接函数调用之前被复制到最后可用的内存单元中。调用 <code>pass_data</code> 将把 <code>Cart</code> 的所有 3 个字段复制到内存中，而 <code>pass_pointer</code> 仅需要复制大小为 1 的 <code>new_box</code> 指针。</p>
<div align="center">
    <img src="box_memory.png" alt="box memory" width="500px" />
<div align="center">
    </div>

    <span class="caption">使用 boxes 时的 CairoVM 内存布局</span>
</div>

<p>上面的插图演示了内存在两种情况下的行为。<code>Cart</code> 的第一个实例存储在执行段中，我们需要在调用 <code>pass_data</code> 函数之前将其所有字段复制到内存中。<code>Cart</code> 的第二个实例存储在 boxed segment 中，指向它的指针存储在执行段中。当调用 <code>pass_pointer</code> 函数时，只有指向结构体的指针在紧接函数调用之前被复制到内存中。然而，在这两种情况下，实例化结构体都会将其所有值存储在执行段中：boxed segment 只能用取自执行段的数据填充。</p>
<h2 id="字典的-nullablet-类型"><a class="header" href="#字典的-nullablet-类型">字典的 <code>Nullable&lt;T&gt;</code> 类型</a></h2>
<p><code>Nullable&lt;T&gt;</code> 是另一种类型的智能指针，它可以指向一个值，或者在没有值的情况下为 <code>null</code>。它是在 Sierra 级别定义的。此类型主要用于字典，这些字典包含不实现 <code>Felt252DictValue&lt;T&gt;</code> trait 的 <code>zero_default</code> 方法的类型（即数组和结构体）。</p>
<p>如果我们尝试访问字典中不存在的元素，如果无法调用 <code>zero_default</code> 方法，代码将失败。</p>
<p>关于字典的 <a href="#dictionaries-of-types-not-supported-natively">第 {{#chap common-collections}} 章</a> 彻底解释了如何使用 <code>Nullable&lt;T&gt;</code> 类型在字典内存储 <code>Span&lt;felt252&gt;</code> 变量。更多信息请参考该章节。</p>
<p>{{#quiz ../quizzes/ch12-02-smart_pointers.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="解引用强制转换-deref-coercion"><a class="header" href="#解引用强制转换-deref-coercion">解引用强制转换 (Deref Coercion)</a></h1>
<p>解引用强制转换 (Deref coercion) 简化了我们要与嵌套或包装数据结构交互的方式，允许一种类型的实例像另一种类型的实例一样行动。这种机制通过实现 <code>Deref</code> trait 来启用，它允许隐式转换（或强制转换）为不同的类型，提供对底层数据的直接访问。</p>
<p>解引用强制转换通过 <code>Deref</code> 和 <code>DerefMut</code> traits 实现。当类型 <code>T</code> 实现了对类型 <code>K</code> 的 <code>Deref</code> 或 <code>DerefMut</code> 时，<code>T</code> 的实例可以直接访问 <code>K</code> 的成员。</p>
<p>Cairo 中的 <code>Deref</code> trait 定义如下：</p>
<pre><code class="language-cairo noplayground">pub trait Deref&lt;T&gt; {
    type Target;
    fn deref(self: T) -&gt; Self::Target;
}
</code></pre>
<p><code>Target</code> 类型指定了解引用的结果，<code>deref</code> 方法定义了如何将 <code>T</code> 转换为 <code>K</code>。</p>
<h2 id="使用解引用强制转换"><a class="header" href="#使用解引用强制转换">使用解引用强制转换</a></h2>
<p>为了更好地理解解引用强制转换是如何工作的，让我们看一个实际的例子。我们将创建一个围绕类型 <code>T</code> 的简单泛型包装器类型 <code>Wrapper&lt;T&gt;</code>，并使用它来包装一个 <code>UserProfile</code> 结构体。</p>
<pre><code class="language-cairo noplayground">#[derive(Drop, Copy)]
struct UserProfile {
    username: felt252,
    email: felt252,
    age: u16,
}

#[derive(Drop, Copy)]
struct Wrapper&lt;T&gt; {
    value: T,
}
</code></pre>
<p><code>Wrapper</code> 结构体包装了一个 <code>T</code> 类型的单个值泛型。为了简化对包装值的访问，我们为 <code>Wrapper&lt;T&gt;</code> 实现 <code>Deref</code> trait。</p>
<pre><code class="language-cairo noplayground">impl DerefWrapper&lt;T&gt; of Deref&lt;Wrapper&lt;T&gt;&gt; {
    type Target = T;
    fn deref(self: Wrapper&lt;T&gt;) -&gt; T {
        self.value
    }
}
</code></pre>
<p>这个实现非常简单。<code>deref</code> 方法返回包装的值，允许 <code>Wrapper&lt;T&gt;</code> 的实例直接访问 <code>T</code> 的成员。</p>
<p>在实践中，这种机制是完全透明的。以下示例演示了如何持有一个 <code>Wrapper&lt;UserProfile&gt;</code> 实例，我们可以打印底层 <code>UserProfile</code> 实例的 <code>username</code> 和 <code>age</code> 字段。</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let wrapped_profile = Wrapper {
        value: UserProfile { username: 'john_doe', email: 'john@example.com', age: 30 },
    };
    // Access fields directly via deref coercion
    println!("Username: {}", wrapped_profile.username);
    println!("Current age: {}", wrapped_profile.age);
}
</code></pre>
<h3 id="将解引用强制转换限制为可变变量"><a class="header" href="#将解引用强制转换限制为可变变量">将解引用强制转换限制为可变变量</a></h3>
<p>虽然 <code>Deref</code> 适用于可变和不可变变量，但 <code>DerefMut</code> 仅适用于可变变量。与名称可能暗示的相反，<code>DerefMut</code> 不提供对底层数据的可变访问。</p>
<pre><code class="language-cairo noplayground">impl DerefMutWrapper&lt;T, +Copy&lt;T&gt;&gt; of DerefMut&lt;Wrapper&lt;T&gt;&gt; {
    type Target = T;
    fn deref_mut(ref self: Wrapper&lt;T&gt;) -&gt; T {
        self.value
    }
}
</code></pre>
<p>如果你尝试在不可变变量上使用 <code>DerefMut</code>，编译器会抛出错误。这是一个例子：</p>
<pre><code class="language-cairo noplayground">fn error() {
    let wrapped_profile = Wrapper {
        value: UserProfile { username: 'john_doe', email: 'john@example.com', age: 30 },
    };
    // Uncommenting the next line will cause a compilation error
    println!("Username: {}", wrapped_profile.username);
}
</code></pre>
<p>编译此代码将导致以下错误：</p>
<pre><code class="language-plaintext">$ scarb build 
   Compiling no_listing_09_deref_coercion_example v0.1.0 (listings/ch12-advanced-features/no_listing_09_deref_mut_example/Scarb.toml)
error: Type "no_listing_09_deref_coercion_example::Wrapper::&lt;no_listing_09_deref_coercion_example::UserProfile&gt;" has no member "username"
 --&gt; listings/ch12-advanced-features/no_listing_09_deref_mut_example/src/lib.cairo:32:46
    println!("Username: {}", wrapped_profile.username);
                                             ^^^^^^^^

error: could not compile `no_listing_09_deref_coercion_example` due to previous error

</code></pre>
<p>为了使上述代码工作，我们需要将 <code>wrapped_profile</code> 定义为可变变量。</p>
<pre><code class="language-cairo noplayground">#[executable]
fn main() {
    let mut wrapped_profile = Wrapper {
        value: UserProfile { username: 'john_doe', email: 'john@example.com', age: 30 },
    };

    println!("Username: {}", wrapped_profile.username);
    println!("Current age: {}", wrapped_profile.age);
}
</code></pre>
<h2 id="通过解引用强制转换调用方法"><a class="header" href="#通过解引用强制转换调用方法">通过解引用强制转换调用方法</a></h2>
<p>除了访问成员外，解引用强制转换还允许直接在源类型实例上调用目标类型上定义的方法。让我们用一个例子来说明这一点：</p>
<pre><code class="language-cairo">struct MySource {
    pub data: u8,
}

struct MyTarget {
    pub data: u8,
}

#[generate_trait]
impl TargetImpl of TargetTrait {
    fn foo(self: MyTarget) -&gt; u8 {
        self.data
    }
}

impl SourceDeref of Deref&lt;MySource&gt; {
    type Target = MyTarget;
    fn deref(self: MySource) -&gt; MyTarget {
        MyTarget { data: self.data }
    }
}

#[executable]
fn main() {
    let source = MySource { data: 5 };
    // Thanks to the Deref impl, we can call foo directly on MySource
    let res = source.foo();
    assert!(res == 5);
}
</code></pre>
<p>在这个例子中，<code>MySource</code> 实现了解引用到 <code>MyTarget</code>。<code>MyTarget</code> 结构体有 trait <code>TargetTrait</code> 的实现 <code>TargetImpl</code>，该 trait 定义了一个方法 <code>foo</code>。因为 <code>MySource</code> 解引用到 <code>MyTarget</code>，我们可以直接在 <code>MySource</code> 的实例上调用 <code>foo</code> 方法，如 <code>main</code> 函数所示。</p>
<h2 id="总结-7"><a class="header" href="#总结-7">总结</a></h2>
<p>通过使用 <code>Deref</code> 和 <code>DerefMut</code> traits，我们可以透明地将一种类型转换为另一种类型，简化对嵌套或包装数据结构的访问，并启用对目标类型上定义的方法的调用。当使用泛型类型或构建需要轻松访问底层数据的抽象时，此功能特别有用，并且可以帮助减少样板代码。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="关联项-associated-items"><a class="header" href="#关联项-associated-items">关联项 (Associated Items)</a></h1>
<p><em>关联项 (Associated Items)</em> 是在 <a href="#cairo-中的-traits">traits</a> 中声明或在 <a href="#implementing-a-trait-on-a-type">implementations</a> 中定义的项。具体来说，有 <a href="#associated-functions">关联函数</a>（包括我们已经在 <a href="#方法语法">第 {{#chap using-structs-to-structure-related-data}} 章</a> 中介绍过的方法）、<a href="#associated-types">关联类型</a>、<a href="#associated-constants">关联常量</a> 和 <a href="#associated-implementations">关联实现</a>。</p>
<p>当关联项与实现逻辑相关时，它们很有用。例如，<code>Option</code> 上的 <code>is_some</code> 方法与 Options 本质相关，因此应该是关联的。</p>
<p>每种关联项都有两种形式：包含实际实现的定义和声明定义的签名的声明。</p>
<h2 id="关联类型-associated-types"><a class="header" href="#关联类型-associated-types">关联类型 (Associated Types)</a></h2>
<p>关联类型是 <em>类型别名</em>，允许你在 traits 中定义抽象类型占位符。关联类型允许 trait 实现者选择要使用的实际类型，而不是在 trait 定义中指定具体类型。</p>
<p>让我们考虑以下 <code>Pack</code> trait：</p>
<pre><code class="language-cairo noplayground">trait Pack&lt;T&gt; {
    type Result;

    fn pack(self: T, other: T) -&gt; Self::Result;
}
</code></pre>
<p>我们的 <code>Pack</code> trait 中的 <code>Result</code> 类型充当将在稍后填充的类型的占位符。将关联类型视为在 trait 中留出空白空间，以便每个实现写入其所需的特定类型。这种方法使你的 trait 定义保持整洁和灵活。当你使用 trait 时，你不需要担心指定这些类型 —— 它们已经由实现为你选择了。在我们的 <code>Pack</code> trait 中，类型 <code>Result</code> 就是这样一个占位符。方法的定义表明它将返回 <code>Self::Result</code> 类型的值，但它没有指定 <code>Result</code> 实际上是什么。这留给了 <code>Pack</code> trait 的实现者，他们将为 <code>Result</code> 指定具体类型。当调用 <code>pack</code> 方法时，它将返回该所选具体类型的值，无论它可能是什么。</p>
<p>让我们看看关联类型与更传统的泛型方法相比如何。假设我们需要一个函数 <code>foo</code>，它可以打包两个 <code>T</code> 类型的变量。如果没有关联类型，我们要定义一个 <code>PackGeneric</code> trait 和一个打包两个 <code>u32</code> 的实现，如下所示：</p>
<pre><code class="language-cairo noplayground">trait PackGeneric&lt;T, U&gt; {
    fn pack_generic(self: T, other: T) -&gt; U;
}

impl PackGenericU32 of PackGeneric&lt;u32, u64&gt; {
    fn pack_generic(self: u32, other: u32) -&gt; u64 {
        let shift: u64 = 0x100000000; // 2^32
        self.into() * shift + other.into()
    }
}
</code></pre>
<p>使用这种方法，<code>foo</code> 将实现为：</p>
<pre><code class="language-cairo noplayground">fn foo&lt;T, U, +PackGeneric&lt;T, U&gt;&gt;(self: T, other: T) -&gt; U {
    self.pack_generic(other)
}
</code></pre>
<p>注意 <code>foo</code> 如何需要同时指定 <code>T</code> 和 <code>U</code> 作为泛型参数。现在，让我们将其与具有关联类型的 <code>Pack</code> trait 进行比较：</p>
<pre><code class="language-cairo noplayground">impl PackU32Impl of Pack&lt;u32&gt; {
    type Result = u64;

    fn pack(self: u32, other: u32) -&gt; Self::Result {
        let shift: u64 = 0x100000000; // 2^32
        self.into() * shift + other.into()
    }
}
</code></pre>
<p>使用关联类型，我们可以更简洁地定义 <code>bar</code>：</p>
<pre><code class="language-cairo noplayground">fn bar&lt;T, impl PackImpl: Pack&lt;T&gt;&gt;(self: T, b: T) -&gt; PackImpl::Result {
    PackImpl::pack(self, b)
}
</code></pre>
<p>最后，让我们看看这两种方法的实际效果，证明最终结果是相同的：</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let a: u32 = 1;
    let b: u32 = 1;

    let x = foo(a, b);
    let y = bar(a, b);

    // result is 2^32 + 1
    println!("x: {}", x);
    println!("y: {}", y);
}
</code></pre>
<p>如你所见，<code>bar</code> 不需要为打包结果指定第二个泛型类型。此信息隐藏在 <code>Pack</code> trait 的实现中，使函数签名更清晰、更灵活。关联类型允许我们以更少的冗长表达相同的功能，同时仍然保持泛型编程的灵活性。</p>
<h2 id="关联常量-associated-constants"><a class="header" href="#关联常量-associated-constants">关联常量 (Associated Constants)</a></h2>
<p>关联常量是与类型关联的常量。它们使用 <code>const</code> 关键字在 trait 中声明，并在其实现中定义。在下一个示例中，我们要定义一个通用的 <code>Shape</code> trait，我们为 <code>Triangle</code> 和 <code>Square</code> 实现该 trait。此 trait 包含一个关联常量，定义实现该 trait 的类型的边数。</p>
<pre><code class="language-cairo noplayground">trait Shape&lt;T&gt; {
    const SIDES: u32;
    fn describe() -&gt; ByteArray;
}

struct Triangle {}

impl TriangleShape of Shape&lt;Triangle&gt; {
    const SIDES: u32 = 3;
    fn describe() -&gt; ByteArray {
        "I am a triangle."
    }
}

struct Square {}

impl SquareShape of Shape&lt;Square&gt; {
    const SIDES: u32 = 4;
    fn describe() -&gt; ByteArray {
        "I am a square."
    }
}
</code></pre>
<p>之后，我们创建一个 <code>print_shape_info</code> 泛型函数，它要求泛型参数实现 <code>Shape</code> trait。此函数将使用关联常量来检索几何图形的边数，并将其与其描述一起打印。</p>
<pre><code class="language-cairo noplayground">fn print_shape_info&lt;T, impl ShapeImpl: Shape&lt;T&gt;&gt;() {
    println!("I have {} sides. {}", ShapeImpl::SIDES, ShapeImpl::describe());
}
</code></pre>
<p>关联常量允许我们将常量数字绑定到 <code>Shape</code> trait，而不是将其添加到结构体中或仅在实现中硬编码该值。这种方法提供了几个好处：</p>
<ol>
<li>它使常量与 trait 紧密联系，改善了代码组织。</li>
<li>它允许进行编译时检查，以确保所有实现者都定义了所需的常量。</li>
<li>它确保同一类型的两个实例具有相同的边数。</li>
</ol>
<p>关联常量也可用于特定于类型的行为或配置，使其成为 trait 设计中的多功能工具。</p>
<p>我们要最终运行 <code>print_shape_info</code> 并查看 <code>Triangle</code> 和 <code>Square</code> 的输出：</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    print_shape_info::&lt;Triangle&gt;();
    print_shape_info::&lt;Square&gt;();
}
</code></pre>
<h2 id="关联实现-associated-implementations"><a class="header" href="#关联实现-associated-implementations">关联实现 (Associated Implementations)</a></h2>
<p>关联实现允许你声明必须为关联类型存在 trait 实现。当你想要在 trait 级别强制执行类型和实现之间的关系时，此功能特别有用。它确保了跨不同 trait 实现的类型安全和一致性，这在泛型编程上下文中很重要。</p>
<p>为了理解关联实现的实用性，让我们检查 Cairo 核心库中的 <code>Iterator</code> 和 <code>IntoIterator</code> traits，以及它们使用 <code>ArrayIter&lt;T&gt;</code> 作为集合类型的各自实现：</p>
<pre><code class="language-cairo noplayground">// Collection type that contains a simple array
#[derive(Drop)]
pub struct ArrayIter&lt;T&gt; {
    array: Array&lt;T&gt;,
}

// T is the collection type
pub trait Iterator&lt;T&gt; {
    type Item;
    fn next(ref self: T) -&gt; Option&lt;Self::Item&gt;;
}

impl ArrayIterator&lt;T&gt; of Iterator&lt;ArrayIter&lt;T&gt;&gt; {
    type Item = T;
    fn next(ref self: ArrayIter&lt;T&gt;) -&gt; Option&lt;T&gt; {
        self.array.pop_front()
    }
}

/// Turns a collection of values into an iterator
pub trait IntoIterator&lt;T&gt; {
    /// The iterator type that will be created
    type IntoIter;
    impl Iterator: Iterator&lt;Self::IntoIter&gt;;

    fn into_iter(self: T) -&gt; Self::IntoIter;
}

impl ArrayIntoIterator&lt;T&gt; of IntoIterator&lt;Array&lt;T&gt;&gt; {
    type IntoIter = ArrayIter&lt;T&gt;;
    fn into_iter(self: Array&lt;T&gt;) -&gt; ArrayIter&lt;T&gt; {
        ArrayIter { array: self }
    }
}
</code></pre>
<ol>
<li><code>IntoIterator</code> trait 旨在将集合转换为迭代器。</li>
<li><code>IntoIter</code> 关联类型表示将创建的特定迭代器类型。这允许不同的集合定义它们自己的高效迭代器类型。</li>
<li>关联实现 <code>Iterator: Iterator&lt;Self::IntoIter&gt;</code>（我们正在讨论的关键特性）声明此 <code>IntoIter</code> 类型必须实现 <code>Iterator</code> trait。</li>
<li>这种设计允许类型安全的迭代，而无需每次都显式指定迭代器类型，从而改善了代码的人体工程学。</li>
</ol>
<p>关联实现创建了一个 trait 级别的绑定，保证：</p>
<ul>
<li><code>into_iter</code> 方法将始终返回一个实现 <code>Iterator</code> 的类型。</li>
<li>这种关系对 <code>IntoIterator</code> 的所有实现强制执行，而不仅仅是逐个案例。</li>
</ul>
<p>以下 <code>main</code> 函数演示了这在实践中如何用于 <code>Array&lt;felt252&gt;</code>：</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let mut arr: Array&lt;felt252&gt; = array![1, 2, 3];

    // Converts the array into an iterator
    let mut iter = arr.into_iter();

    // Uses the iterator to print each element
    while let Some(item) = iter.next() {
        println!("Item: {}", item);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="运算符重载"><a class="header" href="#运算符重载">运算符重载</a></h1>
<p>运算符重载是一些编程语言中的一个特性，允许重新定义标准运算符，例如加法 (<code>+</code>)、减法 (<code>-</code>)、乘法 (<code>*</code>) 和除法 (<code>/</code>)，以便与用户定义的类型一起使用。这可以通过使对用户定义类型的操作能够以与对原始类型的操作相同的方式表达，从而使代码的语法更加直观。</p>
<p>在 Cairo 中，运算符重载是通过实现特定的 traits 来实现的。每个运算符都有一个关联的 trait，重载该运算符涉及为自定义类型提供该 trait 的实现。然而，必须明智地使用运算符重载。滥用会导致混乱，使代码更难维护，例如当被重载的运算符没有语义意义时。</p>
<p>考虑一个例子，其中需要组合两个 <code>Potion</code>（药水）。<code>Potion</code> 有两个数据字段，mana（法力值）和 health（生命值）。组合两个 <code>Potion</code> 应该将它们各自的字段相加。</p>
<pre><code class="language-cairo">struct Potion {
    health: felt252,
    mana: felt252,
}

impl PotionAdd of Add&lt;Potion&gt; {
    fn add(lhs: Potion, rhs: Potion) -&gt; Potion {
        Potion { health: lhs.health + rhs.health, mana: lhs.mana + rhs.mana }
    }
}

#[executable]
fn main() {
    let health_potion: Potion = Potion { health: 100, mana: 0 };
    let mana_potion: Potion = Potion { health: 0, mana: 100 };
    let super_potion: Potion = health_potion + mana_potion;
    // Both potions were combined with the `+` operator.
    assert!(super_potion.health == 100);
    assert!(super_potion.mana == 100);
}
</code></pre>
<p>在上面的代码中，我们为 <code>Potion</code> 类型实现了 <code>Add</code> trait。add 函数接受两个参数：<code>lhs</code> 和 <code>rhs</code>（左手边和右手边）。函数体返回一个新的 <code>Potion</code> 实例，其字段值是 <code>lhs</code> 和 <code>rhs</code> 的组合。</p>
<p>如示例所示，重载运算符需要指定被重载的具体类型。重载的泛型 trait 是 <code>Add&lt;T&gt;</code>，我们使用 <code>Add&lt;Potion&gt;</code> 为 <code>Potion</code> 类型定义了一个具体实现。</p>
<p>{{#quiz ../quizzes/ch12-03-operator-overloading.toml}}</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="哈希-hashes"><a class="header" href="#哈希-hashes">哈希 (Hashes)</a></h1>
<p>本质上，哈希是将任意长度的输入数据（通常称为消息）转换为固定大小值的过程，该值通常称为“哈希”。这种转换是确定性的，意味着相同的输入将始终产生相同的哈希值。哈希函数是包括数据存储、密码学和数据完整性验证在内的各个领域的基本组件。它们在开发智能合约时经常被使用，尤其是在使用 <a href="https://zh.wikipedia.org/wiki/Merkle树">Merkle 树</a> 时。</p>
<p>在本章中，我们将介绍 Cairo 核心库中原生实现的两个哈希函数：<code>Poseidon</code> 和 <code>Pedersen</code>。我们将讨论何时以及如何使用它们，并查看 Cairo 程序的示例。</p>
<h3 id="cairo-中的哈希函数"><a class="header" href="#cairo-中的哈希函数">Cairo 中的哈希函数</a></h3>
<p>Cairo 核心库提供了两个哈希函数：Pedersen 和 Poseidon。</p>
<p>Pedersen 哈希函数是依赖于 <a href="https://zh.wikipedia.org/wiki/椭圆曲线密码学">椭圆曲线密码学</a> 的加密算法。这些函数对椭圆曲线上的点执行操作 —— 本质上是对这些点的位置进行数学运算 —— 这些操作在一个方向上很容易做，但在很难撤消。这种单向难度基于椭圆曲线离散对数问题 (ECDLP)，这是一个非常难以解决的问题，从而保证了哈希函数的安全性。逆转这些操作的难度使得 Pedersen 哈希函数在加密目的上既安全又可靠。</p>
<p>Poseidon 是一族设计为作为代数电路非常高效的哈希函数。它的设计对于零知识证明系统（包括 STARKs，即 Cairo）特别高效。Poseidon 使用一种称为“海绵构造 (sponge construction)”的方法，该方法吸收数据并使用称为 Hades 排列的过程安全地转换数据。Cairo 版本的 Poseidon 基于具有 <a href="https://github.com/starkware-industries/poseidon/blob/main/poseidon3.txt">特定参数</a> 的三元素状态排列。</p>
<h4 id="何时使用它们"><a class="header" href="#何时使用它们">何时使用它们？</a></h4>
<p>Pedersen 是 Starknet 上使用的第一个哈希函数，并且仍然用于计算存储中变量的地址（例如，<code>LegacyMap</code> 使用 Pedersen 对 Starknet 上的存储映射的键进行哈希）。然而，由于 Poseidon 在使用 STARK 证明系统时比 Pedersen 更便宜、更快，它现在是 Cairo 程序中推荐使用的哈希函数。</p>
<h3 id="使用哈希"><a class="header" href="#使用哈希">使用哈希</a></h3>
<p>核心库使得使用哈希变得容易。<code>Hash</code> trait 为所有可以转换为 <code>felt252</code> 的类型实现，包括 <code>felt252</code> 本身。对于像结构体这样的更复杂类型，派生 <code>Hash</code> 允许使用你选择的哈希函数轻松地对它们进行哈希 —— 前提是结构体的所有字段本身都是可哈希的。你不能在包含不可哈希值的结构体上派生 <code>Hash</code> trait，例如 <code>Array&lt;T&gt;</code> 或 <code>Felt252Dict&lt;T&gt;</code>，即使 <code>T</code> 本身是可哈希的。</p>
<p><code>Hash</code> trait 伴随着 <code>HashStateTrait</code> 和 <code>HashStateExTrait</code>，它们定义了使用哈希的基本方法。它们允许你初始化一个哈希状态，该状态将在每次应用哈希函数后包含哈希的临时值，更新哈希状态，并在计算完成时将其定型。<code>HashStateTrait</code> 和 <code>HashStateExTrait</code> 定义如下：</p>
<pre><code class="language-cairo noplayground">/// A trait for hash state accumulators.
trait HashStateTrait&lt;S&gt; {
    fn update(self: S, value: felt252) -&gt; S;
    fn finalize(self: S) -&gt; felt252;
}

/// Extension trait for hash state accumulators.
trait HashStateExTrait&lt;S, T&gt; {
    /// Updates the hash state with the given value.
    fn update_with(self: S, value: T) -&gt; S;
}

/// A trait for values that can be hashed.
trait Hash&lt;T, S, +HashStateTrait&lt;S&gt;&gt; {
    /// Updates the hash state with the given value.
    fn update_state(state: S, value: T) -&gt; S;
}
</code></pre>
<p>要在你的代码中使用哈希，你必须首先导入相关的 traits 和函数。在以下示例中，我们将演示如何使用 Pedersen 和 Poseidon 哈希函数对结构体进行哈希。</p>
<p>第一步是用 <code>PoseidonTrait::new() -&gt; HashState</code> 或 <code>PedersenTrait::new(base: felt252) -&gt; HashState</code> 初始化哈希，具体取决于我们想要使用哪个哈希函数。然后可以使用 <code>update(self: HashState, value: felt252) -&gt; HashState</code> 或 <code>update_with(self: S, value: T) -&gt; S</code> 函数根据需要多次更新哈希状态。然后对哈希状态调用函数 <code>finalize(self: HashState) -&gt; felt252</code>，它将哈希值作为 <code>felt252</code> 返回。</p>
<pre><code class="language-cairo">use core::hash::{HashStateExTrait, HashStateTrait};
use core::poseidon::PoseidonTrait;

#[derive(Drop, Hash)]
struct StructForHash {
    first: felt252,
    second: felt252,
    third: (u32, u32),
    last: bool,
}

#[executable]
fn main() -&gt; felt252 {
    let struct_to_hash = StructForHash { first: 0, second: 1, third: (1, 2), last: false };

    let hash = PoseidonTrait::new().update_with(struct_to_hash).finalize();
    hash
}
</code></pre>
<p>Pedersen 与 Poseidon 不同，因为它从一个基本状态开始。这个基本状态必须是 <code>felt252</code> 类型，这迫使我们要么使用 <code>update_with</code> 方法用任意基本状态对结构体进行哈希，要么将结构体序列化为数组以循环遍历其所有字段并将元素哈希在一起。</p>
<p>这是一个 Pedersen 哈希的简短示例：</p>
<pre><code class="language-cairo">#[executable]
fn main() -&gt; (felt252, felt252) {
    let struct_to_hash = StructForHash { first: 0, second: 1, third: (1, 2), last: false };

    // hash1 is the result of hashing a struct with a base state of 0
    let hash1 = PedersenTrait::new(0).update_with(struct_to_hash).finalize();

    let mut serialized_struct: Array&lt;felt252&gt; = ArrayTrait::new();
    Serde::serialize(@struct_to_hash, ref serialized_struct);
    let first_element = serialized_struct.pop_front().unwrap();
    let mut state = PedersenTrait::new(first_element);

    for value in serialized_struct {
        state = state.update(value);
    }

    // hash2 is the result of hashing only the fields of the struct
    let hash2 = state.finalize();

    (hash1, hash2)
}
</code></pre>
<h3 id="高级哈希使用-poseidon-对数组进行哈希"><a class="header" href="#高级哈希使用-poseidon-对数组进行哈希">高级哈希：使用 Poseidon 对数组进行哈希</a></h3>
<p>让我们看一个对包含 <code>Span&lt;felt252&gt;</code> 的结构体进行哈希的例子。要对 <code>Span&lt;felt252&gt;</code> 或包含 <code>Span&lt;felt252&gt;</code> 的结构体进行哈希，你可以使用内置函数 <code>poseidon_hash_span(mut span: Span&lt;felt252&gt;) -&gt; felt252</code>。同样，你可以通过对其 span 调用 <code>poseidon_hash_span</code> 来对 <code>Array&lt;felt252&gt;</code> 进行哈希。</p>
<p>首先，让我们导入以下 traits 和函数：</p>
<pre><code class="language-cairo noplayground">use core::hash::{HashStateExTrait, HashStateTrait};
use core::poseidon::{PoseidonTrait, poseidon_hash_span};
</code></pre>
<p>现在我们定义结构体。正如你可能注意到的，我们没有派生 <code>Hash</code> trait。如果你尝试为此结构体派生 <code>Hash</code> trait，它将导致错误，因为该结构体包含不可哈希的字段。</p>
<pre><code class="language-cairo noplayground">#[derive(Drop)]
struct StructForHashArray {
    first: felt252,
    second: felt252,
    third: Array&lt;felt252&gt;,
}
</code></pre>
<p>在这个例子中，我们初始化了一个 <code>HashState</code> (<code>hash</code>)，更新了它，然后对 <code>HashState</code> 调用函数 <code>finalize()</code> 以获取计算出的哈希 <code>hash_felt252</code>。我们在 <code>Array&lt;felt252&gt;</code> 的 <code>Span</code> 上使用了 <code>poseidon_hash_span</code> 来计算其哈希值。</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let struct_to_hash = StructForHashArray { first: 0, second: 1, third: array![1, 2, 3, 4, 5] };

    let mut hash = PoseidonTrait::new().update(struct_to_hash.first).update(struct_to_hash.second);
    let hash_felt252 = hash.update(poseidon_hash_span(struct_to_hash.third.span())).finalize();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="宏-macros"><a class="header" href="#宏-macros">宏 (Macros)</a></h1>
<p>我们在本书中一直在使用像 <code>println!</code> 这样的宏，但我们还没有完全探索宏是什么以及它是如何工作的。术语 <em>宏 (macro)</em> 指的是 Cairo 中的一组特性：使用 <code>macro</code> 的 <em>声明式 (declarative)</em> 宏，以及在 <a href="#过程宏-procedural-macros">过程宏</a> 中介绍的三种 <em>过程 (procedural)</em> 宏：</p>
<ul>
<li>自定义 <code>#[derive]</code> 宏，指定在结构体和枚举上使用 <code>derive</code> 属性时添加的代码</li>
<li>属性类 (Attribute-like) 宏，定义可用于任何项的自定义属性</li>
<li>函数类 (Function-like) 宏，看起来像函数调用，但对作为其参数指定的标记 (tokens) 进行操作</li>
</ul>
<p>我们将依次讨论每一个，但首先，让我们看看当我们已经有了函数时为什么还需要宏。</p>
<h2 id="宏和函数之间的区别"><a class="header" href="#宏和函数之间的区别">宏和函数之间的区别</a></h2>
<p>从根本上说，宏是一种编写其他代码的代码的方式，这被称为 <em>元编程 (metaprogramming)</em>。在附录 C 中，我们讨论了可派生 traits 和 <code>derive</code> 属性，它为你生成各种 traits 的实现。我们在整本书中还使用了 <code>println!</code> 和 <code>array!</code> 宏。所有这些宏都会 <em>展开</em> 以生成比你手动编写的代码更多的代码。</p>
<p>元编程对于减少你需要编写和维护的代码量很有用，这也是函数的作用之一。然而，宏具有一些函数所没有的额外能力。</p>
<p>函数签名必须声明函数具有的参数的数量和类型。另一方面，宏可以接受可变数量的参数：我们可以用一个参数调用 <code>println!("hello")</code>，或者用两个参数调用 <code>println!("hello {}", name)</code>。此外，宏在编译器解释代码含义之前展开，因此宏可以，例如，在给定类型上实现 trait。函数不能，因为它在运行时被调用，而 trait 需要在编译时实现。</p>
<p>实现宏而不是函数的缺点是，宏定义比函数定义更复杂，因为你正在编写 Cairo 代码 —— 或者更复杂的 Rust 代码 —— 来编写 Cairo 代码。由于这种间接性，宏定义通常比函数定义更难阅读、理解和维护。</p>
<p>宏和函数之间的另一个重要区别是，你必须在文件中调用宏 <em>之前</em> 定义宏或将它们引入作用域，而函数可以在任何地方定义并在任何地方调用。</p>
<h2 id="用于通用元编程的声明式内联宏"><a class="header" href="#用于通用元编程的声明式内联宏">用于通用元编程的声明式内联宏</a></h2>
<p>Cairo 中最简单的宏形式是 <em>声明式宏 (declarative macro)</em>，有时也简称为“宏”。在其核心，声明式宏允许你编写类似于 <code>match</code> 表达式的东西。如 <a href="#枚举和模式匹配">第 6 章</a> 所述，<code>match</code> 表达式是控制结构，它接受一个表达式，将表达式的结果值与模式进行比较，然后运行与匹配模式关联的代码。宏也将值与关联特定代码的模式进行比较：在这种情况下，值是传递给宏的文字 Cairo 源代码；模式与该源代码的结构进行比较；当匹配时，与每个模式关联的代码替换传递给宏的代码。这一切都发生在编译期间。</p>
<p>要定义宏，你使用 <code>macro</code> 构造。让我们通过查看“数组构建”宏的工作原理来探索这种风格。之前，我们使用 Cairo 内置的 <code>array!</code> 宏来创建具有特定值的数组。例如，以下代码创建一个包含三个整数的新数组：</p>
<pre><code class="language-cairo">let a = array![1, 2, 3];
</code></pre>
<p>我们也可以使用 <code>array!</code> 制作两个整数的数组或五个其他类型值的数组，因为宏可以接受可变数量的参数。我们无法使用常规函数做同样的事情，因为我们无法预先知道值的数量或类型。</p>
<p>下面是用 Cairo 编写的数组构建宏的稍微简化的定义。它不是核心库中的确切 <code>array!</code> 宏，但它展示了使用声明式内联宏的相同核心思想：</p>
<pre><code class="language-cairo">macro make_array {
    ($($x:expr), *) =&gt; {
        {
            let mut arr = $defsite::ArrayTrait::new();
            $(arr.append($x);)*
            arr
        }
    };
}
</code></pre>
<blockquote>
<p>注意：标准库中的内置 <code>array!</code> 宏可能包含优化（如预留容量），我们为了保持示例简单而没有包含这些优化。</p>
</blockquote>
<p>宏主体的结构类似于 <code>match</code> 表达式。这里我们有一个带有模式 <code>($($x:expr), *)</code> 的分支，后面跟着 <code>=&gt;</code> 和与此模式关联的代码块。如果模式匹配，则发出关联的代码块。更复杂的宏可以有多个分支，每个分支都有不同的模式。</p>
<p>宏定义中的模式语法与匹配值时使用的模式语法不同：宏模式与 Cairo 源代码结构进行匹配。让我们以此为例，逐步了解模式的各个部分：</p>
<ul>
<li>我们使用括号来包含整个匹配器模式。</li>
<li>美元符号 (<code>$</code>) 引入一个宏变量，它将捕获与子模式匹配的代码。在 <code>$()</code> 内是 <code>$x:expr</code>，它匹配任何 Cairo 表达式并将该表达式命名为 <code>$x</code>。</li>
<li>跟随 <code>$()</code> 的逗号要求每个匹配表达式之间有文字逗号。</li>
<li><code>*</code> 量词指定子模式可以重复零次或多次。</li>
</ul>
<p>当我们用 <code>make_array![1, 2, 3]</code> 调用此宏时，<code>$x</code> 模式匹配三次：表达式 <code>1</code>、<code>2</code> 和 <code>3</code>。</p>
<p>现在看展开方面：<code>$(arr.append($x);)*</code> 对模式中 <code>$()</code> 的每次匹配生成一次。<code>$x</code> 被替换为每个匹配的表达式。调用 <code>make_array![1, 2, 3]</code> 展开为如下代码：</p>
<blockquote>
<p>注意：VSCode 扩展可以通过按 <code>Ctrl+Shift+P</code> 然后选择 <code>Cairo: Recursively expand macros for item at caret</code> 来帮助你检查展开的代码。</p>
</blockquote>
<pre><code class="language-cairo ignore">{
    let mut arr = ArrayTrait::new();
    arr.append(1);
    arr.append(2);
    arr.append(3);
    arr
}
</code></pre>
<p>我们定义了一个宏，它可以接受任意数量、任意类型的参数，并生成代码来创建包含指定元素的数组。</p>
<p>用法如下所示：</p>
<pre><code class="language-cairo">    let a = make_array![1, 2, 3];
</code></pre>
<p>要使用它们，请在你的 <code>Scarb.toml</code> 中启用实验性功能：</p>
<pre><code class="language-toml">&lt;!-- Warning: Anchor 'feature_flag' not found in Scarb.toml --&gt;
</code></pre>
<p>内联宏是用 <code>macro name { ... }</code> 定义的，其中每个分支匹配一个代码模式并展开为替换代码。像 Rust 的 macros-by-example 一样，你可以用 <code>$var: kind</code> 捕获语法片段，并用 <code>$()*</code>、<code>$()+</code> 或 <code>$()?</code> 重复匹配。</p>
<h3 id="卫生-hygienedefsitecallsite-和-expose"><a class="header" href="#卫生-hygienedefsitecallsite-和-expose">卫生 (Hygiene)、<code>$defsite</code>/<code>$callsite</code> 和 <code>expose!</code></a></h3>
<p>Cairo 的内联宏是卫生的：宏定义中引入的名称不会泄漏到调用点，除非你显式地暴露它们。宏内的名称解析可以使用 <code>$defsite::</code> 和 <code>$callsite::</code> 引用宏定义点或调用点。</p>
<p>注意，与 Rust 类似，宏预期展开为单个表达式；因此，如果你的宏定义了多个语句，你应该将它们包装在一个额外的 <code>{}</code> 块中，该块返回最终表达式。</p>
<p>以下端到端示例说明了所有这些方面：</p>
<pre><code class="language-cairo">mod hygiene_demo {
    // A helper available at the macro definition site
    fn def_bonus() -&gt; u8 {
        10
    }

    // Adds the defsite bonus, regardless of what exists at the callsite
    pub macro add_defsite_bonus {
        ($x: expr) =&gt; { $x + $defsite::def_bonus() };
    }

    // Adds the callsite bonus, resolved where the macro is invoked
    pub macro add_callsite_bonus {
        ($x: expr) =&gt; { $x + $callsite::bonus() };
    }

    // Exposes a variable to the callsite using `expose!`.
    pub macro apply_and_expose_total {
        ($base: expr) =&gt; {
            let total = $base + 1;
            expose!(let exposed_total = total;);
        };
    }

    // A helper macro that reads a callsite-exposed variable
    pub macro read_exposed_total {
        () =&gt; { $callsite::exposed_total };
    }

    // Wraps apply_and_expose_total and then uses another inline macro
    // that accesses the exposed variable via `$callsite::...`.
    pub macro wrapper_uses_exposed {
        ($x: expr) =&gt; {
            {
                $defsite::apply_and_expose_total!($x);
                $defsite::read_exposed_total!()
            }
        };
    }
}
</code></pre>
<p>调用点的用法：</p>
<pre><code class="language-cairo">
    // Callsite defines its own `bonus` — used only by callsite-resolving macro
    let bonus = | | -&gt; u8 {
        20
    };
    let price: u8 = 5;
    assert_eq!(add_defsite_bonus!(price), 15); // uses defsite::def_bonus() = 10
    assert_eq!(add_callsite_bonus!(price), 25); // uses callsite::bonus() = 20

    // Call in statement position; it exposes `exposed_total` at the callsite
    apply_and_expose_total!(3);
    assert_eq!(exposed_total, 4);

    // A macro invoked by another macro can access exposed values via `$callsite::...`
    let w = wrapper_uses_exposed!(7);
    assert_eq!(w, 8);
</code></pre>
<p>这演示了什么：</p>
<ul>
<li><code>$defsite::...</code> 解析为宏定义旁边的项，并在调用点之间保持稳定。</li>
<li><code>$callsite::...</code> 解析为在调用宏的地方可见的项。</li>
<li>默认情况下名称不会泄漏；<code>expose!</code> 可以故意将新项引入调用点。</li>
<li>暴露的名称可以通过 <code>$callsite::name</code> 访问你的宏主体内调用的其他内联宏。</li>
</ul>
<p>注意：</p>
<ul>
<li>此功能是实验性的；语法和功能可能会发生变化。</li>
<li>尚未支持产生项的宏（结构体、枚举、函数等）；支持将在未来版本中添加。</li>
<li>对于属性、派生和 crate 范围的转换，请首选过程宏（下一节）。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="过程宏-procedural-macros"><a class="header" href="#过程宏-procedural-macros">过程宏 (Procedural Macros)</a></h1>
<p>Cairo 提供了宏作为一项基本功能，让你能够编写生成其他代码的代码（称为元编程）。当你使用宏时，你可以将 Cairo 的能力扩展到常规函数所能提供的范围之外。在整本书中，我们要使用了像 <code>println!</code> 和 <code>assert!</code> 这样的宏，但还没有完全探索如何创建我们自己的宏。</p>
<p>在深入研究过程宏之前，让我们了解一下当我们已经有了函数时为什么还需要宏：</p>
<blockquote>
<p>提示：对于许多表达式级用例，首选直接用 Cairo 编写的声明式内联宏（参见 <a href="#declarative-inline-macros-for-general-metaprogramming">宏 → 通用元编程的声明式内联宏</a>）。
当你需要属性/派生或跨项操作或需要 Rust 侧逻辑的高级转换时，请使用过程宏。</p>
</blockquote>
<h2 id="cairo-过程宏是-rust-函数"><a class="header" href="#cairo-过程宏是-rust-函数">Cairo 过程宏是 Rust 函数</a></h2>
<p>就像 Cairo 编译器是用 Rust 编写的一样，过程宏是转换 Cairo 代码的 Rust 函数。这些函数接受 Cairo 代码作为输入，并返回修改后的 Cairo 代码作为输出。要实现宏，你需要一个同时具有 <code>Cargo.toml</code> 和 <code>Scarb.toml</code> 文件的包。<code>Cargo.toml</code> 定义宏实现依赖项，而 <code>Scarb.toml</code> 将包标记为宏并定义其元数据。</p>
<p>定义过程宏的函数对两个关键类型进行操作：</p>
<ul>
<li><code>TokenStream</code>: 代表你的源代码的 Cairo 标记序列。标记是编译器识别的最小代码单元（如标识符、关键字和运算符）。</li>
<li><code>ProcMacroResult</code>: <code>TokenStream</code> 的增强版本，包括生成的代码和应该在编译期间向用户显示的任何诊断消息（警告或错误）。</li>
</ul>
<p>实现宏的函数必须用三个特殊属性之一进行装饰，这些属性告诉编译器应该如何使用宏：</p>
<ul>
<li><code>#[inline_macro]</code>: 用于看起来像函数调用的宏（例如 <code>println!()</code>）</li>
<li><code>#[attribute_macro]</code>: 用于充当属性的宏（例如 <code>#[generate_trait]</code>）</li>
<li><code>#[derive_macro]</code>: 用于自动实现 traits 的宏</li>
</ul>
<p>每个属性类型对应于不同的用例，并影响宏如何在你的代码中被调用。</p>
<p>以下是每种类型的签名：</p>
<pre><code class="language-rust ignore">#[inline_macro]
pub fn inline(code: TokenStream) -&gt; ProcMacroResult {}

#[attribute_macro]
pub fn attribute(attr: TokenStream, code: TokenStream) -&gt; ProcMacroResult {}

#[derive_macro]
pub fn derive(code: TokenStream) -&gt; ProcMacroResult {}</code></pre>
<h3 id="安装依赖"><a class="header" href="#安装依赖">安装依赖</a></h3>
<p>要使用过程宏，你需要在机器上安装 Rust 工具链 (Cargo)。要使用 Rustup 安装 Rust，你可以在终端中运行以下命令：</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<h2 id="创建你的宏"><a class="header" href="#创建你的宏">创建你的宏</a></h2>
<p>创建过程宏需要设置特定的项目结构。你的宏项目需要：</p>
<ol>
<li>
<p>一个 Rust 项目（你在其中实现宏）：</p>
<ul>
<li><code>Cargo.toml</code>: 定义 Rust 依赖项和构建设置</li>
<li><code>src/lib.rs</code>: 包含宏实现</li>
</ul>
</li>
<li>
<p>一个 Cairo 项目：</p>
<ul>
<li><code>Scarb.toml</code>: 为 Cairo 项目声明宏</li>
<li>不需要 Cairo 源文件</li>
</ul>
</li>
</ol>
<p>让我们逐步了解每个组件并理解其作用：</p>
<pre><code class="language-bash">├── Cargo.toml
├── Scarb.toml
├── src
│   └── lib.rs
</code></pre>
<p>项目根目录包含 <code>Scarb.toml</code> 和 <code>Cargo.toml</code> 文件。</p>
<p>Cargo 清单文件需要在 <code>[lib]</code> 目标上包含 <code>crate-type = ["cdylib"]</code>，并在 <code>[dependencies]</code> 目标上包含 <code>cairo-lang-macro</code> crate。这是一个例子：</p>
<pre><code class="language-toml">[package]
name = "pow"
version = "0.1.0"
edition = "2021"
publish = false

[lib]
crate-type = ["cdylib"]

[dependencies]
bigdecimal = "0.4.5"
cairo-lang-macro = "0.1.1"
cairo-lang-parser = "2.13.1"
cairo-lang-syntax = "2.13.1"

[workspace]
</code></pre>
<p>Scarb 清单文件必须定义 <code>[cairo-plugin]</code> 目标类型。这是一个例子：</p>
<pre><code class="language-toml">[package]
name = "pow"
version = "0.1.0"

[cairo-plugin]
</code></pre>
<p>最后，项目需要包含一个 Rust 库 (<code>lib.rs</code>)，在 <code>src/</code> 目录下实现过程宏 API。</p>
<p>正如你可能注意到的，该项目不需要任何 cairo 代码，它只需要提到的 <code>Scarb.toml</code> 清单文件。</p>
<h2 id="使用你的宏"><a class="header" href="#使用你的宏">使用你的宏</a></h2>
<p>从用户的角度来看，你只需要在依赖项中添加定义宏的包。在使用宏的项目中，你的 Scarb 清单文件将包含：</p>
<pre><code class="language-toml">[package]
name = "no_listing_15_procedural_macro"
version = "0.1.0"
edition = "2024_07"

# See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html

[dependencies]
cairo_execute = "2.13.1"
pow = { path = "../no_listing_16_procedural_macro_expression" }
hello_macro = { path = "../no_listing_17_procedural_macro_derive" }
rename_macro = { path = "../no_listing_18_procedural_macro_attribute" }


[dev-dependencies]
cairo_test = "2.13.1"

[cairo]
enable-gas = false


[[target.executable]]
name = "main"
function = "no_listing_15_procedural_macro::main"
</code></pre>
<h2 id="表达式宏-expression-macros"><a class="header" href="#表达式宏-expression-macros">表达式宏 (Expression Macros)</a></h2>
<p>注意：如果你的目标是生成或转换表达式和小块，前面介绍的内联声明式宏更易于编写和维护。当你特别需要 Rust 驱动的解析或当你的宏逻辑位于 Cairo 之外时，请使用过程表达式宏。作为一个具体的例子，让我们看一个作为过程宏实现的编译时幂函数。</p>
<h3 id="创建表达式宏"><a class="header" href="#创建表达式宏">创建表达式宏</a></h3>
<p>为了理解如何创建表达式宏，我们将查看来自 <a href="https://github.com/keep-starknet-strange/alexandria">Alexandria</a> 库的 <code>pow</code> 宏实现，它在编译时计算数字的幂。</p>
<p>宏实现的核心代码是使用三个 Rust crates 的 Rust 代码：特定于宏实现的 <code>cairo_lang_macro</code>，具有与编译器解析器相关功能的 <code>cairo_lang_parser</code> crate，以及与编译器语法相关的 <code>cairo_lang_syntax</code>。后两者最初是为 Cairo 语言编译器创建的，由于宏函数在 Cairo 语法级别操作，我们可以直接重用为编译器创建的语法函数中的逻辑来创建宏。</p>
<blockquote>
<p><strong>注意：</strong> 要更好地理解 Cairo 编译器以及我们这里仅提到的一些概念（如 Cairo 解析器或 Cairo 语法），你可以阅读 <a href="https://github.com/software-mansion-labs/cairo-compiler-workshop">Cairo 编译器研讨会</a>。</p>
</blockquote>
<p>在下面的 <code>pow</code> 函数示例中，处理输入以提取底数参数和指数参数的值，以返回 \(base^{exponent}\) 的结果。</p>
<pre><code class="language-rust noplayground">use bigdecimal::{num_traits::pow, BigDecimal};
use cairo_lang_macro::{inline_macro, Diagnostic, ProcMacroResult, TokenStream};
use cairo_lang_parser::utils::SimpleParserDatabase;

#[inline_macro]
pub fn pow(token_stream: TokenStream) -&gt; ProcMacroResult {
    let db = SimpleParserDatabase::default();
    let (parsed, _diag) = db.parse_virtual_with_diagnostics(token_stream);

    // extracting the args from the parsed input
    let macro_args: Vec&lt;String&gt; = parsed
        .descendants(&amp;db)
        .next()
        .unwrap()
        .get_text(&amp;db)
        .trim_matches(|c| c == '(' || c == ')')
        .split(',')
        .map(|s| s.trim().to_string())
        .collect();

    if macro_args.len() != 2 {
        return ProcMacroResult::new(TokenStream::empty()).with_diagnostics(
            Diagnostic::error(format!("Expected two arguments, got {:?}", macro_args)).into(),
        );
    }

    // getting the value from the base arg
    let base: BigDecimal = match macro_args[0].parse() {
        Ok(val) =&gt; val,
        Err(_) =&gt; {
            return ProcMacroResult::new(TokenStream::empty())
                .with_diagnostics(Diagnostic::error("Invalid base value").into());
        }
    };

    // getting the value from the exponent arg
    let exp: usize = match macro_args[1].parse() {
        Ok(val) =&gt; val,
        Err(_) =&gt; {
            return ProcMacroResult::new(TokenStream::empty())
                .with_diagnostics(Diagnostic::error("Invalid exponent value").into());
        }
    };

    // base^exp
    let result: BigDecimal = pow(base, exp);

    ProcMacroResult::new(TokenStream::new(result.to_string()))
}</code></pre>
<p>现在宏已定义，我们可以使用它了。在 Cairo 项目中，我们需要在 <code>Scarb.toml</code> 清单文件的 <code>[dependencies]</code> 目标中有 <code>pow = { path = "path/to/pow" }</code>。然后我们可以像这样无需进一步导入即可使用它：</p>
<pre><code class="language-cairo">    let res = pow!(10, 2);
    println!("res : {}", res);
</code></pre>
<h2 id="派生宏-derive-macros"><a class="header" href="#派生宏-derive-macros">派生宏 (Derive Macros)</a></h2>
<p>派生宏允许你定义可以自动应用于类型的自定义 trait 实现。当你用 <code>#[derive(TraitName)]</code> 注释类型时，你的派生宏：</p>
<ol>
<li>接收类型的结构作为输入</li>
<li>包含你生成 trait 实现的自定义逻辑</li>
<li>输出将包含在 crate 中的实现代码</li>
</ol>
<p>编写派生宏通过使用关于如何生成 trait 实现的通用逻辑消除了重复的 trait 实现代码。</p>
<h3 id="创建派生宏"><a class="header" href="#创建派生宏">创建派生宏</a></h3>
<p>在这个例子中，我们将实现一个派生宏，它将实现 <code>Hello</code> Trait。<code>Hello</code> trait 将有一个 <code>hello()</code> 函数，它将打印：<code>Hello, StructName!</code>，其中 <em>StructName</em> 是结构体的名称。</p>
<p>这是 <code>Hello</code> trait 的定义：</p>
<pre><code class="language-cairo">trait Hello&lt;T&gt; {
    fn hello(self: @T);
}
</code></pre>
<p>让我们检查宏实现，首先 <code>hello_derive</code> 函数解析输入标记流，然后提取 <code>struct_name</code> 以为该特定结构体实现 trait。</p>
<p>然后 hello derived 返回一段硬编码的代码，其中包含类型 <em>StructName</em> 的 <code>Hello</code> trait 的实现。</p>
<pre><code class="language-rust noplayground">use cairo_lang_macro::{derive_macro, ProcMacroResult, TokenStream};
use cairo_lang_parser::utils::SimpleParserDatabase;
use cairo_lang_syntax::node::kind::SyntaxKind::{TerminalStruct, TokenIdentifier};

#[derive_macro]
pub fn hello_macro(token_stream: TokenStream) -&gt; ProcMacroResult {
    let db = SimpleParserDatabase::default();
    let (parsed, _diag) = db.parse_virtual_with_diagnostics(token_stream);
    let mut nodes = parsed.descendants(&amp;db);

    let mut struct_name = String::new();
    for node in nodes.by_ref() {
        if node.kind(&amp;db) == TerminalStruct {
            struct_name = nodes
                .find(|node| node.kind(&amp;db) == TokenIdentifier)
                .unwrap()
                .get_text(&amp;db)
                .to_string();
            break;
        }
    }

    ProcMacroResult::new(TokenStream::new(indoc::formatdoc! {r#"
            impl SomeHelloImpl of Hello&lt;{0}&gt; {{
                fn hello(self: @{0}) {{
                    println!("Hello {0}!");
                }}
            }}
        "#, struct_name}))
}</code></pre>
<p>现在宏已定义，我们可以使用它了。在 Cairo 项目中，我们需要在 <code>Scarb.toml</code> 清单文件的 <code>[dependencies]</code> 目标中有 <code>hello_macro = { path = "path/to/hello_macro" }</code>。然后我们可以在任何结构体上无需进一步导入即可使用它：</p>
<pre><code class="language-cairo noplayground">#[derive(HelloMacro, Drop, Destruct)]
struct SomeType {}
</code></pre>
<p>现在我们可以对 <code>SomeType</code> 类型的变量调用已实现的函数 <code>hello</code>。</p>
<pre><code class="language-cairo noplayground">    let a = SomeType {};
    a.hello();
</code></pre>
<p>注意，宏中实现的 <code>Hello</code> trait 必须在代码中的某处定义或导入。</p>
<h2 id="属性宏-attribute-macros"><a class="header" href="#属性宏-attribute-macros">属性宏 (Attribute Macros)</a></h2>
<p>属性类宏类似于自定义派生宏，但允许更多的可能性，它们不限于结构体和枚举，也可以应用于其他项，例如函数。它们可用于比实现 trait 更通过的代码生成。它可用于修改结构体的名称、在他机构中添加字段、在函数之前执行某些代码、更改函数的签名以及许多其他可能性。</p>
<p>额外的可能性也来自于它们是用第二个参数 <code>TokenStream</code> 定义的这一事实，实际上签名看起来像这样：</p>
<pre><code class="language-rust noplayground">#[attribute_macro]
pub fn attribute(attr: TokenStream, code: TokenStream) -&gt; ProcMacroResult {}</code></pre>
<p>第一个参数 (<code>attr</code>) 用于属性参数 (#[macro(arguments)])，第二个参数用于应用属性的实际代码，第二个参数是其他两个宏所拥有的唯一参数。</p>
<h3 id="创建属性宏"><a class="header" href="#创建属性宏">创建属性宏</a></h3>
<p>现在让我们看一个自定义属性宏的例子，在这个例子中我们将创建一个重命名结构体的宏。</p>
<pre><code class="language-rust noplayground">use cairo_lang_macro::attribute_macro;
use cairo_lang_macro::{ProcMacroResult, TokenStream};

#[attribute_macro]
pub fn rename(_attr: TokenStream, token_stream: TokenStream) -&gt; ProcMacroResult {
    ProcMacroResult::new(TokenStream::new(
        token_stream
            .to_string()
            .replace("struct OldType", "#[derive(Drop)]\n struct RenamedType"),
    ))
}</code></pre>
<p>同样，要在 Cairo 项目中使用该宏，我们需要在 <code>Scarb.toml</code> 清单文件的 <code>[dependencies]</code> 目标中有 <code>rename_macro = { path = "path/to/rename_macro" }</code>。然后我们可以在任何结构体上无需进一步导入即可使用它。</p>
<p>重命名宏可以如下派生：</p>
<pre><code class="language-cairo">#[rename]
struct OldType {}
</code></pre>
<p>现在编译器知道了 <em>RenamedType</em> 结构体，因此我们可以像这样创建一个实例：</p>
<pre><code class="language-cairo">    let _a = RenamedType {};
</code></pre>
<p>你可以注意到 <em>OldType</em> 和 <em>RenamedType</em> 的名称在示例中是硬编码的，但可以是利用属性宏第二个参数的变量。另请注意，由于编译顺序的原因，其他宏（如这里的 <em>Drop</em>）的派生必须在宏生成的代码中完成。创建自定义宏可能需要对 Cairo 编译有更深入的了解。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cairo-中的内联-inlining"><a class="header" href="#cairo-中的内联-inlining">Cairo 中的内联 (Inlining)</a></h1>
<p>内联是大多数编译器支持的一种常见的代码优化技术。它涉及用被调用函数的实际代码替换调用点处的函数调用，从而消除与函数调用本身相关的开销。这可以通过减少执行的指令数量来提高性能，但可能会增加程序的总大小。每当你考虑是否内联函数时，请考虑它的大小、它有什么参数、它被调用的频率以及它可能如何影响编译代码的大小等因素。</p>
<h2 id="inline-属性"><a class="header" href="#inline-属性"><code>inline</code> 属性</a></h2>
<p>在 Cairo 中，<code>inline</code> 属性建议是否应将归属于该函数的 Sierra 代码直接注入调用者函数的上下文中，而不是使用 <code>function_call</code> libfunc 来执行该代码。</p>
<p>你可以使用 <code>inline</code> 属性的三种变体：</p>
<ul>
<li><code>#[inline]</code> 建议执行内联展开。</li>
<li><code>#[inline(always)]</code> 建议总是执行内联展开。</li>
<li><code>#[inline(never)]</code> 建议从不执行内联展开。</li>
</ul>
<blockquote>
<p>注意：每种形式的 <code>inline</code> 属性都是一个提示，语言不要求将归属函数的副本放置在调用者中。这意味着编译器可能会忽略该属性。实际上，<code>#[inline(always)]</code> 会在除最例外的情况外的所有情况下导致内联。</p>
</blockquote>
<p>许多 Cairo corelib 函数都是内联的。用户定义的函数也可以用 <code>inline</code> 属性进行注释。用 <code>#[inline(always)]</code> 属性注释函数可以减少调用这些归属函数时所需的总步骤数。实际上，在调用者站点注入 Sierra 代码避免了调用函数和获取其参数所涉及的步骤成本。</p>
<p>然而，内联也会导致代码大小增加。每当一个函数被内联时，调用点都包含该函数的 Sierra 代码的副本，这可能导致编译代码中的代码重复。</p>
<p>因此，应谨慎应用内联。不加选择地使用 <code>#[inline]</code> 或 <code>#[inline(always)]</code> 会导致编译时间增加。内联小函数特别有用，最好是带有许多参数的函数。这是因为内联大函数会增加程序的代码长度，而处理许多参数会增加执行这些函数的步骤数。</p>
<p>函数被调用的频率越高，内联在性能方面就越有利。通过这样做，执行的步骤数将更少，而代码长度不会增长那么多，甚至在指令总数方面可能会减少。</p>
<blockquote>
<p>内联通​​常是步骤数和代码长度之间的权衡。在适当的地方谨慎使用 <code>inline</code> 属性。</p>
</blockquote>
<h2 id="内联决策过程"><a class="header" href="#内联决策过程">内联决策过程</a></h2>
<p>Cairo 编译器遵循 <code>inline</code> 属性，但对于没有显式内联指令的函数，它将使用一种启发式方法。是否内联函数的决定将取决于归属函数的复杂性，并且主要依赖于阈值 <code>DEFAULT_INLINE_SMALL_FUNCTIONS_THRESHOLD</code>。</p>
<p>编译器使用 <code>ApproxCasmInlineWeight</code> 结构体计算函数的“权重”，该结构体估计函数将生成的 Cairo 汇编 (CASM) 语句的数量。这种权重计算提供了比简单的语句计数更细致的函数复杂性视图。如果函数的权重低于阈值，它将被内联。</p>
<p>除了基于权重的方法外，编译器还考虑原始语句计数。语句数少于阈值的函数通常会被内联，从而促进小的、经常调用的函数的优化。</p>
<p>内联过程还考虑了特殊情况。非常简单的函数，例如仅调用另一个函数或返回常量的函数，无论其他因素如何，总是被内联。相反，具有复杂控制流结构（如 <code>Match</code>）或以 <code>Panic</code> 结尾的函数通常不被内联。</p>
<h2 id="内联示例"><a class="header" href="#内联示例">内联示例</a></h2>
<p>让我们介绍一个简短的示例来说明 Cairo 中内联的机制。清单 {{#ref inlining}} 显示了一个基本程序，允许比较内联和非内联函数。</p>
<pre><code class="language-cairo">#[executable]
fn main() -&gt; felt252 {
    inlined() + not_inlined()
}

#[inline(always)]
fn inlined() -&gt; felt252 {
    1
}

#[inline(never)]
fn not_inlined() -&gt; felt252 {
    2
}
</code></pre>
<p>{{#label inlining}} <span class="caption">清单 {{#ref inlining}}: 一个小的 Cairo 程序，它添加 2 个函数的返回值，其中一个被内联</span></p>
<p>让我们看看相应的 Sierra 代码，看看内联在底层是如何工作的：</p>
<pre><code class="language-cairo noplayground">// type declarations
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false]

// libfunc declarations
libfunc function_call&lt;user@main::main::not_inlined&gt; = function_call&lt;user@main::main::not_inlined&gt;
libfunc felt252_const&lt;1&gt; = felt252_const&lt;1&gt;
libfunc store_temp&lt;felt252&gt; = store_temp&lt;felt252&gt;
libfunc felt252_add = felt252_add
libfunc felt252_const&lt;2&gt; = felt252_const&lt;2&gt;

// statements
00 function_call&lt;user@main::main::not_inlined&gt;() -&gt; ([0])
01 felt252_const&lt;1&gt;() -&gt; ([1])
02 store_temp&lt;felt252&gt;([1]) -&gt; ([1])
03 felt252_add([1], [0]) -&gt; ([2])
04 store_temp&lt;felt252&gt;([2]) -&gt; ([2])
05 return([2])
06 felt252_const&lt;1&gt;() -&gt; ([0])
07 store_temp&lt;felt252&gt;([0]) -&gt; ([0])
08 return([0])
09 felt252_const&lt;2&gt;() -&gt; ([0])
10 store_temp&lt;felt252&gt;([0]) -&gt; ([0])
11 return([0])

// funcs
main::main::main@0() -&gt; (felt252)
main::main::inlined@6() -&gt; (felt252)
main::main::not_inlined@9() -&gt; (felt252)
</code></pre>
<p>Sierra 文件结构分为三个部分：</p>
<ul>
<li>类型和 libfunc 声明。</li>
<li>构成程序的语句。</li>
<li>程序函数的声明。</li>
</ul>
<p>Sierra 代码语句总是与 Cairo 程序中函数声明的顺序相匹配。实际上，程序函数的声明告诉我们：</p>
<ul>
<li><code>main</code> 函数从第 0 行开始，并在第 5 行返回一个 <code>felt252</code>。</li>
<li><code>inlined</code> 函数从第 6 行开始，并在第 8 行返回一个 <code>felt252</code>。</li>
<li><code>not_inlined</code> 函数从第 9 行开始，并在第 11 行返回一个 <code>felt252</code>。</li>
</ul>
<p>对应于 <code>main</code> 函数的所有语句位于第 0 行和第 5 行之间：</p>
<pre><code class="language-cairo noplayground">00 function_call&lt;user@main::main::not_inlined&gt;() -&gt; ([0])
01 felt252_const&lt;1&gt;() -&gt; ([1])
02 store_temp&lt;felt252&gt;([1]) -&gt; ([1])
03 felt252_add([1], [0]) -&gt; ([2])
04 store_temp&lt;felt252&gt;([2]) -&gt; ([2])
05 return([2])
</code></pre>
<p>第 0 行调用 <code>function_call</code> libfunc 来执行 <code>not_inlined</code> 函数。这将执行从第 9 行到第 10 行的代码，并将返回值存储在 id 为 <code>0</code> 的变量中。</p>
<pre><code class="language-cairo noplayground">09	felt252_const&lt;2&gt;() -&gt; ([0])
10	store_temp&lt;felt252&gt;([0]) -&gt; ([0])
</code></pre>
<p>此代码使用单一数据类型 <code>felt252</code>。它使用两个库函数 —— <code>felt252_const&lt;2&gt;</code>，它返回常量 <code>felt252</code> 2，以及 <code>store_temp&lt;felt252&gt;</code>，它将常量值推送到内存。第一行调用 <code>felt252_const&lt;2&gt;</code> libfunc 来创建一个 id 为 <code>0</code> 的变量。然后，第二行将此变量推送到内存以供以后使用。</p>
<p>之后，从第 1 行到第 2 行的 Sierra 语句是 <code>inlined</code> 函数的实际主体：</p>
<pre><code class="language-cairo noplayground">06	felt252_const&lt;1&gt;() -&gt; ([0])
07	store_temp&lt;felt252&gt;([0]) -&gt; ([0])
</code></pre>
<p>唯一的区别是内联代码将把 <code>felt252_const</code> 值存储在 id 为 <code>1</code> 的变量中，因为 <code>[0]</code> 引用的是之前分配的变量：</p>
<pre><code class="language-cairo noplayground">01	felt252_const&lt;1&gt;() -&gt; ([1])
02	store_temp&lt;felt252&gt;([1]) -&gt; ([1])
</code></pre>
<blockquote>
<p>注意：在两种情况下（内联或不内联），被调用函数的 <code>return</code> 指令都不会被执行，因为这将导致过早结束 <code>main</code> 函数的执行。相反，<code>inlined</code> 和 <code>not_inlined</code> 的返回值将被相加并返回结果。</p>
</blockquote>
<p>第 3 到 5 行包含 Sierra 语句，它们将把包含在 id 为 <code>0</code> 和 <code>1</code> 的变量中的值相加，将结果存储在内存中并返回它：</p>
<pre><code class="language-cairo noplayground">03	felt252_add([1], [0]) -&gt; ([2])
04	store_temp&lt;felt252&gt;([2]) -&gt; ([2])
05	return([2])
</code></pre>
<p>现在，让我们看看对应于此程序的 Casm 代码，以真正了解内联的好处。</p>
<h2 id="casm-代码解释"><a class="header" href="#casm-代码解释">Casm 代码解释</a></h2>
<p>这是我们之前程序示例的 Casm 代码：</p>
<pre><code class="language-cairo noplayground">1	call rel 3
2	ret
3	call rel 9
4	[ap + 0] = 1, ap++
5	[ap + 0] = [ap + -1] + [ap + -2], ap++
6	ret
7	[ap + 0] = 1, ap++
8	ret
9	[ap + 0] = 2, ap++
10	ret
11	ret
</code></pre>
<p>不要犹豫，使用 <a href="https://cairovm.codes/">cairovm.codes</a> playground 来跟随并查看所有的执行痕迹。</p>
<p>每条指令和任何指令的每个参数都会使程序计数器（称为 PC）增加 1。这意味着第 2 行上的 <code>ret</code> 实际上是 <code>PC = 3</code> 处的指令，因为参数 <code>3</code> 对应于 <code>PC = 2</code>。</p>
<p><code>call</code> 和 <code>ret</code> 指令允许实现函数栈：</p>
<ul>
<li><code>call</code> 指令像跳转指令一样行动，将 PC 更新为给定值，无论是使用 <code>rel</code> 相对于当前值还是使用 <code>abs</code> 绝对值。</li>
<li><code>ret</code> 指令跳回到 <code>call</code> 指令之后并在那里继续执行代码。</li>
</ul>
<p>我们现在可以分解这些指令是如何执行的，以理解这段代码做了什么：</p>
<ul>
<li><code>call rel 3</code>: 这条指令将 PC 增加 3 并执行位于此位置的指令，即 <code>PC = 4</code> 处的 <code>call rel 9</code>。</li>
<li><code>call rel 9</code> 将 PC 增加 9 并执行 <code>PC = 13</code> 处的指令，实际上是第 9 行。</li>
<li><code>[ap + 0] = 2, ap++</code>: <code>ap</code> 代表 Allocation Pointer（分配指针），它指向程序目前尚未使用的第一个内存单元。这意味着我们将值 <code>2</code> 存储在 <code>ap</code> 当前值指示的下一个空闲内存单元中，之后我们将 <code>ap</code> 增加 1。然后，我们去下一行，即 <code>ret</code>。</li>
<li><code>ret</code>: 跳回到 <code>call rel 9</code> 之后的行，所以我们去第 4 行。</li>
<li><code>[ap + 0] = 1, ap++</code>: 我们将值 <code>1</code> 存储在 <code>[ap]</code> 中并应用 <code>ap++</code>，使得 <code>[ap - 1] = 1</code>。这意味着我们现在有 <code>[ap-1] = 1, [ap-2] = 2</code>，我们去下一行。</li>
<li><code>[ap + 0] = [ap + -1] + [ap + -2], ap++</code>: 我们将值 <code>1</code> 和 <code>2</code> 相加并将结果存储在 <code>[ap]</code> 中，我们应用 <code>ap++</code>，所以结果是 <code>[ap-1] = 3, [ap-2] = 1, [ap-3]=2</code>。</li>
<li><code>ret</code>: 跳回到 <code>call rel 3</code> 之后的行，所以我们去第 2 行。</li>
<li><code>ret</code>: 执行的最后一条指令，因为没有更多的 <code>call</code> 指令可以在之后跳回。这是 Cairo <code>main</code> 函数的实际返回指令。</li>
</ul>
<p>总结一下：</p>
<ul>
<li><code>call rel 3</code> 对应于 <code>main</code> 函数，它显然没有被内联。</li>
<li><code>call rel 9</code> 触发对 <code>not_inlined</code> 函数的调用，该函数返回 <code>2</code> 并将其存储在最终位置 <code>[ap-3]</code>。</li>
<li>第 4 行是 <code>inlined</code> 函数的内联代码，它返回 <code>1</code> 并将其存储在最终位置 <code>[ap-2]</code>。我们可以清楚地看到在这种情况下没有 <code>call</code> 指令，因为函数体被插入并直接执行。</li>
<li>之后，计算总和，我们最终回到第 2 行，其中包含最终的 <code>ret</code> 指令，返回总和，对应于 <code>main</code> 函数的返回值。</li>
</ul>
<p>有趣的是，在 Sierra 代码和 Casm 代码中，<code>not_inlined</code> 函数将在 <code>inlined</code> 函数的主体之前被调用和执行，即使 Cairo 程序执行 <code>inlined() + not_inlined()</code>。</p>
<blockquote>
<p>我们程序的 Casm 代码清楚地表明，对于 <code>not_inlined</code> 函数有一个函数调用，而 <code>inlined</code> 函数被正确地内联了。</p>
</blockquote>
<h2 id="额外的优化"><a class="header" href="#额外的优化">额外的优化</a></h2>
<p>让我们研究另一个程序，它展示了内联有时可能提供的其他好处。清单 {{#ref code_removal}} 显示了一个调用 2 个函数且不返回任何内容的 Cairo 程序：</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    inlined();
    not_inlined();
}

#[inline(always)]
fn inlined() -&gt; felt252 {
    'inlined'
}

#[inline(never)]
fn not_inlined() -&gt; felt252 {
    'not inlined'
}
</code></pre>
<p>{{#label code_removal}} <span class="caption">清单 {{#ref code_removal}}: 一个小的 Cairo 程序，它调用 <code>inlined</code> 和 <code>not_inlined</code> 且不返回任何值。</span></p>
<p>这是相应的 Sierra 代码：</p>
<pre><code class="language-cairo noplayground">// type declarations
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false]
type Unit = Struct&lt;ut@Tuple&gt; [storable: true, drop: true, dup: true, zero_sized: true]

// libfunc declarations
libfunc function_call&lt;user@main::main::not_inlined&gt; = function_call&lt;user@main::main::not_inlined&gt;
libfunc drop&lt;felt252&gt; = drop&lt;felt252&gt;
libfunc struct_construct&lt;Unit&gt; = struct_construct&lt;Unit&gt;
libfunc felt252_const&lt;29676284458984804&gt; = felt252_const&lt;29676284458984804&gt;
libfunc store_temp&lt;felt252&gt; = store_temp&lt;felt252&gt;
libfunc felt252_const&lt;133508164995039583817065828&gt; = felt252_const&lt;133508164995039583817065828&gt;

// statements
00 function_call&lt;user@main::main::not_inlined&gt;() -&gt; ([0])
01 drop&lt;felt252&gt;([0]) -&gt; ()
02 struct_construct&lt;Unit&gt;() -&gt; ([1])
03 return([1])
04 felt252_const&lt;29676284458984804&gt;() -&gt; ([0])
05 store_temp&lt;felt252&gt;([0]) -&gt; ([0])
06 return([0])
07 felt252_const&lt;133508164995039583817065828&gt;() -&gt; ([0])
08 store_temp&lt;felt252&gt;([0]) -&gt; ([0])
09 return([0])

// funcs
main::main::main@0() -&gt; (Unit)
main::main::inlined@4() -&gt; (felt252)
main::main::not_inlined@7() -&gt; (felt252)
</code></pre>
<p>在这个特定案例中，我们可以观察到编译器对我们代码的 <code>main</code> 函数应用了额外的优化：<code>inlined</code> 函数的代码，它被注释为 <code>#[inline(always)]</code> 属性，实际上没有被复制到 <code>main</code> 函数中。相反，<code>main</code> 函数以 <code>function_call</code> libfunc 开始来调用 <code>not_inlined</code> 函数，完全省略了 <code>inlined</code> 函数的代码。</p>
<blockquote>
<p>因为 <code>inlined</code> 返回值从未被使用，编译器通过跳过 <code>inlined</code> 函数代码来优化 <code>main</code> 函数。这实际上会减少代码长度，同时减少执行 <code>main</code> 所需的步骤数。</p>
</blockquote>
<p>相比之下，第 0 行使用 <code>function_call</code> libfunc 来正常执行 <code>not_inlined</code> 函数。这意味着从第 7 行到第 8 行的所有代码都将被执行：</p>
<pre><code class="language-cairo noplayground">07 felt252_const&lt;133508164995039583817065828&gt;() -&gt; ([0])
08 store_temp&lt;felt252&gt;([0]) -&gt; ([0])
</code></pre>
<p>这个存储在 id 为 <code>0</code> 的变量中的值随后在第 1 行被丢弃，因为它在 <code>main</code> 函数中没被使用：</p>
<pre><code class="language-cairo noplayground">01 drop&lt;felt252&gt;([0]) -&gt; ()
</code></pre>
<p>最后，由于 <code>main</code> 函数不返回任何值，因此创建并返回一个单元类型的变量 <code>()</code>：</p>
<pre><code class="language-cairo noplayground">02 struct_construct&lt;Unit&gt;() -&gt; ([1])
03 return([1])
</code></pre>
<h2 id="总结-8"><a class="header" href="#总结-8">总结</a></h2>
<p>内联是一种编译器优化技术，在各种情况下都非常有用。内联函数允许通过将 Sierra 代码直接注入调用者函数的上下文中来摆脱使用 <code>function_call</code> libfunc 调用函数的开销，同时可能优化执行的 Sierra 代码以减少步骤数。如果使用得当，内联甚至可以减少代码长度，如前一个示例所示。</p>
<p>然而，将 <code>inline</code> 属性应用于具有大量代码和少量参数的函数可能会导致代码大小增加，特别是如果内联函数在代码库中被多次使用。仅在有意义的地方使用内联，并注意编译器默认处理内联。因此，在大多数情况下不建议手动应用内联，但这可以帮助改进和微调代码的行为。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="打印-printing"><a class="header" href="#打印-printing">打印 (Printing)</a></h1>
<p>在编写程序时，将以此数据打印到控制台是很常见的，无论是为了程序的正常过程还是出于调试目的。在本章中，我们将描述你打印简单和复杂数据类型的选项。</p>
<h2 id="打印标准数据类型"><a class="header" href="#打印标准数据类型">打印标准数据类型</a></h2>
<p>Cairo 提供了两个宏来打印标准数据类型：</p>
<ul>
<li><code>println!</code> 在新行上打印</li>
<li><code>print!</code> 进行内联打印</li>
</ul>
<p>两者都接受 <code>ByteArray</code> 字符串作为第一个参数（参见 <a href="#byte-array-strings">数据类型</a>），可以是一个简单的字符串以打印消息，或者是一个带有占位符的字符串以格式化值的打印方式。</p>
<p>有两种方式使用这些占位符，两者可以混合使用：</p>
<ul>
<li>空的大括号 <code>{}</code> 按相同顺序被作为参数给出的值替换给 <code>print!</code> 宏。</li>
<li>带有变量名的大括号被直接替换为变量值。</li>
</ul>
<p>这是一些例子：</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let a = 10;
    let b = 20;
    let c = 30;

    println!("Hello world!");
    println!("{} {} {}", a, b, c); // 10 20 30
    println!("{c} {a} {}", b); // 30 10 20
}
</code></pre>
<blockquote>
<p><code>print!</code> 和 <code>println!</code> 宏在底层使用 <code>Display</code> trait，因此用于打印实现了它的类型的值。基本数据类型就是这种情况，但对于更复杂的类型则不是。如果你尝试用这些宏打印复杂数据类型的值，例如出于调试目的，你会得到一个错误。在这种情况下，你可以为你的类型 <a href="#printing-custom-data-types">手动实现</a> <code>Display</code> trait，或者使用 <code>Debug</code> trait（见 <a href="#print-debug-traces">下文</a>）。</p>
</blockquote>
<h2 id="格式化"><a class="header" href="#格式化">格式化</a></h2>
<p>Cairo 还提供了一个有用的宏来处理字符串格式化：<code>format!</code>。这个宏像 <code>println!</code> 一样工作，但它不是将输出打印到屏幕，而是返回一个包含内容的 <code>ByteArray</code>。在以下示例中，我们使用 <code>+</code> 运算符或 <code>format!</code> 宏执行字符串连接。使用 <code>format!</code> 的代码版本更容易阅读，并且 <code>format!</code> 宏生成的代码使用快照，因此此调用不获取其任何参数的所有权。</p>
<pre><code class="language-cairo">#[executable]
fn main() {
    let s1: ByteArray = "tic";
    let s2: ByteArray = "tac";
    let s3: ByteArray = "toe";
    let s = s1 + "-" + s2 + "-" + s3;
    // using + operator consumes the strings, so they can't be used again!

    let s1: ByteArray = "tic";
    let s2: ByteArray = "tac";
    let s3: ByteArray = "toe";
    let s = format!("{s1}-{s2}-{s3}"); // s1, s2, s3 are not consumed by format!
    // or
    let s = format!("{}-{}-{}", s1, s2, s3);

    println!("{}", s);
}
</code></pre>
<h2 id="打印自定义数据类型"><a class="header" href="#打印自定义数据类型">打印自定义数据类型</a></h2>
<p>如前所述，如果你尝试使用 <code>print!</code> 或 <code>println!</code> 宏打印自定义数据类型的值，你会得到一个错误，告诉你 <code>Display</code> trait 未为你的自定义类型实现：</p>
<pre><code class="language-shell">error: Trait has no implementation in context: core::fmt::Display::&lt;package_name::struct_name&gt;
</code></pre>
<p><code>println!</code> 宏可以做多种格式化，默认情况下，大括号告诉 <code>println!</code> 使用称为 <code>Display</code> 的格式化 —— 旨在供最终用户直接使用的输出。我们目前看到的原始类型默认实现了 <code>Display</code>，因为向用户展示 <code>1</code> 或任何其他原始类型只有一种方式。但是对于结构体，<code>println!</code> 应该如何格式化输出就不那么清楚了，因为有更多的显示可能性：我们要逗号吗？我们要打印大括号吗？应该显示所有字段吗？由于这种歧义，Cairo 不尝试猜测我们想要什么，并且结构体没有提供用于 <code>println!</code> 和 <code>{}</code> 占位符的 <code>Display</code> 实现。</p>
<p>这是要实现的 <code>Display</code> trait：</p>
<pre><code class="language-cairo noplayground">trait Display&lt;T&gt; {
    fn fmt(self: @T, ref f: Formatter) -&gt; Result&lt;(), Error&gt;;
}
</code></pre>
<p>第二个参数 <code>f</code> 是 <code>Formatter</code> 类型，它只是一个包含 <code>ByteArray</code> 的结构体，表示格式化的待定结果：</p>
<pre><code class="language-cairo noplayground">#[derive(Default, Drop)]
pub struct Formatter {
    /// The pending result of formatting.
    pub buffer: ByteArray,
}
</code></pre>
<p>知道了这一点，这是一个如何为自定义 <code>Point</code> 结构体实现 <code>Display</code> trait 的示例：</p>
<pre><code class="language-cairo">use core::fmt::{Display, Error, Formatter};

#[derive(Copy, Drop)]
struct Point {
    x: u8,
    y: u8,
}

impl PointDisplay of Display&lt;Point&gt; {
    fn fmt(self: @Point, ref f: Formatter) -&gt; Result&lt;(), Error&gt; {
        let str: ByteArray = format!("Point ({}, {})", *self.x, *self.y);
        f.buffer.append(@str);
        Ok(())
    }
}

#[executable]
fn main() {
    let p = Point { x: 1, y: 3 };
    println!("{}", p); // Point: (1, 3)
}
</code></pre>
<p>Cairo 还提供了 <code>write!</code> 和 <code>writeln!</code> 宏以在格式化程序中写入格式化字符串。这是一个使用 <code>write!</code> 宏在同一行连接多个字符串然后打印结果的简短示例：</p>
<pre><code class="language-cairo">use core::fmt::Formatter;

#[executable]
fn main() {
    let mut formatter: Formatter = Default::default();
    let a = 10;
    let b = 20;
    write!(formatter, "hello");
    write!(formatter, "world");
    write!(formatter, " {a} {b}");

    println!("{}", formatter.buffer); // helloworld 10 20
}
</code></pre>
<p>也可以使用这些宏为 <code>Point</code> 结构体实现 <code>Display</code> trait，如下所示：</p>
<pre><code class="language-cairo">use core::fmt::{Display, Error, Formatter};

#[derive(Copy, Drop)]
struct Point {
    x: u8,
    y: u8,
}

impl PointDisplay of Display&lt;Point&gt; {
    fn fmt(self: @Point, ref f: Formatter) -&gt; Result&lt;(), Error&gt; {
        let x = *self.x;
        let y = *self.y;

        writeln!(f, "Point ({x}, {y})")
    }
}

#[executable]
fn main() {
    let p = Point { x: 1, y: 3 };
    println!("{}", p); // Point: (1, 3)
}
</code></pre>
<blockquote>
<p>以这种方式打印复杂数据类型可能并不理想，因为它需要额外的步骤来使用 <code>print!</code> 和 <code>println!</code> 宏。如果你需要打印复杂数据类型，尤其是在调试时，请改用下面描述的 <code>Debug</code> trait。</p>
</blockquote>
<h2 id="以十六进制打印"><a class="header" href="#以十六进制打印">以十六进制打印</a></h2>
<p>默认情况下，<code>Display</code> trait 以十进制打印整数值。但是，就像在 Rust 中一样，你可以使用 <code>{:x}</code> 符号以十六进制打印它们。</p>
<p>在底层，Cairo 为常见类型如无符号整数、<code>felt252</code> 和 <code>NonZero</code> 实现了 <code>LowerHex</code> trait，也为常见的 Starknet 类型如 <code>ContractAddress</code> 和 <code>ClassHash</code> 实现了该 trait。</p>
<p>如果这对你有意义，你也可以使用与 <code>Display</code> trait 相同的方法为你的自定义类型实现 <code>LowerHex</code> trait（参见 <a href="#printing-custom-data-types">打印自定义数据类型</a>）。</p>
<h2 id="打印调试痕迹"><a class="header" href="#打印调试痕迹">打印调试痕迹</a></h2>
<p>Cairo 提供了 <code>Debug</code> trait，可以派生它以在调试时打印变量的值。只需在 <code>print!</code> 或 <code>println!</code> 宏字符串的大括号 <code>{}</code> 占位符内添加 <code>:?</code>。</p>
<p>这个 trait 非常有用，并且默认情况下为基本数据类型实现。对于复杂数据类型，只要它们包含的所有类型都实现了它，就可以使用 <code>#[derive(Debug)]</code> 属性简单地派生它。这消除了手动实现额外代码以打印复杂数据类型的需要。</p>
<p>注意，测试中使用的 <code>assert_xx!</code> 宏要求提供的值实现 <code>Debug</code> trait，因为它们在断言失败的情况下也会打印结果。</p>
<p>有关 <code>Debug</code> trait 及其在调试时打印值的用法的更多详细信息，请参阅 <a href="#debug-trait-for-printing-and-debugging">可派生 Traits</a> 附录。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="算术电路-arithmetic-circuits"><a class="header" href="#算术电路-arithmetic-circuits">算术电路 (Arithmetic Circuits)</a></h1>
<p>算术电路是用于表示多项式计算的数学模型。它们定义在域上（通常是有限域 \(F_p\)，其中 \(p\) 是素数），并由以下部分组成：</p>
<ul>
<li>输入信号（范围 \([0, p-1]\) 内的值）</li>
<li>算术运算（加法和乘法门）</li>
<li>输出信号</li>
</ul>
<p>Cairo 支持模数高达 384 位的模拟算术电路。</p>
<p>这对于以下方面特别有用：</p>
<ul>
<li>为其他证明系统实现验证</li>
<li>实现密码学原语</li>
<li>创建更低级的程序，与标准 Cairo 构造相比可能具有更低的开销</li>
</ul>
<h2 id="在-cairo-中实现算术电路"><a class="header" href="#在-cairo-中实现算术电路">在 Cairo 中实现算术电路</a></h2>
<p>Cairo 的电路构造在 corelib 的 <code>core::circuit</code> 模块中可用。</p>
<p>算术电路包括：</p>
<ul>
<li>模 \(p\) 加法：<code>AddMod</code> builtin</li>
<li>模 \(p\) 乘法：<code>MulMod</code> builtin</li>
</ul>
<p>由于模属性，我们可以构建四个基本算术门：</p>
<ul>
<li>加法：<code>AddModGate</code></li>
<li>减法：<code>SubModGate</code></li>
<li>乘法：<code>MulModGate</code></li>
<li>逆元：<code>InvModGate</code></li>
</ul>
<p>让我们创建一个计算 \(a \cdot (a + b)\) 的电路，在 BN254 素数域上。</p>
<p>我们从空的结构体 <code>CircuitElement&lt;T&gt;</code> 开始。</p>
<p>我们电路的输入定义为 <code>CircuitInput</code>：</p>
<pre><code class="language-cairo noplayground">    let a = CircuitElement::&lt;CircuitInput&lt;0&gt;&gt; {};
    let b = CircuitElement::&lt;CircuitInput&lt;1&gt;&gt; {};
</code></pre>
<p>我们可以组合电路输入和门：<code>CircuitElement&lt;a&gt;</code> 和 <code>CircuitElement&lt;b&gt;</code> 与加法门组合得到 <code>CircuitElement&lt;AddModGate&lt;a, b&gt;&gt;</code>。</p>
<p>我们可以使用 <code>circuit_add</code>、<code>circuit_sub</code>、<code>circuit_mul</code> 和 <code>circuit_inverse</code> 直接组合电路元素。对于 \(a * (a + b)\)，我们的电路描述是：</p>
<pre><code class="language-cairo noplayground">    let add = circuit_add(a, b);
    let mul = circuit_mul(a, add);
</code></pre>
<p>注意 <code>a</code>、<code>b</code> 和 <code>add</code> 是中间电路元素，不是专门的输入或门，这就是为什么我们需要区分空结构体 <code>CircuitElement&lt;T&gt;</code> 和由类型 <code>T</code> 指定的电路描述。</p>
<p>电路的输出定义为电路元素的元组。可以添加我们电路的任何中间门，但我们必须添加所有度为 0 的门（输出信号未被用作任何其他门的输入的门）。在我们的例子中，我们将只添加最后一个门 <code>mul</code>：</p>
<pre><code class="language-cairo noplayground">    let output = (mul,);
</code></pre>
<p>我们现在有了我们电路及其输出的完整描述。我们现在需要为每个输入分配一个值。由于电路是用 384 位模数定义的，单个 <code>u384</code> 值可以表示为四个 <code>u96</code> 的固定数组。我们可以将 \(a\) 和 \(b\) 分别初始化为 \(10\) 和 \(20\)：</p>
<pre><code class="language-cairo noplayground">    let mut inputs = output.new_inputs();
    inputs = inputs.next([10, 0, 0, 0]);
    inputs = inputs.next([20, 0, 0, 0]);

    let instance = inputs.done();
</code></pre>
<p>由于输入数量可以变化，Cairo 使用累加器，并且 <code>new_inputs</code> 和 <code>next</code> 函数返回 <code>AddInputResult</code> 枚举的一个变体。</p>
<pre><code class="language-cairo noplayground">pub enum AddInputResult&lt;C&gt; {
    /// All inputs have been filled.
    Done: CircuitData&lt;C&gt;,
    /// More inputs are needed to fill the circuit instance's data.
    More: CircuitInputAccumulator&lt;C&gt;,
}
</code></pre>
<p>我们必须为每个输入分配一个值，通过对每个 <code>CircuitInputAccumulator</code> 变体调用 <code>next</code>。输入初始化后，通过调用 <code>done</code> 函数，我们得到完整的电路 <code>CircuitData&lt;C&gt;</code>，其中 <code>C</code> 是编码整个电路实例的长类型。</p>
<p>然后我们需要定义我们的电路使用什么模数（高达 384 位模数），通过定义一个 <code>CircuitModulus</code>。我们想使用 BN254 素数域模数：</p>
<pre><code class="language-cairo noplayground">    let bn254_modulus = TryInto::&lt;
        _, CircuitModulus,
    &gt;::try_into([0x6871ca8d3c208c16d87cfd47, 0xb85045b68181585d97816a91, 0x30644e72e131a029, 0x0])
        .unwrap();
</code></pre>
<p>最后一部分是电路的评估，即通过我们电路描述的每个门正确传递输入信号并获取每个输出门的值的实际过程。我们可以如下评估并获得给定模数的结果：</p>
<pre><code class="language-cairo noplayground">    let res = instance.eval(bn254_modulus).unwrap();
</code></pre>
<p>要检索特定输出的值，我们可以对我们的结果使用 <code>get_output</code> 函数以及我们想要的输出门的 <code>CircuitElement</code> 实例。我们也可以检索任何中间门的值。</p>
<pre><code class="language-cairo noplayground">    let add_output = res.get_output(add);
    let circuit_output = res.get_output(mul);

    assert!(add_output == u384 { limb0: 30, limb1: 0, limb2: 0, limb3: 0 }, "add_output");
    assert!(circuit_output == u384 { limb0: 300, limb1: 0, limb2: 0, limb3: 0 }, "circuit_output");
</code></pre>
<p>回顾一下，我们执行了以下步骤：</p>
<ul>
<li>定义电路输入</li>
<li>描述电路</li>
<li>指定输出</li>
<li>为输入赋值</li>
<li>定义模数</li>
<li>评估电路</li>
<li>获取输出值</li>
</ul>
<p>完整的代码是：</p>
<pre><code class="language-cairo noplayground">use core::circuit::{
    AddInputResultTrait, CircuitElement, CircuitInput, CircuitInputs, CircuitModulus,
    CircuitOutputsTrait, EvalCircuitTrait, circuit_add, circuit_mul, u384,
};

// Circuit: a * (a + b)
// witness: a = 10, b = 20
// expected output: 10 * (10 + 20) = 300
fn eval_circuit() -&gt; (u384, u384) {
    // ANCHOR: inputs
    let a = CircuitElement::&lt;CircuitInput&lt;0&gt;&gt; {};
    let b = CircuitElement::&lt;CircuitInput&lt;1&gt;&gt; {};
    // ANCHOR_END: inputs

    // ANCHOR: description
    let add = circuit_add(a, b);
    let mul = circuit_mul(a, add);
    // ANCHOR_END: description

    // ANCHOR: output
    let output = (mul,);
    // ANCHOR_END: output

    // ANCHOR: instance
    let mut inputs = output.new_inputs();
    inputs = inputs.next([10, 0, 0, 0]);
    inputs = inputs.next([20, 0, 0, 0]);

    let instance = inputs.done();
    // ANCHOR_END: instance

    // ANCHOR: modulus
    let bn254_modulus = TryInto::&lt;
        _, CircuitModulus,
    &gt;::try_into([0x6871ca8d3c208c16d87cfd47, 0xb85045b68181585d97816a91, 0x30644e72e131a029, 0x0])
        .unwrap();
    // ANCHOR_END: modulus

    // ANCHOR: eval
    let res = instance.eval(bn254_modulus).unwrap();
    // ANCHOR_END: eval

    // ANCHOR: output_values
    let add_output = res.get_output(add);
    let circuit_output = res.get_output(mul);

    assert!(add_output == u384 { limb0: 30, limb1: 0, limb2: 0, limb3: 0 }, "add_output");
    assert!(circuit_output == u384 { limb0: 300, limb1: 0, limb2: 0, limb3: 0 }, "circuit_output");
    // ANCHOR_END: output_values

    (add_output, circuit_output)
}
</code></pre>
<h2 id="零知识证明系统中的算术电路"><a class="header" href="#零知识证明系统中的算术电路">零知识证明系统中的算术电路</a></h2>
<p>在零知识证明系统中，证明者创建计算陈述的证明，验证者可以在不执行完整计算的情况下检查该证明。然而，这些陈述必须首先转换为适合证明系统的表示形式。</p>
<h3 id="zk-snarks-方法"><a class="header" href="#zk-snarks-方法">zk-SNARKs 方法</a></h3>
<p>一些证明系统，如 zk-SNARKs，使用有限域 \(F_p\) 上的算术电路。这些电路在特定门处包括约束，表示为方程：</p>
<p>\[ (a_1 \cdot s_1 + … + a_n \cdot s_n) \cdot (b_1 \cdot s_1 + … + b_n \cdot s_n) + (c_1 \cdot s_1 + … + c_n \cdot s_n) = 0 \mod p \] 其中 \(s_1, …, s_n\) 是信号，\(a_i, b_i, c_i\) 是系数。</p>
<p>见证 (witness) 是满足电路中所有约束的信号分配。zk-SNARK 证明使用这些属性来证明对见证的知识，而不泄露私有输入信号，确保证明者的诚实同时保护隐私。</p>
<p>已经做了一些工作，例如 <a href="https://felt.gitbook.io/garaga/deploy-your-snark-verifier-on-starknet/groth16/generate-and-deploy-your-verifier-contract">Garaga Groth16 verifier</a>。</p>
<h3 id="zk-starks-方法"><a class="header" href="#zk-starks-方法">zk-STARKs 方法</a></h3>
<p>STARKs（Cairo 使用的）使用代数中间表示 (AIR) 代替算术电路。AIR 将计算描述为一组多项式约束。</p>
<p>通过允许模拟算术电路，Cairo 可用于在 STARK 证明内实现 zk-SNARKs 证明验证。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="使用预言机卸载计算-offloading-computations-with-oracles"><a class="header" href="#使用预言机卸载计算-offloading-computations-with-oracles">使用预言机卸载计算 (Offloading Computations with Oracles)</a></h1>
<p>在本章中，我们将构建一个小的 Cairo 可执行文件，它请求外部助手（“预言机”）做一些工作，然后在 Cairo 内部约束返回值，使它们成为证明的一部分。在此过程中，你将学习什么是预言机，为什么它们自然地适合 Cairo 的非确定性机器，以及如何安全地使用它们。</p>
<p>预言机是 Scarb 的一个实验性功能，可供使用 <code>--experimental-oracles</code> 执行的 Cairo 可执行文件使用。它们在 Starknet 合约中不可用。</p>
<blockquote>
<p>注意：这个“预言机”系统与智能合约预言机无关；但概念相似：使用外部进程在受限系统中查询数据。</p>
</blockquote>
<h2 id="为什么要使用预言机"><a class="header" href="#为什么要使用预言机">为什么要使用预言机？</a></h2>
<p>当 Cairo VM 运行时，预言机允许证明者为内存单元分配任意值。这种非确定性让我们“注入”来自外部世界的值。例如，要证明我们知道 \(\sqrt{25}\)，我们不需要在 Cairo 中实现平方根算法；我们可以从预言机获得 \(5\) 并简单地断言 \(5 \cdot 5 = 25\)。</p>
<p>如果你对底层内存模型感到好奇，请参阅 <a href="#非确定性只读内存">非确定性只读存储器</a>。</p>
<h2 id="我们将构建什么"><a class="header" href="#我们将构建什么">我们将构建什么</a></h2>
<p>我们将创建两个协同工作的部分：</p>
<ul>
<li>一个 Cairo 可执行文件，它调用两个预言机端点：一个返回数字的整数平方根，另一个将数字分解为小端字节。每次调用后，我们将断言必须成立的属性，以保持程序的可靠性属性。</li>
<li>一个 Rust 进程，实现这些端点并通过标准输入/输出通过 JSON-RPC（Scarb 执行器支持的 <code>stdio:</code> 协议）与 Cairo 通信。</li>
</ul>
<p>我们在 <code>listing_oracles/</code> 下准备了一个完整的示例。我们将浏览重要文件然后运行它。</p>
<h2 id="cairo-包"><a class="header" href="#cairo-包">Cairo 包</a></h2>
<p>首先，让我们看看清单。我们声明一个可执行包，依赖于 <code>cairo_execute</code> 以便我们可以使用 Scarb 运行，并添加 <code>oracle</code> crate 以访问 <code>oracle::invoke</code>。</p>
<p><span class="caption">文件名: listing_oracles/Scarb.toml</span></p>
<pre><code class="language-toml">[package]
name = "example"
version = "0.1.0"
edition = "2024_07"
publish = false

[dependencies]
cairo_execute = "2.13.1"
oracle = "0.1.0-dev.4"

[executable]

[cairo]
enable-gas = false

[dev-dependencies]
cairo_test = "2"
</code></pre>
<p>现在让我们看看我们如何从 Cairo 调用预言机。我们定义两个辅助函数，使用形式为 <code>stdio:...</code> 的连接字符串转发到 Rust 预言机，然后我们断言使返回值成为证明一部分的关系。</p>
<p><span class="caption">文件名: listing_oracles/src/lib.cairo</span></p>
<pre><code class="language-cairo">use core::num::traits::Pow;

// Call into the Rust oracle to get the square root of an integer.
fn sqrt_call(x: u64) -&gt; oracle::Result&lt;u64&gt; {
    oracle::invoke("stdio:cargo -q run --manifest-path ./src/my_oracle/Cargo.toml", 'sqrt', (x,))
}

// Call into the Rust oracle to convert an integer to little-endian bytes.
fn to_le_bytes(val: u64) -&gt; oracle::Result&lt;Array&lt;u8&gt;&gt; {
    oracle::invoke(
        "stdio:cargo -q run --manifest-path ./src/my_oracle/Cargo.toml", 'to_le_bytes', (val,),
    )
}

fn oracle_calls(x: u64) -&gt; Result&lt;(), oracle::Error&gt; {
    let sqrt = sqrt_call(x)?;
    // CONSTRAINT: sqrt * sqrt == x
    assert!(sqrt * sqrt == x, "Expected sqrt({x}) * sqrt({x}) == x, got {sqrt} * {sqrt} == {x}");
    println!("Computed sqrt({x}) = {sqrt}");

    let bytes = to_le_bytes(x)?;
    // CONSTRAINT: sum(bytes_i * 256^i) == x
    let mut recomposed_val = 0;
    for (i, byte) in bytes.span().into_iter().enumerate() {
        recomposed_val += (*byte).into() * 256_u64.pow(i.into());
    }
    assert!(
        recomposed_val == x,
        "Expected recomposed value {recomposed_val} == {x}, got {recomposed_val}",
    );
    println!("le_bytes decomposition of {x}) = {:?}", bytes.span());

    Ok(())
}

#[executable]
fn main(x: u64) -&gt; bool {
    match oracle_calls(x) {
        Ok(()) =&gt; true,
        Err(e) =&gt; panic!("Oracle call failed: {e:?}"),
    }
}
</code></pre>
<p>这里有两个重要的想法：</p>
<ol>
<li>我们用 <code>oracle::invoke(connection, selector, inputs_tuple)</code> 调用预言机。<code>connection</code> 告诉 Scarb 如何生成进程（这里是通过 <code>stdio:</code> 的 Cargo 命令），<code>selector</code> 按名称选择端点，元组包含输入。返回类型是 <code>oracle::Result&lt;T&gt;</code>，所以我们显式处理错误。</li>
<li>我们立即约束从预言机返回的任何内容。对于平方根，我们断言 <code>sqrt * sqrt == x</code>。对于字节分解，我们从其字节重新计算该值并断言它等于原始数字。这些断言是将注入的值转化为可靠见证数据的原因。正确约束返回值非常重要；否则，恶意证明者可以将任意值注入内存，并伪造任意有效的 ZK-Proofs。</li>
</ol>
<h2 id="rust-预言机"><a class="header" href="#rust-预言机">Rust 预言机</a></h2>
<p>在 Rust 方面，我们实现端点并让辅助 crate (<code>cairo_oracle_server</code>) 处理管道。输入自动解码；输出被编码回 Cairo。</p>
<p><span class="caption">文件名: listing_oracles/src/my_oracle/Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "my_oracle"
version = "0.1.0"
edition = "2021"
publish = false

[dependencies]
anyhow = "1"
cairo-oracle-server = "0.1"
starknet-core = "0.11"
</code></pre>
<p><span class="caption">文件名: listing_oracles/src/my_oracle/src/main.rs</span></p>
<pre><code class="language-rust noplayground">use anyhow::ensure;
use cairo_oracle_server::Oracle;
use std::process::ExitCode;

fn main() -&gt; ExitCode {
    Oracle::new()
        .provide("sqrt", |value: u64| {
            let sqrt = (value as f64).sqrt() as u64;
            ensure!(
                sqrt * sqrt == value,
                "Cannot compute integer square root of {value}"
            );
            Ok(sqrt)
        })
        .provide("to_le_bytes", |value: u64| {
            let value_bytes = value.to_le_bytes();
            Ok(value_bytes.to_vec())
        })
        .run()
}</code></pre>
<p><code>sqrt</code> 端点返回整数平方根并拒绝没有精确平方根的值。<code>to_le_bytes</code> 端点返回 <code>u64</code> 的小端字节分解。</p>
<h2 id="运行示例"><a class="header" href="#运行示例">运行示例</a></h2>
<p>从示例目录中，在启用预言机的情况下执行程序：</p>
<pre><code class="language-bash">scarb execute --experimental-oracles --print-program-output --arguments 25000000
</code></pre>
<p>你会看到程序返回 <code>1</code>，表示成功。Cairo 代码向预言机询问 <code>sqrt(25000000)</code>，验证 <code>5000 * 5000 == 25000000</code>，然后将 <code>25000000</code> 分解为字节并验证重新组合它们等于原始输入。</p>
<p>尝试一个不是完全平方数的值，例如 <code>27</code>：</p>
<pre><code class="language-bash">scarb execute --experimental-oracles --print-program-output --arguments 27
</code></pre>
<p><code>sqrt</code> 端点将返回错误，因为 <code>27</code> 没有整数平方根，这会传播回 Cairo。我们的程序会 panic。</p>
<h2 id="快速浏览-api"><a class="header" href="#快速浏览-api">快速浏览 API</a></h2>
<p>所有预言机交互都通过 Cairo 侧的一个函数进行：</p>
<pre><code class="language-text">oracle::invoke(connection: felt252*, selector: felt252*, inputs: (..)) -&gt; oracle::Result&lt;T&gt;
</code></pre>
<p>连接字符串选择传输和要运行的进程（这里是 <code>stdio:</code> 加上 Cargo 命令）。选择器是你在 Rust 中提供的端点名称（例如 <code>'sqrt'</code>）。输入是与 Rust 处理程序参数匹配的 Cairo 元组。返回类型是 <code>oracle::Result&lt;T&gt;</code>，所以你可以用 <code>match</code>、<code>unwrap_or</code> 或自定义逻辑处理错误。</p>
<h2 id="总结-9"><a class="header" href="#总结-9">总结</a></h2>
<p>你现在有一个工作示例，展示了如何将工作卸载到外部进程并将结果作为 Cairo 证明的一部分。当你想在客户端证明期间使用快速、灵活的助手时，请使用此模式，并记住：预言机是实验性的，仅限运行器，并且来自它们的所有内容必须由你的 Cairo 代码验证。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="附录-cairo"><a class="header" href="#附录-cairo">附录 (Cairo)</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="附录-a---关键字"><a class="header" href="#附录-a---关键字">附录 A - 关键字</a></h1>
<p>以下列表包含保留给 Cairo 语言当前或将来使用的关键字。</p>
<p>关键字分为三类：</p>
<ul>
<li>严格 (strict)</li>
<li>宽松 (loose)</li>
<li>保留 (reserved)</li>
</ul>
<p>还有第四类，即核心库中的函数。虽然它们的名称未被保留，但为了遵循良好的实践，不建议将它们用作任何项的名称。</p>
<hr>
<h2 id="严格关键字"><a class="header" href="#严格关键字">严格关键字</a></h2>
<p>这些关键字只能在其正确的上下文中使用。它们不能用作任何项的名称。</p>
<ul>
<li><code>as</code> - 重命名导入</li>
<li><code>break</code> - 立即退出循环</li>
<li><code>const</code> - 定义常量项</li>
<li><code>continue</code> - 继续下一次循环迭代</li>
<li><code>else</code> - <code>if</code> 和 <code>if let</code> 控制流结构的后备分支</li>
<li><code>enum</code> - 定义枚举</li>
<li><code>extern</code> - 在编译器级别定义的函数，可以编译为 CASM</li>
<li><code>false</code> - 布尔值 false 字面量</li>
<li><code>fn</code> - 定义函数</li>
<li><code>if</code> - 基于条件表达式的结果进行分支</li>
<li><code>impl</code> - 实现固有或 trait 功能</li>
<li><code>implicits</code> - 执行某些操作所需的特殊类型的函数参数</li>
<li><code>let</code> - 绑定变量</li>
<li><code>loop</code> - 无条件循环</li>
<li><code>match</code> - 将值与模式匹配</li>
<li><code>mod</code> - 定义模块</li>
<li><code>mut</code> - 表示变量可变性</li>
<li><code>nopanic</code> - 标记为此符号的函数意味着该函数永远不会 panic</li>
<li><code>of</code> - 实现 trait</li>
<li><code>pub</code> - 表示项的公共可见性，例如 struct 和 struct 字段、enum、const、trait 和 impl 块或模块</li>
<li><code>ref</code> - 隐式传递的参数，在函数结束时返回</li>
<li><code>return</code> - 从函数返回</li>
<li><code>struct</code> - 定义结构体</li>
<li><code>trait</code> - 定义 trait</li>
<li><code>true</code> - 布尔值 true 字面量</li>
<li><code>type</code> - 定义类型别名</li>
<li><code>use</code> - 将符号引入作用域</li>
<li><code>while</code> - 基于表达式的结果有条件地循环</li>
</ul>
<hr>
<h2 id="宽松关键字"><a class="header" href="#宽松关键字">宽松关键字</a></h2>
<p>这些关键字与特定行为相关联，但也可以用来定义项。</p>
<ul>
<li><code>self</code> - 方法主体</li>
<li><code>super</code> - 当前模块的父模块</li>
</ul>
<hr>
<h2 id="保留关键字"><a class="header" href="#保留关键字">保留关键字</a></h2>
<p>这些关键字尚未被使用，但保留供将来使用。目前，可以使用它们来定义项，虽然强烈建议不要这样做。该建议背后的原因是禁止使用这些关键字，从而使当前程序与 Cairo 的未来版本向前兼容。</p>
<ul>
<li><code>Self</code></li>
<li><code>do</code></li>
<li><code>dyn</code></li>
<li><code>for</code></li>
<li><code>hint</code></li>
<li><code>in</code></li>
<li><code>macro</code></li>
<li><code>move</code></li>
<li><code>static_assert</code></li>
<li><code>static</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsafe</code></li>
<li><code>where</code></li>
<li><code>with</code></li>
<li><code>yield</code></li>
</ul>
<hr>
<h2 id="内置函数"><a class="header" href="#内置函数">内置函数</a></h2>
<p>Cairo 编程语言提供了几个具有特殊用途的特定函数。我们不会在本书中介绍所有这些函数，但不建议使用这些函数的名称作为其他项的名称。</p>
<ul>
<li><code>assert</code> - 此函数检查布尔表达式，如果计算结果为 false，则触发 panic 函数。</li>
<li><code>panic</code> - 此函数确认发生了错误并终止程序。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="附录-b---运算符和符号"><a class="header" href="#附录-b---运算符和符号">附录 B - 运算符和符号</a></h1>
<p>本附录包含 Cairo 语法的词汇表，包括运算符和其他独自出现或是出现在路径、泛型、宏、属性、注释、元组和括号上下文中的符号。</p>
<h2 id="运算符"><a class="header" href="#运算符">运算符</a></h2>
<p>表 B-1 包含 Cairo 中的运算符、运算符在上下文中的示例、简短解释以及该运算符是否可重载。如果运算符是可重载的，则列出了用于重载该运算符的相关 trait。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>运算符</th><th>示例</th><th>解释</th><th>可重载?</th></tr>
</thead>
<tbody>
<tr><td><code>!</code></td><td><code>!expr</code></td><td>逻辑非</td><td><code>Not</code></td></tr>
<tr><td><code>~</code></td><td><code>~expr</code></td><td>按位非 (NOT)</td><td><code>BitNot</code></td></tr>
<tr><td><code>!=</code></td><td><code>expr != expr</code></td><td>不等于比较</td><td><code>PartialEq</code></td></tr>
<tr><td><code>%</code></td><td><code>expr % expr</code></td><td>算术取余</td><td><code>Rem</code></td></tr>
<tr><td><code>%=</code></td><td><code>var %= expr</code></td><td>算术取余并赋值</td><td><code>RemEq</code></td></tr>
<tr><td><code>&amp;</code></td><td><code>expr &amp; expr</code></td><td>按位与 (AND)</td><td><code>BitAnd</code></td></tr>
<tr><td><code>&amp;&amp;</code></td><td><code>expr &amp;&amp; expr</code></td><td>短路逻辑与 (AND)</td><td></td></tr>
<tr><td><code>*</code></td><td><code>expr * expr</code></td><td>算术乘法</td><td><code>Mul</code></td></tr>
<tr><td><code>*=</code></td><td><code>var *= expr</code></td><td>算术乘法并赋值</td><td><code>MulEq</code></td></tr>
<tr><td><code>@</code></td><td><code>@var</code></td><td>快照 (Snapshot)</td><td></td></tr>
<tr><td><code>*</code></td><td><code>*var</code></td><td>解快照 (Desnap)</td><td></td></tr>
<tr><td><code>+</code></td><td><code>expr + expr</code></td><td>算术加法</td><td><code>Add</code></td></tr>
<tr><td><code>+=</code></td><td><code>var += expr</code></td><td>算术加法并赋值</td><td><code>AddEq</code></td></tr>
<tr><td><code>,</code></td><td><code>expr, expr</code></td><td>参数和元素分隔符</td><td></td></tr>
<tr><td><code>-</code></td><td><code>-expr</code></td><td>算术取反</td><td><code>Neg</code></td></tr>
<tr><td><code>-</code></td><td><code>expr - expr</code></td><td>算术减法</td><td><code>Sub</code></td></tr>
<tr><td><code>-=</code></td><td><code>var -= expr</code></td><td>算术减法并赋值</td><td><code>SubEq</code></td></tr>
<tr><td><code>-&gt;</code></td><td><code>fn(...) -&gt; type</code>, <code>|…| -&gt; type</code></td><td>函数和闭包返回类型</td><td></td></tr>
<tr><td><code>.</code></td><td><code>expr.ident</code></td><td>成员访问</td><td></td></tr>
<tr><td><code>/</code></td><td><code>expr / expr</code></td><td>算术除法</td><td><code>Div</code></td></tr>
<tr><td><code>/=</code></td><td><code>var /= expr</code></td><td>算术除法并赋值</td><td><code>DivEq</code></td></tr>
<tr><td><code>:</code></td><td><code>pat: type</code>, <code>ident: type</code></td><td>约束</td><td></td></tr>
<tr><td><code>:</code></td><td><code>ident: expr</code></td><td>结构体字段初始化器</td><td></td></tr>
<tr><td><code>;</code></td><td><code>expr;</code></td><td>语句和项终止符</td><td></td></tr>
<tr><td><code>&lt;</code></td><td><code>expr &lt; expr</code></td><td>小于比较</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>expr &lt;= expr</code></td><td>小于等于比较</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>=</code></td><td><code>var = expr</code></td><td>赋值</td><td></td></tr>
<tr><td><code>==</code></td><td><code>expr == expr</code></td><td>相等比较</td><td><code>PartialEq</code></td></tr>
<tr><td><code>=&gt;</code></td><td><code>pat =&gt; expr</code></td><td>匹配分支语法的一部分</td><td></td></tr>
<tr><td><code>&gt;</code></td><td><code>expr &gt; expr</code></td><td>大于比较</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;=</code></td><td><code>expr &gt;= expr</code></td><td>大于等于比较</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>^</code></td><td><code>expr ^ expr</code></td><td>按位异或 (XOR)</td><td><code>BitXor</code></td></tr>
<tr><td><code>|</code></td><td><code>expr | expr</code></td><td>按位或 (OR)</td><td><code>BitOr</code></td></tr>
<tr><td><code>||</code></td><td><code>expr || expr</code></td><td>短路逻辑或 (OR)</td><td></td></tr>
<tr><td><code>?</code></td><td>expr?</td><td>错误传播</td><td></td></tr>
</tbody>
</table>
</div>
<p><span class="caption">表 B-1: 运算符</span></p>
<h2 id="非运算符符号"><a class="header" href="#非运算符符号">非运算符符号</a></h2>
<p>以下列表包含所有不用作运算符的符号；也就是说，它们的行为与函数或方法调用不同。</p>
<p>表 B-2 显示了独自出现并在各种位置有效的符号。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>符号</th><th>解释</th></tr>
</thead>
<tbody>
<tr><td><code>..._u8</code>, <code>..._usize</code>, <code>..._bool</code>, etc.</td><td>特定类型的数字字面量</td></tr>
<tr><td><code>"..."</code></td><td>字符串字面量</td></tr>
<tr><td><code>'...'</code></td><td>短字符串，最多 31 个 ASCII 字符</td></tr>
<tr><td><code>_</code></td><td>“忽略”模式绑定</td></tr>
</tbody>
</table>
</div>
<p><span class="caption">表 B-2: 独立语法</span></p>
<p>表 B-3 显示了用于模块层次路径上下文中访问项的符号。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>符号</th><th>解释</th></tr>
</thead>
<tbody>
<tr><td><code>ident::ident</code></td><td>命名空间路径</td></tr>
<tr><td><code>super::path</code></td><td>当前模块父级相对路径</td></tr>
<tr><td><code>trait::method(...)</code></td><td>通过命名定义方法的 trait 来消除方法调用的歧义</td></tr>
</tbody>
</table>
</div>
<p><span class="caption">表 B-3: 路径相关语法</span></p>
<p>表 B-4 显示了用于指定泛型类型参数上下文中的符号。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>符号</th><th>解释</th></tr>
</thead>
<tbody>
<tr><td><code>path&lt;...&gt;</code></td><td>指定类型中的泛型类型参数 (例如 <code>Array&lt;u8&gt;</code>)</td></tr>
<tr><td><code>path::&lt;...&gt;</code>, <code>method::&lt;...&gt;</code></td><td>指定表达式中泛型类型、函数或方法的参数；通常被称为 turbofish</td></tr>
<tr><td><code>fn ident&lt;...&gt; ...</code></td><td>定义泛型函数</td></tr>
<tr><td><code>struct ident&lt;...&gt; ...</code></td><td>定义泛型结构体</td></tr>
<tr><td><code>enum ident&lt;...&gt; ...</code></td><td>定义泛型枚举</td></tr>
<tr><td><code>impl&lt;...&gt; ...</code></td><td>定义泛型实现</td></tr>
</tbody>
</table>
</div>
<p><span class="caption">表 B-4: 泛型</span></p>
<p>表 B-5 显示了用于在项上指定属性的上下文中的符号。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>符号</th><th>解释</th></tr>
</thead>
<tbody>
<tr><td><code>#[derive(...)]</code></td><td>自动为类型实现 trait</td></tr>
<tr><td><code>#[inline]</code></td><td>给编译器的提示，允许内联注释的函数</td></tr>
<tr><td><code>#[inline(always)]</code></td><td>给编译器的提示，系统地内联注释的函数</td></tr>
<tr><td><code>#[inline(never)]</code></td><td>给编译器的提示，从不内联注释的函数</td></tr>
<tr><td><code>#[must_use]</code></td><td>给编译器的提示，必须使用函数或特定返回类型的返回值</td></tr>
<tr><td><code>#[generate_trait]</code></td><td>自动为 impl 生成 trait</td></tr>
<tr><td><code>#[available_gas(...)]</code></td><td>设置执行函数可用的最大 gas 数量</td></tr>
<tr><td><code>#[panic_with('...', wrapper_name)]</code></td><td>为注释函数创建一个包装器，如果函数返回 <code>None</code> 或 <code>Err</code>，则该包装器将 panic，并使用给定的数据作为 panic 错误</td></tr>
<tr><td><code>#[test]</code></td><td>将函数描述为测试函数</td></tr>
<tr><td><code>#[cfg(...)]</code></td><td>配置属性，特别用于通过 <code>#[cfg(test)]</code> 配置 <code>tests</code> 模块</td></tr>
<tr><td><code>#[should_panic]</code></td><td>指定测试函数必须 panic</td></tr>
<tr><td><code>#[starknet::contract]</code></td><td>定义 Starknet 智能合约</td></tr>
<tr><td><code>#[starknet::interface]</code></td><td>定义 Starknet 接口</td></tr>
<tr><td><code>#[starknet::component]</code></td><td>定义 Starknet 组件</td></tr>
<tr><td><code>#[starknet::embeddable]</code></td><td>定义隔离的可嵌入实现，可以注入任何智能合约</td></tr>
<tr><td><code>#[embeddable_as(...)]</code></td><td>在组件内定义可嵌入实现</td></tr>
<tr><td><code>#[storage]</code></td><td>定义智能合约的存储</td></tr>
<tr><td><code>#[event]</code></td><td>定义智能合约中的事件</td></tr>
<tr><td><code>#[constructor]</code></td><td>定义智能合约中的构造函数</td></tr>
<tr><td><code>#[abi(embed_v0)]</code></td><td>定义 trait 的实现，将 impl 的函数作为合约的入口点公开</td></tr>
<tr><td><code>#[abi(per_item)]</code></td><td>允许单独定义 impl 内部函数的入口点类型</td></tr>
<tr><td><code>#[external(v0)]</code></td><td>当使用 <code>#[abi(per_item)]</code> 时定义外部函数</td></tr>
<tr><td><code>#[flat]</code></td><td>定义不嵌套的 <code>Event</code> 枚举变体，在序列化过程中忽略变体名称，在使用 Starknet 组件时对于可组合性非常有用</td></tr>
<tr><td><code>#[key]</code></td><td>定义索引的 <code>Event</code> 枚举字段，允许更有效地查询和过滤事件</td></tr>
</tbody>
</table>
</div>
<p><span class="caption">表 B-5: 属性</span></p>
<p>表 B-6 显示了用于调用或定义宏的上下文中的符号。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>符号</th><th>解释</th></tr>
</thead>
<tbody>
<tr><td><code>print!</code></td><td>内联打印</td></tr>
<tr><td><code>println!</code></td><td>在新行打印</td></tr>
<tr><td><code>array!</code></td><td>实例化并填充数组</td></tr>
<tr><td><code>panic!</code></td><td>调用 <code>panic</code> 函数并允许提供超过 31 个字符的错误消息</td></tr>
<tr><td><code>assert!</code></td><td>评估布尔值，如果为 <code>false</code> 则 panic</td></tr>
<tr><td><code>assert_eq!</code></td><td>评估相等性，如果不相等则 panic</td></tr>
<tr><td><code>assert_ne!</code></td><td>评估相等性，如果相等则 panic</td></tr>
<tr><td><code>assert_lt!</code></td><td>评估比较，如果大于或等于则 panic</td></tr>
<tr><td><code>assert_le!</code></td><td>评估比较，如果大于则 panic</td></tr>
<tr><td><code>assert_gt!</code></td><td>评估比较，如果小于或等于则 panic</td></tr>
<tr><td><code>assert_ge!</code></td><td>评估比较，如果小于则 panic</td></tr>
<tr><td><code>format!</code></td><td>格式化字符串并返回包含内容的 <code>ByteArray</code></td></tr>
<tr><td><code>write!</code></td><td>在格式化程序中写入格式化字符串</td></tr>
<tr><td><code>writeln!</code></td><td>在格式化程序中在新行写入格式化字符串</td></tr>
<tr><td><code>get_dep_component!</code></td><td>从组件内状态的快照返回请求的组件状态</td></tr>
<tr><td><code>get_dep_component_mut!</code></td><td>从组件内状态的引用返回请求的组件状态</td></tr>
<tr><td><code>component!</code></td><td>在 Starknet 合约中使用的宏，用于将组件嵌入合约</td></tr>
</tbody>
</table>
</div>
<p><span class="caption">表 B-6: 宏</span></p>
<p>表 B-7 显示了创建注释的符号。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>符号</th><th>解释</th></tr>
</thead>
<tbody>
<tr><td><code>//</code></td><td>行注释</td></tr>
</tbody>
</table>
</div>
<p><span class="caption">表 B-7: 注释</span></p>
<p>表 B-8 显示了使用元组的上下文中的符号。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>符号</th><th>解释</th></tr>
</thead>
<tbody>
<tr><td><code>()</code></td><td>空元组（又名单元 unit），即是字面量也是类型</td></tr>
<tr><td><code>(expr)</code></td><td>括号表达式</td></tr>
<tr><td><code>(expr,)</code></td><td>单元素元组表达式</td></tr>
<tr><td><code>(type,)</code></td><td>单元素元组类型</td></tr>
<tr><td><code>(expr, ...)</code></td><td>元组表达式</td></tr>
<tr><td><code>(type, ...)</code></td><td>元组类型</td></tr>
<tr><td><code>expr(expr, ...)</code></td><td>函数调用表达式；也用于初始化元组 <code>struct</code> 和元组 <code>enum</code> 变体</td></tr>
</tbody>
</table>
</div>
<p><span class="caption">表 B-8: 元组</span></p>
<p>表 B-9 显示了使用大括号的上下文。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>上下文</th><th>解释</th></tr>
</thead>
<tbody>
<tr><td><code>{...}</code></td><td>块表达式</td></tr>
<tr><td><code>Type {...}</code></td><td><code>struct</code> 字面量</td></tr>
</tbody>
</table>
</div>
<p><span class="caption">表 B-9: 大括号</span></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="附录-c---可派生-traits"><a class="header" href="#附录-c---可派生-traits">附录 C - 可派生 Traits</a></h1>
<p>在书中各个地方，我们讨论了 <code>derive</code> 属性，你可以将其应用于结构体或枚举定义。<code>derive</code> 属性会生成代码，为你用 <code>derive</code> 语法注释的类型实现默认 trait。</p>
<p>在本附录中，我们提供了一个综合参考，详细介绍了标准库中与 <code>derive</code> 属性兼容的所有 traits。</p>
<p>此处列出的这些 traits 是核心库定义的唯一可以使用 <code>derive</code> 在你的类型上实现的 traits。标准库中定义的其他 traits 没有合理的默认行为，因此由你来以对你试图实现的目标有意义的方式实现它们。</p>
<h2 id="drop-和-destruct"><a class="header" href="#drop-和-destruct">Drop 和 Destruct</a></h2>
<p>当移出作用域时，变量首先需要被移动。这就是 <code>Drop</code> trait 介入的地方。你可以 <a href="#no-op-destruction-the-drop-trait">在此</a> 找到有关其用法的更多详细信息。</p>
<p>此外，字典在离开作用域之前需要被 squash（压扁/压缩）。手动对每个字典调用 <code>squash</code> 方法很快就会变得多余。<code>Destruct</code> trait 允许字典在离开作用域时自动被 squash。你也可以 <a href="#destruction-with-a-side-effect-the-destruct-trait">在此</a> 找到有关 <code>Destruct</code> 的更多信息。</p>
<h2 id="用于复制值的-clone-和-copy"><a class="header" href="#用于复制值的-clone-和-copy">用于复制值的 <code>Clone</code> 和 <code>Copy</code></a></h2>
<p><code>Clone</code> trait 提供了显式创建值深拷贝的功能。</p>
<p>派生 <code>Clone</code> 实现了 <code>clone</code> 方法，该方法反过来对类型的每个组件调用 clone。这意味着类型中的所有字段或值也必须实现 <code>Clone</code> 才能派生 <code>Clone</code>。</p>
<p>这是一个简单的示例：</p>
<pre><code class="language-cairo">#[derive(Clone, Drop)]
struct A {
    item: felt252,
}

#[executable]
fn main() {
    let first_struct = A { item: 2 };
    let second_struct = first_struct.clone();
    assert!(second_struct.item == 2, "Not equal");
}
</code></pre>
<p><code>Copy</code> trait 允许复制值。你可以在其部分都实现 <code>Copy</code> 的任何类型上派生 <code>Copy</code>。</p>
<p>示例：</p>
<pre><code class="language-cairo">#[derive(Copy, Drop)]
struct A {
    item: felt252,
}

#[executable]
fn main() {
    let first_struct = A { item: 2 };
    let second_struct = first_struct;
    // Copy Trait prevents first_struct from moving into second_struct
    assert!(second_struct.item == 2, "Not equal");
    assert!(first_struct.item == 2, "Not Equal");
}
</code></pre>
<h2 id="用于打印和调试的-debug"><a class="header" href="#用于打印和调试的-debug">用于打印和调试的 <code>Debug</code></a></h2>
<p><code>Debug</code> trait 启用格式字符串中的调试格式化，你可以通过在 <code>{}</code> 占位符内添加 <code>:?</code> 来指示。</p>
<p>它允许你为了调试目的打印类型的实例，因此你和使用此类型的其他程序员可以在程序执行的特定点检查实例。</p>
<p>例如，如果你想打印 <code>Point</code> 类型变量的值，你可以这样做：</p>
<pre><code class="language-cairo">#[derive(Copy, Drop, Debug)]
struct Point {
    x: u8,
    y: u8,
}

#[executable]
fn main() {
    let p = Point { x: 1, y: 3 };
    println!("{:?}", p);
}
</code></pre>
<pre><code class="language-shell">scarb execute
Point { x: 1, y: 3 }
</code></pre>
<p>例如，当在测试中使用 <code>assert_xx!</code> 宏时，需要 <code>Debug</code> trait。如果相等性或比较断言失败，这些宏将打印作为参数给出的实例的值，以便程序员可以看到为什么两个实例不相等。</p>
<h2 id="用于默认值的-default"><a class="header" href="#用于默认值的-default">用于默认值的 <code>Default</code></a></h2>
<p><code>Default</code> trait 允许创建类型的默认值。最常见的默认值为零。标准库中的所有原始类型都实现了 <code>Default</code>。</p>
<p>如果你想在复合类型上派生 <code>Default</code>，它的每个元素必须已经实现 <code>Default</code>。如果你有一个 <a href="#枚举"><code>enum</code></a> 类型，你必须通过在其变体之一上使用 <code>#[default]</code> 属性来声明其默认值。</p>
<p>一个例子：</p>
<pre><code class="language-cairo">#[derive(Default, Drop)]
struct A {
    item1: felt252,
    item2: u64,
}

#[derive(Default, Drop, PartialEq)]
enum CaseWithDefault {
    A: felt252,
    B: u128,
    #[default]
    C: u64,
}

#[executable]
fn main() {
    let defaulted: A = Default::default();
    assert!(defaulted.item1 == 0_felt252, "item1 mismatch");
    assert!(defaulted.item2 == 0_u64, "item2 mismatch");

    let default_case: CaseWithDefault = Default::default();
    assert!(default_case == CaseWithDefault::C(0_u64), "case mismatch");
}
</code></pre>
<h2 id="用于相等比较的-partialeq"><a class="header" href="#用于相等比较的-partialeq">用于相等比较的 <code>PartialEq</code></a></h2>
<p><code>PartialEq</code> trait 允许比较类型的实例是否相等，从而启用 <code>==</code> 和 <code>!=</code> 运算符。</p>
<p>当在结构体上派生 <code>PartialEq</code> 时，仅当所有字段都相等时，两个实例才相等；如果任何字段不同，则它们不相等。当为枚举派生时，每个变体等于其自身，不等于其他变体。</p>
<p>如果你无法派生它或者你想实现自定义规则，你可以为你的类型编写自己的 <code>PartialEq</code> trait 实现。在以下示例中，我们为 <code>PartialEq</code> 编写了一个实现，其中我们认为如果两个矩形具有相同的面积，则它们相等：</p>
<pre><code class="language-cairo">#[derive(Copy, Drop)]
struct Rectangle {
    width: u64,
    height: u64,
}

impl PartialEqImpl of PartialEq&lt;Rectangle&gt; {
    fn eq(lhs: @Rectangle, rhs: @Rectangle) -&gt; bool {
        (*lhs.width) * (*lhs.height) == (*rhs.width) * (*rhs.height)
    }

    fn ne(lhs: @Rectangle, rhs: @Rectangle) -&gt; bool {
        (*lhs.width) * (*lhs.height) != (*rhs.width) * (*rhs.height)
    }
}

#[executable]
fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 50, height: 30 };

    println!("Are rect1 and rect2 equal? {}", rect1 == rect2);
}
</code></pre>
<p>在测试中使用 <code>assert_eq!</code> 宏时需要 <code>PartialEq</code> trait，这需要能够比较两个类型实例的相等性。</p>
<p>这是一个例子：</p>
<pre><code class="language-cairo">#[derive(PartialEq, Drop)]
struct A {
    item: felt252,
}

#[executable]
fn main() {
    let first_struct = A { item: 2 };
    let second_struct = A { item: 2 };
    assert!(first_struct == second_struct, "Structs are different");
}
</code></pre>
<h2 id="使用-serde-进行序列化"><a class="header" href="#使用-serde-进行序列化">使用 <code>Serde</code> 进行序列化</a></h2>
<p><code>Serde</code> 为你的 crate 中定义的数据结构提供 <code>serialize</code> 和 <code>deserialize</code> 函数的 trait 实现。它允许你将结构转换为数组（或反之）。</p>
<blockquote>
<p><strong><a href="https://zh.wikipedia.org/wiki/序列化">序列化 (Serialization)</a></strong> 是将数据结构转换为易于存储或传输的格式的过程。假设你正在运行一个程序，并希望持久化其状态以便稍后恢复。为此，你可以获取程序正在使用的每个对象并保存它们的信息，例如保存在文件中。这是序列化的简化版本。现在，如果你想使用此保存的状态恢复程序，你将执行 <strong>反序列化 (deserialization)</strong>，这意味着从保存的源加载对象的状态。</p>
</blockquote>
<p>例如：</p>
<pre><code class="language-cairo">// TAG: does_not_run

#[derive(Serde, Drop)]
struct A {
    item_one: felt252,
    item_two: felt252,
}

#[executable]
fn main() {
    let first_struct = A { item_one: 2, item_two: 99 };
    let mut output_array = array![];
    first_struct.serialize(ref output_array);
    panic(output_array);
}

</code></pre>
<p>如果你运行 <code>main</code> 函数，输出将是：</p>
<pre><code class="language-shell">Run panicked with [2, 99 ('c'), ].
</code></pre>
<p>我们可以在这里看到我们的结构体 <code>A</code> 已被序列化到输出数组中。注意，<code>serialize</code> 函数将你要转换为数组的类型的快照作为参数。这就是为什么这里需要为 <code>A</code> 派生 <code>Drop</code>，因为 <code>main</code> 函数保留了 <code>first_struct</code> 结构体的所有权。</p>
<p>此外，我们可以使用 <code>deserialize</code> 函数将序列化的数组转换回我们的 <code>A</code> 结构体。</p>
<p>这是一个例子：</p>
<pre><code class="language-cairo">#[derive(Serde, Drop)]
struct A {
    item_one: felt252,
    item_two: felt252,
}

#[executable]
fn main() {
    let first_struct = A { item_one: 2, item_two: 99 };
    let mut output_array = array![];
    first_struct.serialize(ref output_array);
    let mut span_array = output_array.span();
    let deserialized_struct: A = Serde::&lt;A&gt;::deserialize(ref span_array).unwrap();
}
</code></pre>
<p>在这里，我们将序列化的数组 span 转换回结构体 <code>A</code>。<code>deserialize</code> 返回一个 <code>Option</code>，所以我们需要 unwrap 它。这也是为什么这里需要为 <code>A</code> 派生 <code>Drop</code>，因为 <code>main</code> 函数保留了 <code>first_struct</code> 结构体的所有权。当使用 <code>deserialize</code> 时，我们还需要指定我们要反序列化成的类型。</p>
<h2 id="使用-hash-进行哈希"><a class="header" href="#使用-hash-进行哈希">使用 <code>Hash</code> 进行哈希</a></h2>
<p>可以在结构体和枚举上派生 <code>Hash</code> trait。这允许使用任何可用的哈希函数轻松地对它们进行哈希。对于要派生 <code>Hash</code> 属性的结构体或枚举，所有字段或变体本身都需要是可哈希的。</p>
<p>你可以参考 <a href="#哈希-hashes">哈希章节</a> 以获取有关如何对复杂数据类型进行哈希的更多信息。</p>
<h2 id="使用-starknetstore-进行-starknet-存储"><a class="header" href="#使用-starknetstore-进行-starknet-存储">使用 <code>starknet::Store</code> 进行 Starknet 存储</a></h2>
<p><code>starknet::Store</code> trait 仅在构建 <a href="#智能合约简介-1">Starknet</a> 合约时相关。通过自动实现必要的读写函数，它允许类型在智能合约存储中使用。</p>
<p>你可以在 <a href="#合约存储-contract-storage">合约存储章节</a> 中找到有关 Starknet 存储内部工作原理的详细信息。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="附录-d---cairo-prelude"><a class="header" href="#附录-d---cairo-prelude">附录 D - Cairo Prelude</a></h1>
<h2 id="prelude"><a class="header" href="#prelude">Prelude</a></h2>
<p>Cairo prelude 是常用模块、函数、数据类型和 traits 的集合，它们会自动引入 Cairo crate 中每个模块的作用域，而无需显式导入语句。Cairo 的 prelude 提供了开发人员开始编写 Cairo 程序和智能合约所需的基本构建块。</p>
<p>核心库 prelude 定义在 corelib crate 的 <em><a href="https://github.com/starkware-libs/cairo/blob/main/corelib/src/lib.cairo">lib.cairo</a></em> 文件中，包含 Cairo 的原始数据类型、traits、运算符和实用函数。这包括：</p>
<ul>
<li>数据类型：整数、布尔值、数组、字典等。</li>
<li>Traits：算术、比较和序列化操作的行为</li>
<li>运算符：算术、逻辑、按位</li>
<li>实用函数 - 数组、映射、装箱 (boxing) 等的助手</li>
</ul>
<p>核心库 prelude 提供了基本 Cairo 程序所需的基础编程结构和操作，而无需显式导入元素。由于核心库 prelude 是自动导入的，因此其内容可在任何 Cairo crate 中使用，无需显式导入。这防止了重复并提供了更好的开发体验 (devX)。这就是允许你使用 <code>ArrayTrait::append()</code> 或 <code>Default</code> trait 而无需显式将它们引入作用域的原因。</p>
<p>你可以选择使用哪个 prelude。例如，在 <em>Scarb.toml</em> 配置文件中添加 <code>edition = "2024_07"</code> 将加载 2024 年 7 月的 prelude。注意，当你使用 <code>scarb new</code> 命令创建新项目时，<em>Scarb.toml</em> 文件将自动包含 <code>edition = "2024_07"</code>。不同的 prelude 版本将公开不同的函数和 traits，因此在 <em>Scarb.toml</em> 文件中指定正确的版本非常重要。通常，你会希望使用该最新版本开始新项目，并随着新版本的发布迁移到更新的版本。</p>
<h2 id="cairo-版本-editions"><a class="header" href="#cairo-版本-editions">Cairo 版本 (editions)</a></h2>
<p>以下是可用 Cairo 版本（即 prelude 版本）及其详细信息的列表：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>版本</th><th>详情</th></tr>
</thead>
<tbody>
<tr><td><code>2024-07</code></td><td><a href="https://community.starknet.io/t/cairo-v2-7-0-is-coming/114362#the-2024_07-edition-3">2024-07 的详细信息</a></td></tr>
<tr><td><code>2023-11</code></td><td><a href="https://community.starknet.io/t/cairo-v2-5-0-is-out/112807#the-pub-keyword-9">2023-11 的详细信息</a></td></tr>
<tr><td><code>2023-10</code> / <code>2023-1</code></td><td><a href="https://community.starknet.io/t/cairo-v2-4-0-is-out/109275#editions-and-the-introduction-of-preludes-10">2023-10 的详细信息</a></td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="附录-e---常见错误信息"><a class="header" href="#附录-e---常见错误信息">附录 E - 常见错误信息</a></h1>
<p>在编写 Cairo 代码时，你可能会遇到错误信息。其中一些非常频繁地发生，这就是为什么我们将在这个附录中列出最常见的错误信息，以帮助你解决常见问题。</p>
<ul>
<li>
<p><code>Variable not dropped.</code>: 这个错误信息意味着你正试图让一个具有未实现 <code>Drop</code> trait 的类型的变量离开作用域，而没有销毁它。确保在函数执行结束时需要被丢弃的变量实现了 <code>Drop</code> trait 或 <code>Destruct</code> trait。请参阅 <a href="#destroying-values---example-with-feltdict">所有权</a> 章节。</p>
</li>
<li>
<p><code>Variable was previously moved.</code>: 这个错误信息意味着你正试图使用一个所有权已经转移给另一个函数的变量。当变量没有实现 <code>Copy</code> trait 时，它按值传递给函数，变量的所有权转移给函数。在所有权转移后，该变量不能再在当前上下文中使用。在这种情况下，使用 <code>clone</code> 方法通常很有用。</p>
</li>
<li>
<p><code>error: Trait has no implementation in context: core::fmt::Display::&lt;package_name::struct_name&gt;</code>:
如果尝试在 <code>print!</code> 或 <code>println!</code> 宏中使用 <code>{}</code> 占位符打印自定义数据类型的实例，则会遇到此错误消息。为了解决这个问题，你要么需要为你的类型手动实现 <code>Display</code> trait，要么使用 <code>Debug</code> trait，通过对你的类型应用 <code>derive(Debug)</code>，允许通过在 <code>{}</code> 占位符中添加 <code>:?</code> 来打印你的实例。</p>
</li>
<li>
<p><code>Got an exception while executing a hint: Hint Error: Failed to deserialize param #x.</code>:
这个错误意味着执行失败，因为调用了一个入口点而没有提供预期的参数。确保调用入口点时提供的参数是正确的。<code>u256</code> 变量有一个经典问题，它实际上是 2 个 <code>u128</code> 的结构体。因此，当调用接受 <code>u256</code> 作为参数的函数时，你需要传递 2 个值。</p>
</li>
<li>
<p><code>Item path::item is not visible in this context.</code>: 这个错误信息让我们知道引入项到作用域的路径是正确的，但是存在可见性问题。在 Cairo 中，默认情况下所有项对父模块都是私有的。要解决此问题，请确保通往项的路径上的所有模块以及项本身都声明为 <code>pub(crate)</code> 或 <code>pub</code> 以便可以访问它们。</p>
</li>
<li>
<p><code>Identifier not found.</code>: 这个错误信息有点不具体，但可能表明：</p>
<ul>
<li>变量在声明之前就被使用了。确保使用 <code>let</code> 关键字声明变量。</li>
<li>将项引入作用域的路径定义错误。确保使用有效路径。</li>
</ul>
</li>
</ul>
<h2 id="starknet-组件相关错误信息"><a class="header" href="#starknet-组件相关错误信息">Starknet 组件相关错误信息</a></h2>
<p>在尝试实现组件时，你可能会遇到一些错误。不幸的是，其中一些缺乏有意义的错误信息来帮助调试。本节旨在为你提供一些指针来帮助你调试代码。</p>
<ul>
<li>
<p><code>Trait not found. Not a trait.</code>: 当你没有在合约中正确导入组件的 impl 块时，可能会发生此错误。确保遵守以下语法：</p>
<pre><code class="language-cairo noplayground">#[abi(embed_v0)]
impl IMPL_NAME = PATH_TO_COMPONENT::EMBEDDED_NAME&lt;ContractState&gt;
</code></pre>
</li>
<li>
<p><code>Plugin diagnostic: name is not a substorage member in the contract's Storage. Consider adding to Storage: (...)</code>:
编译器通过为你提供有关要采取的操作的建议来帮助你调试此问题。基本上，你忘记了将组件的存储添加到合约的存储中。确保将带有 <code>#[substorage(v0)]</code> 属性注释的组件存储路径添加到合约的存储中。</p>
</li>
<li>
<p><code>Plugin diagnostic: name is not a nested event in the contract's Event enum. Consider adding to the Event enum:</code>
类似于前一个错误，编译器告诉你忘记了将组件的事件添加到合约的事件中。确保将组件事件的路径添加到合约的事件中。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="附录-f---有用的开发工具"><a class="header" href="#附录-f---有用的开发工具">附录 F - 有用的开发工具</a></h1>
<p>在本附录中，我们将讨论 Cairo 项目提供的一些有用的开发工具。我们将了解自动格式化、应用警告修复的快速方法、linter 以及与 IDE 的集成。</p>
<h2 id="使用-scarb-fmt-自动格式化"><a class="header" href="#使用-scarb-fmt-自动格式化">使用 <code>scarb fmt</code> 自动格式化</a></h2>
<p>可以使用 <code>scarb fmt</code> 命令格式化 Scarb 项目。如果你直接使用 Cairo 二进制文件，则可以运行 <code>cairo-format</code>。许多协作项目使用 <code>scarb fmt</code> 来防止关于编写 Cairo 时使用哪种风格的争论：每个人都使用该工具格式化他们的代码。</p>
<p>要格式化任何 Cairo 项目，请在项目目录中输入以下内容：</p>
<pre><code class="language-bash">scarb fmt
</code></pre>
<p>对于你不希望 <code>scarb fmt</code> 破坏的内容，请使用 <code>#[cairofmt::skip]</code>：</p>
<pre><code class="language-cairo noplayground">#[cairofmt::skip]
let table: Array&lt;ByteArray&gt; = array![
    "oxo",
    "xox",
    "oxo",
];
</code></pre>
<h2 id="使用-cairo-language-server-进行-ide-集成"><a class="header" href="#使用-cairo-language-server-进行-ide-集成">使用 <code>cairo-language-server</code> 进行 IDE 集成</a></h2>
<p>为了帮助 IDE 集成，Cairo 社区建议使用 <a href="https://github.com/software-mansion/cairols"><code>cairo-language-server</code></a><!-- ignore -->。此工具是一组以编译器为中心的实用程序，使用 <a href="http://langserver.org/">语言服务器协议 (Language Server Protocol)</a><!--
ignore -->，这是 IDE 和编程语言相互通信的规范。不同的客户端可以使用 <code>cairo-language-server</code>，例如 <a href="https://marketplace.visualstudio.com/items?itemName=starkware.cairo1">Visual Studio Code 的 Cairo 扩展</a>。</p>
<p>访问 <code>vscode-cairo</code> <a href="https://marketplace.visualstudio.com/items?itemName=starkware.cairo1">页面</a><!-- ignore --> 以在 VSCode 上安装它。你将获得自动完成、跳转到定义和内联错误等功能。</p>
<blockquote>
<p>注意：如果你安装了 Scarb，它应该可以与 Cairo VSCode 扩展开箱即用，无需手动安装语言服务器。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="智能合约简介-1"><a href="#智能合约简介-1" class="header">智能合约简介</a></h1>
<hr>
<h2 id="meta-在这个为使用-cairo-的开发人员量身定制的全面介绍中探索智能合约的基础知识了解智能合约如何工作以及它们在区块链技术中的作用"><a class="header" href="#meta-在这个为使用-cairo-的开发人员量身定制的全面介绍中探索智能合约的基础知识了解智能合约如何工作以及它们在区块链技术中的作用">meta:
“在这个为使用 Cairo 的开发人员量身定制的全面介绍中探索智能合约的基础知识。了解智能合约如何工作以及它们在区块链技术中的作用。”</a></h2>
<h1 id="智能合约简介"><a class="header" href="#智能合约简介">智能合约简介</a></h1>
<p>本章将为你提供关于什么是智能合约、它们的用途以及为什么区块链开发人员会使用 Cairo 和 Starknet 的高级介绍。如果你已经熟悉区块链编程，请随意跳过本章。不过，最后一部分可能仍然很有趣。</p>
<h2 id="智能合约---简介"><a class="header" href="#智能合约---简介">智能合约 - 简介</a></h2>
<p>随着以太坊的诞生，智能合约变得越来越流行和普及。智能合约本质上是部署在区块链上的程序。“智能合约”这个术语有点误导，因为它们既不“智能”也不完全是“合约”，而是根据特定输入执行的代码和指令。它们主要由两个组件组成：存储和函数。一旦部署，用户可以通过启动包含执行数据（调用哪个函数以及使用什么输入）的区块链交易来与智能合约交互。智能合约可以修改和读取底层区块链的存储。智能合约有自己的地址，被认为是一个区块链账户，这意味着它可以持有代币。</p>
<p>用于编写智能合约的编程语言因区块链而异。例如，在以太坊和 <a href="https://ethereum.org/en/developers/docs/evm/">兼容 EVM 的生态系统</a> 上，最常用的语言是 Solidity，而在 Starknet 上，它是 Cairo。代码编译的方式也根据区块链而有所不同。在以太坊上，Solidity 被编译成字节码。在 Starknet 上，Cairo 被编译成 Sierra，然后编译成 Cairo 汇编 (CASM)。</p>
<p>智能合约拥有几个独特的特征。它们是 <strong>无需许可的 (permissionless)</strong>，这意味着任何人都可以网络上部署智能合约（当然是在去中心化区块链的背景下）。智能合约也是 <strong>透明的 (transparent)</strong>；任何人都可以访问智能合约存储的数据。组成合约的代码也可以是透明的，从而实现 <strong>可组合性 (composability)</strong>。这允许开发人员编写使用其他智能合约的智能合约。智能合约只能访问和交互其部署所在的区块链上的数据。它们需要第三方软件（称为 <em>预言机 Oracles</em>）来访问外部数据（例如代币的价格）。</p>
<p>为了让开发人员构建可以相互交互的智能合约，需要知道其他合约是什么样子的。因此，以太坊开发人员开始为智能合约开发建立标准，即 <code>ERCxx</code>。两个最常用和著名的标准是 <code>ERC20</code>（用于构建像 <code>USDC</code>、<code>DAI</code> 或 <code>STARK</code> 这样的代币）和 <code>ERC721</code>（用于像 <code>CryptoPunks</code> 或 <code>Everai</code> 这样的 NFT（非同质化代币））。</p>
<h2 id="智能合约---用例"><a class="header" href="#智能合约---用例">智能合约 - 用例</a></h2>
<p>智能合约有许多可能的用例。唯一的限制是区块链的技术约束和开发人员的创造力。</p>
<h3 id="defi"><a class="header" href="#defi">DeFi</a></h3>
<p>目前，智能合约的主要用例类似于以太坊或比特币，本质上是处理资金。在比特币承诺的替代支付系统的背景下，以太坊上的智能合约使得创建不再依赖传统金融中介的去中心化金融应用程序成为可能。这就是我们要说的 DeFi（去中心化金融）。DeFi 由各种项目组成，如借贷应用程序、去中心化交易所 (DEX)、链上衍生品、稳定币、去中心化对冲基金、保险等等。</p>
<h3 id="代币化-tokenization"><a class="header" href="#代币化-tokenization">代币化 (Tokenization)</a></h3>
<p>智能合约可以促进现实世界资产的代币化，例如房地产、艺术品或贵金属。代币化将资产分割成数字代币，可以在区块链平台上轻松交易和管理。这可以增加流动性，实现部分所有权，并简化买卖过程。</p>
<h3 id="投票"><a class="header" href="#投票">投票</a></h3>
<p>智能合约可用于创建安全透明的投票系统。投票可以记录在区块链上，确保不可篡改和透明度。智能合约可以自动统计选票并宣布结果，最大限度地减少欺诈或操纵的可能性。</p>
<h3 id="版税-royalties"><a class="header" href="#版税-royalties">版税 (Royalties)</a></h3>
<p>智能合约可以为艺术家、音乐家和其他内容创作者自动支付版税。当消费或出售一份内容时，智能合约可以自动计算并将版税分发给合法的所有者，确保公平的报酬并减少对中介的需求。</p>
<h3 id="去中心化身份-dids"><a class="header" href="#去中心化身份-dids">去中心化身份 (DIDs)</a></h3>
<p>智能合约可用于创建和管理数字身份，允许个人控制其个人信息并安全地与第三方共享。智能合约可以验证用户身份的真实性，并根据用户的凭据自动授予或撤销对特定服务的访问权限。</p>
<br />
<br />
随着以太坊的不断成熟，我们可以预期智能合约的用例和应用将进一步扩展，带来令人兴奋的新机会并重塑传统系统，使其变得更好。
<h2 id="starknet-和-cairo-的兴起"><a class="header" href="#starknet-和-cairo-的兴起">Starknet 和 Cairo 的兴起</a></h2>
<p>以太坊作为最广泛使用和最具弹性的智能合约平台，成为了其自身成功的受害者。随着一些前面提到的用例（主要是 DeFi）的迅速采用，执行交易的成本变得极高，使得网络几乎无法使用。生态系统中的工程师和研究人员开始致力于解决这种可扩展性问题的解决方案。</p>
<p>区块链领域一个著名的三难困境（区块链不可能三角）指出，很难同时实现高水平的可扩展性、去中心化和安全性；必须做出权衡。以太坊处于去中心化和安全性的交叉点。最终决定以太坊的目的将是作为一个安全的结算层，而复杂的计算将被转移到建立在以太坊之上的其他网络上。这些被称为 Layer 2 (L2)。
L2 主要有两种类型：乐观汇总 (optimistic rollups) 和有效性汇总 (validity rollups)。这两种方法都涉及将大量交易压缩和批处理在一起，计算新状态，并将结果结算在以太坊 (L1) 上。区别在于结果在 L1 上结算的方式。对于乐观汇总，新状态默认被认为是有效的，但有一个 7 天的窗口期供节点识别恶意交易。</p>
<p>相比之下，有效性汇总（如 Starknet）使用密码学来证明新状态已被正确计算。这就是 STARKs 的目的，这种密码学技术可以允许有效性汇总比乐观汇总更显著地扩展。你可以从 Starkware 的 Medium <a href="https://medium.com/starkware/starks-starkex-and-starknet-9a426680745a">文章</a> 中了解有关 STARKs 的更多信息，这是一个很好的入门读物。</p>
<blockquote>
<p>Starknet 的架构在 <a href="https://docs.starknet.io/documentation/architecture_and_concepts/">Starknet 文档</a> 中有详细描述，这是了解更多关于 Starknet 网络的绝佳资源。</p>
</blockquote>
<p>还记得 Cairo 吗？事实上，它是一种专门为了与 STARKs 一起工作并使它们具有通用性而开发的语言。使用 Cairo，我们可以编写 <strong>可证明代码 (provable code)</strong>。在 Starknet 的背景下，这允许证明从一个状态到另一个状态的计算的正确性。</p>
<p>与大多数（如果不是全部）选择使用 EVM（按原样或稍作修改）作为基础层的 Starknet 竞争对手不同，Starknet 采用了自己的 VM。这使开发人员从 EVM 的限制中解放出来，开辟了更广泛的可能性。加上交易成本的降低，Starknet 和 Cairo 的结合为开发人员创造了一个令人兴奋的游乐场。原生账户抽象为账户（我们称之为“智能账户”）和交易流实现了更复杂的逻辑。新兴的用例包括 <strong>透明 AI</strong> 和机器学习应用程序。最后，<strong>区块链游戏</strong> 可以完全 <strong>在链上</strong> 开发。Starknet 经过专门设计，旨在最大化 STARK 证明的功能，以此实现最佳的可扩展性。</p>
<blockquote>
<p>在 <a href="https://docs.starknet.io/documentation/architecture_and_concepts/Account_Abstraction/introduction/">Starknet 文档</a> 中了解有关账户抽象的更多信息。</p>
</blockquote>
<h2 id="cairo-程序和-starknet-智能合约有什么区别"><a class="header" href="#cairo-程序和-starknet-智能合约有什么区别">Cairo 程序和 Starknet 智能合约：有什么区别？</a></h2>
<p>Starknet 合约是 Cairo 程序的一个特殊超集，因此本书前面学到的概念仍然适用于编写 Starknet 合约。正如你可能已经注意到的，Cairo 程序必须始终有一个用作此程序入口点的 <code>main</code> 函数：</p>
<pre><code class="language-cairo">fn main() {}
</code></pre>
<p>部署在 Starknet 网络上的合约本质上是由定序器 (sequencer) 运行的程序，因此可以访问 Starknet 的状态。合约没有 <code>main</code> 函数，但有一个或多个可用作入口点的函数。</p>
<p>Starknet 合约在 <a href="#定义模块以控制作用域">模块</a> 中定义。为了让模块被编译器作为合约处理，它必须用 <code>#[starknet::contract]</code> 属性进行注释。</p>
<h2 id="简单合约剖析"><a class="header" href="#简单合约剖析">简单合约剖析</a></h2>
<p>本章将使用一个非常简单的智能合约作为示例，向你介绍 Starknet 合约的基础知识。你将学习如何编写一个允许任何人在 Starknet 区块链上存储单个数字的合约。</p>
<p>让我们在整章中考虑以下合约。要把它们一次全部理解可能并不容易，但我们会一步一步地进行：</p>
<pre><code class="language-cairo noplayground">#[starknet::interface]
trait ISimpleStorage&lt;TContractState&gt; {
    fn set(ref self: TContractState, x: u128);
    fn get(self: @TContractState) -&gt; u128;
}

#[starknet::contract]
mod SimpleStorage {
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};

    #[storage]
    struct Storage {
        stored_data: u128,
    }

    #[abi(embed_v0)]
    impl SimpleStorage of super::ISimpleStorage&lt;ContractState&gt; {
        fn set(ref self: ContractState, x: u128) {
            self.stored_data.write(x);
        }

        fn get(self: @ContractState) -&gt; u128 {
            self.stored_data.read()
        }
    }
}
</code></pre>
<p>{{#label simple-contract}} <span class="caption">清单 {{#ref simple-contract}}: 一个简单的存储合约</span></p>
<h3 id="这个合约是什么"><a class="header" href="#这个合约是什么">这个合约是什么？</a></h3>
<p>合约是通过将状态和逻辑封装在一个用 <code>#[starknet::contract]</code> 属性注释的模块中来定义的。</p>
<p>状态是在 <code>Storage</code> 结构体中定义的，并且总是被初始化为空。在这里，我们的结构体包含一个名为 <code>stored_data</code> 的字段，类型为 <code>u128</code>（128 位无符号整数），表明我们的合约可以存储 0 到 \( {2^{128}} - 1 \) 之间的任何数字。</p>
<p>逻辑是由与状态交互的函数定义的。在这里，我们的合约定义并公开暴露了 <code>set</code> 和 <code>get</code> 函数，可用于修改或检索存储变量的值。你可以把它想象成数据库中的单个插槽，你可以通过调用管理数据库的代码的函数来查询和修改它。</p>
<h3 id="接口合约的蓝图"><a class="header" href="#接口合约的蓝图">接口：合约的蓝图</a></h3>
<pre><code class="language-cairo noplayground">#[starknet::interface]
trait ISimpleStorage&lt;TContractState&gt; {
    fn set(ref self: TContractState, x: u128);
    fn get(self: @TContractState) -&gt; u128;
}
</code></pre>
<p>{{#label interface}} <span class="caption">清单 {{#ref interface}}: 一个基本的合约接口</span></p>
<p>接口代表合约的蓝图。它们定义了合约向外部世界公开的函数，而不包括函数体。在 Cairo 中，它们是通过用 <code>#[starknet::interface]</code> 属性注释 trait 来定义的。该 trait 的所有函数都被视为实现此 trait 的任何合约的公共函数，并且可以从外部世界调用。</p>
<blockquote>
<p>合约构造函数不是接口的一部分。内部函数也不是。</p>
</blockquote>
<p>所有合约接口都使用通用类型作为 <code>self</code> 参数，代表合约状态。我们在接口中选择将此通用参数命名为 <code>TContractState</code>，但这不是强制性的，可以选择任何名称。</p>
<p>在我们的接口中，注意 <code>self</code> 参数的通用类型 <code>TContractState</code> 是通过引用传递给 <code>set</code> 函数的。看到 <code>self</code> 参数如果不动地传入合约函数告诉我们该函数可以访问合约的状态。<code>ref</code> 修饰符暗示 <code>self</code> 可能会被修改，这意味着合约的存储变量可能会在 <code>set</code> 函数内部被修改。</p>
<p>另一方面，<code>get</code> 函数采用 <code>TContractState</code> 的快照，这立即告诉我们它不修改状态（实际上，如果我们试图在 <code>get</code> 函数内修改存储，编译器会报错）。</p>
<p>通过利用 Cairo 的 <a href="#cairo-中的-traits">traits &amp; impls</a> 机制，我们可以确保存好的实际实现与其接口匹配。事实上，如果你的合约不符合声明的接口，你将得到一个编译错误。例如，清单 {{#ref wrong-impl}} 显示了 <code>ISimpleStorage</code> 接口的一个错误实现，包含一个稍微不同的 <code>set</code> 函数，其签名不同。</p>
<pre><code class="language-cairo noplayground">    #[abi(embed_v0)]
    impl SimpleStorage of super::ISimpleStorage&lt;ContractState&gt; {
        fn set(ref self: ContractState, x: u256) {
            self.stored_data.write(x);
        }

        fn get(self: @ContractState) -&gt; u128 {
            self.stored_data.read()
        }
    }
</code></pre>
<p>{{#label wrong-impl}} <span class="caption">清单 {{#ref wrong-impl}}: 合约接口的错误实现。这无法编译，因为 <code>set</code> 的签名与 trait 不匹配。</span></p>
<p>尝试使用此实现编译合约将导致以下错误：</p>
<pre><code class="language-shell">error: Interaction with the trait ISimpleStorage resulted in a ppanic.
 --&gt; contract.cairo:4:1
trait ISimpleStorage&lt;TContractState&gt; {
^************************************^

error: The value of the associated item "set" in the trait implementation mismatch the value in the trait.
 --&gt; contract.cairo:17:5
    impl SimpleStorage of super::ISimpleStorage&lt;ContractState&gt;{
    ^*********************************************************^

</code></pre>
<h3 id="在实现块中定义公共函数"><a class="header" href="#在实现块中定义公共函数">在实现块中定义公共函数</a></h3>
<p>在我们进一步探讨之前，让我们定义一些术语。</p>
<ul>
<li>
<p>在 Starknet 的语境中，<em>公共函数 (public function)</em> 是向外部世界公开的函数。公共函数可以被任何人调用，无论是从合约外部还是从合约内部。在上面的例子中，<code>set</code> 和 <code>get</code> 是公共函数。</p>
</li>
<li>
<p>我们所说的 <em>外部 (external)</em> 函数是一种公共函数，可以通过 Starknet 交易直接调用，并且可以改变合约的状态。<code>set</code> 是一个外部函数。</p>
</li>
<li>
<p><em>视图 (view)</em> 函数是一种公共函数，通常是只读的，不能改变合约的状态。然而，这个限制只是由编译器强制执行的，而不是由 Starknet 本身强制执行的。我们将在后面的章节讨论其含义。<code>get</code> 是一个视图函数。</p>
</li>
</ul>
<pre><code class="language-cairo noplayground">    #[abi(embed_v0)]
    impl SimpleStorage of super::ISimpleStorage&lt;ContractState&gt; {
        fn set(ref self: ContractState, x: u128) {
            self.stored_data.write(x);
        }

        fn get(self: @ContractState) -&gt; u128 {
            self.stored_data.read()
        }
    }
</code></pre>
<p>{{#label implementation}} <span class="caption">清单 {{#ref implementation}}: <code>SimpleStorage</code> 实现</span></p>
<p>由于合约接口被定义为 <code>ISimpleStorage</code> trait，为了匹配接口，合约的公共函数必须在此 trait 的实现中定义 —— 这允许我们确保合约的实现与其接口匹配。</p>
<p>然而，仅仅在实现块中定义函数是不够的。实现块必须用 <code>#[abi(embed_v0)]</code> 属性注释。此属性将此实现中定义的函数公开给外部世界 —— 忘记添加它，你的函数将无法从外部调用。所有在标记为 <code>#[abi(embed_v0)]</code> 的块中定义的函数因此都是 <em>公共函数</em>。</p>
<p>因为 <code>SimpleStorage</code> 合约被定义为一个模块，我们需要访问父模块中定义的接口。我们可以使用 <code>use</code> 关键字将其带入当前作用域，或者直接使用 <code>super</code> 引用它。</p>
<p>在编写接口的实现时，trait 方法中的 <code>self</code> 参数 <strong>必须</strong> 是 <code>ContractState</code> 类型。<code>ContractState</code> 类型由编译器生成，并提供对 <code>Storage</code> 结构体中定义的存储变量的访问。此外，<code>ContractState</code> 赋予了我们发出事件的能力。<code>ContractState</code> 这个名字并不奇怪，因为它是合约状态的表示，这就是我们在合约接口 trait 中认为的 <code>self</code>。当 <code>self</code> 是 <code>ContractState</code> 的快照时，只允许读取访问，并且不可能发出事件。</p>
<h3 id="访问和修改合约状态"><a class="header" href="#访问和修改合约状态">访问和修改合约状态</a></h3>
<p>通常使用两种方法来访问或修改合约的状态：</p>
<ul>
<li><code>read</code>，它返回存储变量的值。此方法在变量本身上调用，不带任何参数。</li>
</ul>
<pre><code class="language-cairo noplayground">            self.stored_data.read()
</code></pre>
<ul>
<li><code>write</code>，它允许在存储槽中写入新值。此方法也在变量本身上调用，并接受一个参数，即要写入的值。注意，<code>write</code> 可能接受多个参数，具体取决于存储变量的类型。例如，在映射 (mapping) 上写入需要 2 个参数：键和要写入的值。</li>
</ul>
<pre><code class="language-cairo noplayground">            self.stored_data.write(x);
</code></pre>
<blockquote>
<p>提醒：如果合约状态作为快照用 <code>@</code> 传递，而不是用 <code>ref</code> 引用传递，尝试修改合约状态将导致编译错误。</p>
</blockquote>
<p>这个合约除了允许任何人存储一个世界上任何人都可以访问的单个数字外，没有做太多事情。任何人都可以用不同的值再次调用 <code>set</code> 并覆盖当前的数字。尽管如此，存储在合约存储中的每个值仍将存储在区块链的历史记录中。在本书的后面，你将看到如何施加访问限制，以便只有你可以更改数字。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="starknet-合约类-classes-和实例-instances"><a class="header" href="#starknet-合约类-classes-和实例-instances">Starknet 合约类 (Classes) 和实例 (Instances)</a></h1>
<p>与面向对象编程一样，Starknet 通过将合约分为 <a href="#contract-classes">类 (classes)</a> 和 <a href="#contract-instances">实例 (instances)</a> 来区分合约及其实现。合约类是合约的定义，而合约实例是对应于类的一个已部署合约。只有合约实例充当真正的合约，因为它们拥有自己的存储，并可以被交易或其他合约调用。</p>
<!-- > Note: A contract class does not necessarily require a deployed instance in Starknet. -->
<h2 id="合约类-contract-classes"><a class="header" href="#合约类-contract-classes">合约类 (Contract Classes)</a></h2>
<h3 id="cairo-类定义的组成部分"><a class="header" href="#cairo-类定义的组成部分">Cairo 类定义的组成部分</a></h3>
<p>定义类的组件包括：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>名称</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td>合约类版本</td><td>合约类对象的版本。目前，Starknet OS 支持版本 0.1.0。</td></tr>
<tr><td>外部函数入口点数组</td><td>入口点是一对 <code>(_selector_, _function_idx_)</code>，其中 <code>_function_idx_</code> 是 Sierra 程序内部函数的索引。选择器 (selector) 是一个标识符，通过它可以在交易或其他类中调用函数。选择器是函数名称的 <code>starknet_keccak</code> 哈希，以 ASCII 编码。</td></tr>
<tr><td>L1 处理程序入口点数组 (L1 Handlers)</td><td>-</td></tr>
<tr><td>构造函数入口点数组</td><td>目前，编译器只允许一个构造函数。</td></tr>
<tr><td>ABI</td><td>表示类 ABI 的字符串。ABI 哈希（影响类哈希）由 <code>starknet_keccak(bytes(ABI, "UTF-8"))</code> 给出。此字符串由声明类的用户提供（并作为 <code>DECLARE</code> 交易的一部分进行签名），并不强制要求是关联类的真实 ABI。如果不查看底层源代码（即生成该类 Sierra 的 Cairo 代码），此 ABI 应被视为声明方“预期”的 ABI，这可能是不正确的（有意或无意）。“诚实”的字符串将是 Cairo 编译器生成的合约 ABI 的 JSON 序列化。</td></tr>
<tr><td>Sierra 程序</td><td>表示 Sierra 指令的字段元素数组。</td></tr>
</tbody>
</table>
</div>
<h3 id="类哈希-class-hash"><a class="header" href="#类哈希-class-hash">类哈希 (Class Hash)</a></h3>
<p>每个类都由其 <em>类哈希</em> 唯一标识，类似于传统面向对象编程语言中的类名。类的哈希是其组件的链式哈希，计算如下：</p>
<pre><code>class_hash = h(
    contract_class_version,
    external_entry_points,
    l1_handler_entry_points,
    constructor_entry_points,
    abi_hash,
    sierra_program_hash
)
</code></pre>
<p>其中：</p>
<ul>
<li><code>h</code> 是 Poseidon 哈希函数</li>
<li>入口点数组 \( (selector,index)_{i=1}^n] \) 的哈希由 \( h(\text{selector}_1,\text{index}_1,…,\text{selector}_n,\text{index}_n) \) 给出</li>
<li><code>sierra_program_hash</code> 是程序字节码数组的 Poseidon 哈希</li>
</ul>
<blockquote>
<p>注意：Starknet OS 目前支持合约类版本 0.1.0，在上述哈希计算中表示为字符串 <code>CONTRACT_CLASS_V0.1.0</code> 的 ASCII 编码（以这种方式对版本进行哈希可以让我们在类哈希和其他对象哈希之间进行域分离）。有关更多详细信息，请参阅 <a href="https://github.com/starkware-libs/cairo-lang/blob/7712b21fc3b1cb02321a58d0c0579f5370147a8b/src/starkware/starknet/core/os/contracts.cairo#L47">Cairo 实现</a>。</p>
</blockquote>
<h3 id="使用类"><a class="header" href="#使用类">使用类</a></h3>
<ul>
<li>添加新类：要向 Starknet 的状态引入新类，请使用 <code>DECLARE</code> 交易。</li>
<li>部署实例：要部署先前声明的类的新实例，请使用 <code>deploy</code> 系统调用。</li>
<li>使用类功能：要在不部署实例的情况下使用已声明类的功能，请使用 <code>library_call</code> 系统调用。类似于以太坊的 <code>delegatecall</code>，它使你能够使用现有类中的代码而无需部署合约实例。</li>
</ul>
<h2 id="合约实例-contract-instances"><a class="header" href="#合约实例-contract-instances">合约实例 (Contract Instances)</a></h2>
<h3 id="合约-nonce"><a class="header" href="#合约-nonce">合约 Nonce</a></h3>
<p>合约实例具有 nonce，其值为源自此地址的交易数量加 1。例如，当你使用 <code>DEPLOY_ACCOUNT</code> 交易部署账户时，交易中账户合约的 nonce 为 <code>0</code>。在 <code>DEPLOY_ACCOUNT</code> 交易之后，直到账户合约发送下一笔交易，nonce 为 <code>1</code>。</p>
<h3 id="合约地址"><a class="header" href="#合约地址">合约地址</a></h3>
<p>合约地址是 Starknet 上合约的唯一标识符。它是以下信息的链式哈希：</p>
<ul>
<li><code>prefix</code>: 常量字符串 <code>STARKNET_CONTRACT_ADDRESS</code> 的 ASCII 编码。</li>
<li><code>deployer_address</code>，它是：
<ul>
<li>当合约通过 <code>DEPLOY_ACCOUNT</code> 交易部署时为 <code>0</code></li>
<li>当合约通过 <code>deploy</code> 系统调用部署时，由 <code>deploy_from_zero</code> 参数的值决定
<blockquote>
<p>注意：有关 <code>deploy_from_zero</code> 参数的信息，请参阅 <a href="#starknet-合约类-classes-和实例-instances"><code>deploy</code> 系统调用</a>。</p>
</blockquote>
</li>
</ul>
</li>
<li><code>salt</code>: 合约调用 syscall 时传递的盐，由交易发送者提供。</li>
<li><code>class_hash</code>: 见 <a href="#class-hash">类哈希</a>。</li>
<li><code>constructor_calldata_hash</code>: 构造函数输入的数组哈希。</li>
</ul>
<p>地址计算如下：</p>
<pre><code>contract_address = pedersen(
    “STARKNET_CONTRACT_ADDRESS”,
    deployer_address,
    salt,
    class_hash,
    constructor_calldata_hash)
</code></pre>
<blockquote>
<p>注意：随机 <code>salt</code> 确保智能合约部署的地址唯一，防止部署相同合约类时发生冲突。它还通过唯一发送者地址影响交易哈希来阻止重放攻击。</p>
</blockquote>
<p>有关地址计算的更多信息，请参阅 Cairo GitHub 存储库中的 <a href="https://github.com/starkware-libs/cairo/blob/2c96b181a6debe9a564b51dbeaaf48fa75808d53/corelib/src/starknet/contract_address.cairo"><code>contract_address.cairo</code></a>。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="构建-starknet-智能合约"><a class="header" href="#构建-starknet-智能合约">构建 Starknet 智能合约</a></h1>
<p>在上一节中，我们给出了一个用 Cairo 编写的智能合约的入门示例，描述了在 Starknet 上构建智能合约的基本模块。在本节中，我们将逐步深入研究智能合约的所有组件。</p>
<p>当我们讨论 <a href="#the-interface-the-contracts-blueprint"><em>接口 (interfaces)</em></a> 时，我们指定了两种 <em>公共函数 (public functions)</em> 之间的区别，即 <em>外部函数 (external functions)</em> 和 <em>视图函数 (view functions)</em>，并且我们提到了如何与合约的 <em>存储 (storage)</em> 进行交互。</p>
<p>在这一点上，你应该会有多个问题浮现在脑海中：</p>
<ul>
<li>我如何通过存储更复杂的数据类型？</li>
<li>我如何定义内部/私有函数？</li>
<li>我如何发出事件？我如何索引它们？</li>
<li>有没有办法减少样板代码？</li>
</ul>
<p>幸运的是，我们将在本章回答所有这些问题。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="starknet-类型"><a class="header" href="#starknet-类型">Starknet 类型</a></h1>
<p>在 Starknet 上构建智能合约时，你将使用表示区块链特定概念的专用类型。这些类型允许你通过地址与已部署的合约进行交互，处理跨链通信并处理合约特定的数据类型。本章介绍核心库提供的 Starknet 特定类型。</p>
<h2 id="合约地址-contract-address"><a class="header" href="#合约地址-contract-address">合约地址 (Contract Address)</a></h2>
<p><code>ContractAddress</code> 类型表示 Starknet 上已部署合约的地址。每个已部署的合约都有一个唯一的地址，用于在网络上标识它。你将使用它来调用其他合约、检查调用者身份、管理访问控制以及任何涉及链上账户的事情。</p>
<pre><code class="language-cairo">use starknet::{ContractAddress, get_caller_address};

#[starknet::interface]
pub trait IAddressExample&lt;TContractState&gt; {
    fn get_owner(self: @TContractState) -&gt; ContractAddress;
    fn transfer_ownership(ref self: TContractState, new_owner: ContractAddress);
}

#[starknet::contract]
mod AddressExample {
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
    use super::{ContractAddress, get_caller_address};

    #[storage]
    struct Storage {
        owner: ContractAddress,
    }

    #[constructor]
    fn constructor(ref self: ContractState, initial_owner: ContractAddress) {
        self.owner.write(initial_owner);
    }

    #[abi(embed_v0)]
    impl AddressExampleImpl of super::IAddressExample&lt;ContractState&gt; {
        fn get_owner(self: @ContractState) -&gt; ContractAddress {
            self.owner.read()
        }

        fn transfer_ownership(ref self: ContractState, new_owner: ContractAddress) {
            let caller = get_caller_address();
            assert!(caller == self.owner.read(), "Only owner can transfer");
            self.owner.write(new_owner);
        }
    }
}
</code></pre>
<p>Starknet 中的合约地址具有 <code>[0, 2^251)</code> 的值范围，这是由类型系统强制执行的。你可以使用常规的 <code>TryInto</code> trait 从 <code>felt252</code> 创建 <code>ContractAddress</code>。</p>
<h2 id="存储地址-storage-address"><a class="header" href="#存储地址-storage-address">存储地址 (Storage Address)</a></h2>
<p><code>StorageAddress</code> 类型表示值在合约存储中的位置。虽然你通常不会直接创建这些地址（存储系统通过 <a href="#使用映射存储键值对">Map</a> 和 <a href="#使用向量存储集合">Vec</a> 等类型为你处理），但了解此类型对于高级存储模式很重要。存储在 <code>Storage</code> 结构体中的每个值都有自己的 <code>StorageAddress</code>，并且可以按照 <a href="#合约存储-contract-storage">存储 (Storage)</a> 章节中定义的规则直接访问。</p>
<pre><code class="language-cairo">#[starknet::contract]
mod StorageExample {
    use starknet::storage_access::StorageAddress;

    #[storage]
    struct Storage {
        value: u256,
    }

    // This is an internal function that demonstrates StorageAddress usage
    // In practice, you rarely need to work with StorageAddress directly
    fn read_from_storage_address(address: StorageAddress) -&gt; felt252 {
        starknet::syscalls::storage_read_syscall(0, address).unwrap()
    }
}
</code></pre>
<p>存储地址与合约地址 <code>[0, 2^251)</code> 共享相同的值范围。相关的 <code>StorageBaseAddress</code> 类型表示可以与偏移量组合的基地址，其范围略小 <code>[0, 2^251 - 256)</code> 以容纳偏移量计算。</p>
<h2 id="以太坊地址-ethereum-address"><a class="header" href="#以太坊地址-ethereum-address">以太坊地址 (Ethereum Address)</a></h2>
<p><code>EthAddress</code> 类型表示 20 字节的以太坊地址，主要用于在 Starknet 上构建跨链应用程序。该类型用于 L1-L2 消息传递、代币桥接以及任何需要与以太坊交互的合约。</p>
<pre><code class="language-cairo">use starknet::EthAddress;

#[starknet::interface]
pub trait IEthAddressExample&lt;TContractState&gt; {
    fn set_l1_contract(ref self: TContractState, l1_contract: EthAddress);
    fn send_message_to_l1(ref self: TContractState, recipient: EthAddress, amount: felt252);
}

#[starknet::contract]
mod EthAddressExample {
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
    use starknet::syscalls::send_message_to_l1_syscall;
    use super::EthAddress;

    #[storage]
    struct Storage {
        l1_contract: EthAddress,
    }

    #[abi(embed_v0)]
    impl EthAddressExampleImpl of super::IEthAddressExample&lt;ContractState&gt; {
        fn set_l1_contract(ref self: ContractState, l1_contract: EthAddress) {
            self.l1_contract.write(l1_contract);
        }

        fn send_message_to_l1(ref self: ContractState, recipient: EthAddress, amount: felt252) {
            // Send a message to L1 with recipient and amount
            let payload = array![recipient.into(), amount];
            send_message_to_l1_syscall(self.l1_contract.read().into(), payload.span()).unwrap();
        }
    }

    #[l1_handler]
    fn handle_message_from_l1(ref self: ContractState, from_address: felt252, amount: felt252) {
        // Verify the message comes from the expected L1 contract
        assert!(from_address == self.l1_contract.read().into(), "Invalid L1 sender");
        // Process the message...
    }
}
</code></pre>
<p>此示例展示了 <code>EthAddress</code> 的主要用途：</p>
<ul>
<li>存储 L1 合约地址</li>
<li>使用 <code>send_message_to_l1_syscall</code> 向以太坊发送消息</li>
<li>使用 <code>#[l1_handler]</code> 从 L1 接收和验证消息</li>
</ul>
<p><code>EthAddress</code> 类型确保类型安全，并且可以与 <code>felt252</code> 相互转换以进行 L1-L2 消息序列化。</p>
<h2 id="类哈希-class-hash-1"><a class="header" href="#类哈希-class-hash-1">类哈希 (Class Hash)</a></h2>
<p><code>ClassHash</code> 类型表示合约类（合约代码）的哈希。在 Starknet 的架构中，合约类与合约实例分部署，允许用于多个合约共享相同的代码。因此，你可以使用相同的类哈希部署多个合约，或者是将合约升级到新版本。</p>
<pre><code class="language-cairo">use starknet::ClassHash;

#[starknet::interface]
pub trait IClassHashExample&lt;TContractState&gt; {
    fn get_implementation_hash(self: @TContractState) -&gt; ClassHash;
    fn upgrade(ref self: TContractState, new_class_hash: ClassHash);
}

#[starknet::contract]
mod ClassHashExample {
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
    use starknet::syscalls::replace_class_syscall;
    use super::ClassHash;

    #[storage]
    struct Storage {
        implementation_hash: ClassHash,
    }

    #[constructor]
    fn constructor(ref self: ContractState, initial_class_hash: ClassHash) {
        self.implementation_hash.write(initial_class_hash);
    }

    #[abi(embed_v0)]
    impl ClassHashExampleImpl of super::IClassHashExample&lt;ContractState&gt; {
        fn get_implementation_hash(self: @ContractState) -&gt; ClassHash {
            self.implementation_hash.read()
        }

        fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {
            replace_class_syscall(new_class_hash).unwrap();
            self.implementation_hash.write(new_class_hash);
        }
    }
}
</code></pre>
<p>类哈希具有与地址 <code>[0, 2^251)</code> 相同的值范围。它们唯一地标识特定版本的合约代码，并用于部署操作、代理模式和升级机制。</p>
<h2 id="使用区块和交易信息"><a class="header" href="#使用区块和交易信息">使用区块和交易信息</a></h2>
<p>Starknet 提供了几个函数来访问有关当前执行上下文的信息。这些函数返回包含区块链状态信息的专用类型或结构体。</p>
<pre><code class="language-cairo">#[starknet::interface]
pub trait IBlockInfo&lt;TContractState&gt; {
    fn get_block_info(self: @TContractState) -&gt; (u64, u64);
    fn get_tx_info(self: @TContractState) -&gt; (ContractAddress, felt252);
}

#[starknet::contract]
mod BlockInfoExample {
    use starknet::{get_block_info, get_tx_info};
    use super::ContractAddress;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl BlockInfoImpl of super::IBlockInfo&lt;ContractState&gt; {
        fn get_block_info(self: @ContractState) -&gt; (u64, u64) {
            let block_info = get_block_info();
            (block_info.block_number, block_info.block_timestamp)
        }

        fn get_tx_info(self: @ContractState) -&gt; (ContractAddress, felt252) {
            let tx_info = get_tx_info();

            // Access transaction details
            let sender = tx_info.account_contract_address;
            let tx_hash = tx_info.transaction_hash;

            (sender, tx_hash)
        }
    }
}
</code></pre>
<p><code>BlockInfo</code> 结构体包含有关当前区块的详细信息，包括其编号和时间戳。<code>TxInfo</code> 结构体提供特定于交易的信息，包括发送者的地址、交易哈希和费用详情。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="合约存储-contract-storage"><a class="header" href="#合约存储-contract-storage">合约存储 (Contract Storage)</a></h1>
<p>合约的存储是一个持久存储空间，你可以在其中读取、写入、修改和持久化数据。存储是一个具有 \(2^{251}\) 个槽位的映射 (map)，其中每个槽位是一个初始化为 0 的 <code>felt252</code>。</p>
<p>每个存储槽位由一个 <code>felt252</code> 值标识，称为存储地址，它是从变量名称和取决于变量类型的参数计算得出的，这在 <a href="#addresses-of-storage-variables">“存储变量的地址”</a> 部分中进行了概述。</p>
<p>我们可以通过两种方式与合约的存储进行交互：</p>
<ol>
<li>通过高级存储变量，这些变量在用 <code>#[storage]</code> 属性注释的特殊 <code>Storage</code> 结构体中声明。</li>
<li>使用其计算出的地址和低级 <code>storage_read</code> 和 <code>storage_write</code> 系统调用直接访问存储槽。当你需要执行不适合存储变量结构化方法的自定义存储操作时，这很有用，但通常应避免；因此，我们将不在本章中介绍它们。</li>
</ol>
<h2 id="声明和使用存储变量"><a class="header" href="#声明和使用存储变量">声明和使用存储变量</a></h2>
<p>Starknet 合约中的存储变量存储在一个名为 <code>Storage</code> 的特殊结构体中：</p>
<pre><code class="language-cairo noplayground">    #[storage]
    struct Storage {
        owner: Person,
        expiration: Expiration,
    }
</code></pre>
<p><code>Storage</code> 结构体像任何其他 <a href="#使用结构体组织相关数据">结构体</a> 一样，除了它 <strong>必须</strong> 用 <code>#[storage]</code> 属性注释。此注释告诉编译器生成与区块链状态交互所需的代码，并允许你从存储中读取和写入数据。此结构体可以包含任何实现 <code>Store</code> trait 的类型，包括其他结构体、枚举，以及 <a href="#使用映射存储键值对">存储映射 (Storage Mappings)</a>、<a href="#使用向量存储集合">存储向量 (Storage Vectors)</a> 和 <a href="#storage-nodes">存储节点 (Storage Nodes)</a>。在本节中，我们将重点介绍简单的存储变量，我们将在接下来的部分中看到如何存储更复杂的类型。</p>
<h3 id="访问存储变量"><a class="header" href="#访问存储变量">访问存储变量</a></h3>
<p>可以使用 <code>read</code> 和 <code>write</code> 函数分别访问和修改存储在 <code>Storage</code> 结构体中的变量。所有这些函数都会由编译器为每个存储变量自动生成。</p>
<p>要读取 <code>owner</code> 存储变量的值（其类型为 <code>Person</code>），我们在 <code>owner</code> 变量上调用 <code>read</code> 函数，不传递任何参数。</p>
<pre><code class="language-cairo noplayground">        fn get_owner(self: @ContractState) -&gt; Person {
            self.owner.read()
        }
</code></pre>
<p>要将新值写入存储变量的存储槽，我们调用 <code>write</code> 函数，将该值作为参数传递。在这里，我们只传入要写入 <code>owner</code> 变量的值，因为它是一个简单的变量。</p>
<pre><code class="language-cairo noplayground">    #[constructor]
    fn constructor(ref self: ContractState, owner: Person) {
        self.owner.write(owner);
    }
</code></pre>
<p>当使用复合类型时，可以通过在结构体的特定成员上调用 <code>read</code> 和 <code>write</code>，而不是在结构体变量本身上调用 <code>read</code> 和 <code>write</code>（这会对每个成员执行存储操作）。这允许你直接访问和修改结构体成员的值，从而最大限度地减少执行的存储操作量。在下面的示例中，<code>owner</code> 变量是 <code>Person</code> 类型。因此，它有一个名为 <code>name</code> 的属性，我们可以在其上调用 <code>read</code> 和 <code>write</code> 函数来访问和修改其值。</p>
<pre><code class="language-cairo noplayground">        fn get_owner_name(self: @ContractState) -&gt; felt252 {
            self.owner.name.read()
        }
</code></pre>
<h2 id="使用-store-trait-存储自定义类型"><a class="header" href="#使用-store-trait-存储自定义类型">使用 <code>Store</code> Trait 存储自定义类型</a></h2>
<p><code>Store</code> trait 定义在 <code>starknet::storage_access</code> 模块中，用于指定类型应如何在存储中存储。为了使类型能够存储在存储中，它 <strong>必须</strong> 实现 <code>Store</code> trait。大多数核心库类型，例如无符号整数（<code>u8</code>、<code>u128</code>、<code>u256</code>…）、<code>felt252</code>、<code>bool</code>、<code>ByteArray</code>、<code>ContractAddress</code> 等都实现了 <code>Store</code> trait，因此可以直接存储而无需进一步操作。然而，<strong>内存集合</strong>，如 <code>Array&lt;T&gt;</code> 和 <code>Felt252Dict&lt;T&gt;</code>，<strong>不能</strong> 存储在合约存储中 —— 你必须改用特殊类型 <code>Vec&lt;T&gt;</code> 和 <code>Map&lt;K, V&gt;</code>。</p>
<p>但是如果你想存储一个你自己定义的类型，比如一个枚举或一个结构体呢？这种情况下，你必须显式告诉编译器如何存储这种类型。</p>
<p>在我们的例子中，我们想在存储中存储一个 <code>Person</code> 结构体，这只有通过为 <code>Person</code> 类型实现 <code>Store</code> trait 才可能实现。这可以通过在我们的结构体定义之上简单地添加 <code>#[derive(starknet::Store)]</code> 属性来实现。请注意，结构体的所有成员都需要实现 <code>Store</code> trait 才能派生该 trait。</p>
<pre><code class="language-cairo noplayground">    #[derive(Drop, Serde, starknet::Store)]
    pub struct Person {
        address: ContractAddress,
        name: felt252,
    }
</code></pre>
<p>同样，枚举只有在实现 <code>Store</code> trait 时才能写入存储，只要所有关联类型都实现了 <code>Store</code> trait，就可以简单地派生它。</p>
<p>合约存储中使用的枚举 <strong>必须</strong> 定义一个默认变体。当读取空存储槽时，将返回此默认变体 —— 否则，将导致运行时错误。</p>
<p>这有一个如何正确定义用于合约存储的枚举的示例：</p>
<pre><code class="language-cairo noplayground">    #[derive(Copy, Drop, Serde, starknet::Store)]
    pub enum Expiration {
        Finite: u64,
        #[default]
        Infinite,
    }
</code></pre>
<p>在这个例子中，我们为 <code>Infinite</code> 变体添加了 <code>#[default]</code> 属性。这告诉 Cairo 编译器，如果我们尝试从存储中读取未初始化的枚举，应该返回 <code>Infinite</code> 变体。</p>
<p>你可能已经注意到，我们还在我们的自定义类型上派生了 <code>Drop</code> 和 <code>Serde</code>。它们两个都是正确序列化传递给入口点的参数和反序列化其输出所必需的。</p>
<h2 id="结构体存储布局"><a class="header" href="#结构体存储布局">结构体存储布局</a></h2>
<p>在 Starknet 上，结构体作为基本类型的序列存储在存储中。结构体的元素按其在结构体定义中定义的相同顺序存储。结构体的第一个元素存储在结构体的基地址，该地址如 <a href="#addresses-of-storage-variables">“存储变量的地址”</a> 一节中所述计算，可以通过 <code>var.__base_address__</code> 获得。后续元素存储在与前一个元素连续的地址处。例如，类型为 <code>Person</code> 的 <code>owner</code> 变量的存储布局将产生以下布局：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>字段</th><th>地址</th></tr>
</thead>
<tbody>
<tr><td>name</td><td><code>owner.__base_address__</code></td></tr>
<tr><td>address</td><td><code>owner.__base_address__ +1</code></td></tr>
</tbody>
</table>
</div>
<p>注意，元组也类似地存储在合约的存储中，元组的第一个元素存储在基地址，后续元素连续存储。</p>
<h2 id="枚举存储布局"><a class="header" href="#枚举存储布局">枚举存储布局</a></h2>
<p>当你存储枚举变体时，你实际上存储的是变体的索引和最终的关联值。此索引从枚举的第一个变体的 0 开始，每个后续变体加 1。如果你的变体具有关联值，则此值从紧随变体索引地址之后的地址开始存储。例如，假设我们有 <code>Expiration</code> 枚举，其中 <code>Finite</code> 变体带有相关的限制日期，而 <code>Infinite</code> 变体没有关联数据。<code>Finite</code> 变体的存储布局将如下所示：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>元素</th><th>地址</th></tr>
</thead>
<tbody>
<tr><td>变体索引 (0 for Finite)</td><td><code>expiration.__base_address__</code></td></tr>
<tr><td>关联的限制日期</td><td><code>expiration.__base_address__ + 1</code></td></tr>
</tbody>
</table>
</div>
<p>而 <code>Infinite</code> 变体的存储布局将如下所示：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>元素</th><th>地址</th></tr>
</thead>
<tbody>
<tr><td>变体索引 (1 for Infinite)</td><td><code>expiration.__base_address__</code></td></tr>
</tbody>
</table>
</div>
<!-- TODO: add example -->
<h2 id="存储节点-storage-nodes"><a class="header" href="#存储节点-storage-nodes">存储节点 (Storage Nodes)</a></h2>
<p>存储节点是一种特殊的结构体，可以包含特定于存储的类型，例如 <a href="#使用映射存储键值对"><code>Map</code></a>、<a href="#使用向量存储集合"><code>Vec</code></a> 或其他存储节点作为成员。与常规结构体不同，存储节点只能存在于合约存储中，不能在其外部实例化或使用。你可以将存储节点视为参与表示合约存储空间的树中的地址计算的中间节点。在下一小节中，我们将介绍如何在核心库中通过建模这个概念。</p>
<p>存储节点的主要好处是允许你创建更复杂的存储布局，包括自定义类型中的映射或向量，并允许你对相关数据进行逻辑分组，从而提高代码的可读性和可维护性。</p>
<p>存储节点是使用 <code>#[starknet::storage_node]</code> 属性定义的结构体。在实现投票系统的这个新合约中，我们实现了一个 <code>ProposalNode</code> 存储节点，其中包含一个 <code>Map&lt;ContractAddress, bool&gt;</code> 来跟踪提案的投票者，以及其他用于存储提案元数据的字段。</p>
<pre><code class="language-cairo noplayground">    #[starknet::storage_node]
    struct ProposalNode {
        title: felt252,
        description: felt252,
        yes_votes: u32,
        no_votes: u32,
        voters: Map&lt;ContractAddress, bool&gt;,
    }
</code></pre>
<p>访问存储节点时，你不能直接 <code>read</code> 或 <code>write</code> 之。相反，你必须访问其各个成员。这是来自我们的 <code>VotingSystem</code> 合约的一个示例，演示了我们如何填充 <code>ProposalNode</code> 存储节点的每个字段：</p>
<pre><code class="language-cairo noplayground">    #[external(v0)]
    fn create_proposal(ref self: ContractState, title: felt252, description: felt252) -&gt; u32 {
        let mut proposal_count = self.proposal_count.read();
        let new_proposal_id = proposal_count + 1;

        let mut proposal = self.proposals.entry(new_proposal_id);
        proposal.title.write(title);
        proposal.description.write(description);
        proposal.yes_votes.write(0);
        proposal.no_votes.write(0);

        self.proposal_count.write(new_proposal_id);

        new_proposal_id
    }
</code></pre>
<p>因为还没有选民对此提案进行投票，所以我们在创建提案时不需要填充 <code>voters</code> 映射。但是，当选民试图投票时，我们完全可以访问 <code>voters</code> 映射来检查给定地址是否已经对此提案进行了投票：</p>
<pre><code class="language-cairo noplayground">    #[external(v0)]
    fn vote(ref self: ContractState, proposal_id: u32, vote: bool) {
        let mut proposal = self.proposals.entry(proposal_id);
        let caller = get_caller_address();
        let has_voted = proposal.voters.entry(caller).read();
        if has_voted {
            return;
        }
        proposal.voters.entry(caller).write(true);
    }
</code></pre>
<p>在这个例子中，我们访问特定提案 ID 的 <code>ProposalNode</code>。然后，我们通过从存储节点中的 <code>voters</code> 映射读取来检查调用者是否已经投票。如果他们还没有投票，我们就写入 <code>voters</code> 映射来标记他们现在已经投票了。</p>
<h2 id="存储变量的地址"><a class="header" href="#存储变量的地址">存储变量的地址</a></h2>
<p>存储变量的地址计算如下：</p>
<ul>
<li>
<p>如果变量是单个值，则地址是变量名称的 ASCII 编码的 <code>sn_keccak</code> 哈希。 <code>sn_keccak</code> 是 Keccak256 哈希函数的 Starknet 版本，其输出被截断为 250 位。</p>
</li>
<li>
<p>如果变量由多个值组成（即元组、结构体或枚举），我们也使用变量名称的 ASCII 编码的 <code>sn_keccak</code> 哈希来确定存储中的基地址。然后，根据类型，存储布局会有所不同。请参阅 <a href="#storing-custom-types-with-the-store-trait">“存储自定义类型”</a> 部分。</p>
</li>
<li>
<p>如果变量是 <a href="#storage-nodes">存储节点</a> 的一部分，则其地址基于反映节点结构的哈希链。对于存储变量 <code>variable_name</code> 内的存储节点成员 <code>m</code>，该成员的路径计算为 <code>h(sn_keccak(variable_name), sn_keccak(m))</code>，其中 <code>h</code> 是 Pedersen 哈希。此过程对于嵌套存储节点继续进行，构建表示通往叶节点的路径的哈希链。一旦到达叶节点，存储计算就像往常一样针对该类型的变量进行。</p>
</li>
<li>
<p>如果变量是 <a href="#使用映射存储键值对">Map</a> 或 <a href="#使用向量存储集合">Vec</a>，地址是相对于存储基地址计算的，存储基地址是变量名称的 <code>sn_keccak</code> 哈希，以及映射的键或 Vec 中的索引。 <a href="#使用映射存储键值对">“存储映射”</a> 和 <a href="#使用向量存储集合">“存储向量”</a> 部分描述了精确的计算。</p>
</li>
</ul>
<p>你可以通过访问变量上的 <code>__base_address__</code> 属性（返回 <code>felt252</code> 值）来访问存储变量的基地址。</p>
<pre><code class="language-cairo noplayground">        self.total_names.__base_address__
</code></pre>
<p>此地址计算机制通过使用 <code>StoragePointers</code> 和 <code>StoragePaths</code> 的概念对合约存储空间进行建模来执行，我们现在将介绍这些概念。</p>
<h2 id="核心库中合约存储的建模"><a class="header" href="#核心库中合约存储的建模">核心库中合约存储的建模</a></h2>
<p>要理解存储变量如何在 Cairo 中存储，重要的是要注意它们不是连续存储的，而是存储在合约存储的不同位置。为了便于检索这些地址，核心库通过 <code>StoragePointers</code> 和 <code>StoragePaths</code> 系统提供了合约存储的模型。</p>
<p>每个存储变量都可以转换为 <code>StoragePointer</code>。该指针包含两个主要字段：</p>
<ul>
<li>合约存储中存储变量的基地址。</li>
<li>该指针指向的特定存储槽相对于基地址的偏移量。</li>
</ul>
<p>一图胜千言。让我们考虑上一节定义的 <code>Person</code> 结构体：</p>
<pre><code class="language-cairo noplayground">    #[derive(Drop, Serde, starknet::Store)]
    pub struct Person {
        address: ContractAddress,
        name: felt252,
    }
</code></pre>
<p>当我们写 <code>let x = self.owner;</code> 时，我们访问一个 <code>StorageBase</code> 类型的变量，该变量表示 <code>owner</code> 变量在合约存储中的基位置。从这个基地址，我们可以获取指向结构体字段（如 <code>name</code> 或 <code>address</code>）的指针，或者指向结构体本身的指针。在这些指针上，我们可以调用 <code>Store</code> trait 中定义的 <code>read</code> 和 <code>write</code> 来读取和写入指向的值。</p>
<p>当然，所有这些对开发人员都是透明的。我们可以像访问常规变量一样读取和写入结构体的字段，但编译器会在幕后将这些访问转换为适当的 <code>StoragePointer</code> 操作。</p>
<p>对于存储映射，过程类似，除了我们引入了一个中间类型 <code>StoragePath</code>。<code>StoragePath</code> 是存储节点和结构体字段的链，它们构成了通往特定存储槽的路径。例如，要访问包含在 <code>Map&lt;ContractAddress, u128&gt;</code> 中的值，过程如下：</p>
<ol>
<li>从 <code>Map</code> 的 <code>StorageBase</code> 开始，并将其转换为 <code>StoragePath</code>。</li>
<li>走 <code>StoragePath</code> 使用 <code>entry</code> 方法到达所需的值，在 <code>Map</code> 的情况下，该方法将当前路径与下一个键进行哈希以生成下一个 <code>StoragePath</code>。</li>
<li>重复步骤 2，直到 <code>StoragePath</code> 指向所需的值，将最终值转换为 <code>StoragePointer</code>。</li>
<li>在该指针处读取或写入值。</li>
</ol>
<p>注意，我们需要在能够对其进行读取或写入之前将 <code>ContractAddress</code> 转换为 <code>StoragePointer</code>。</p>
<p><img src="mermaid-storage-model.png" alt="核心库中存储空间的建模"></p>
<!-- ./mermaid-storage-model.txt -->
<h2 id="总结-10"><a class="header" href="#总结-10">总结</a></h2>
<p>在本章中，我们涵盖了以下关键点：</p>
<ul>
<li><strong>存储变量</strong>：用于在区块链上存储持久数据。它们定义在用 <code>#[storage]</code> 属性注释的特殊 <code>Storage</code> 结构体中。</li>
<li><strong>访问存储变量</strong>：你可以使用自动生成的 <code>read</code> 和 <code>write</code> 函数读取和写入存储变量。对于结构体，你可以直接访问单个成员。</li>
<li><strong>使用 <code>Store</code> Trait 自定义类型</strong>：要存储像结构体和枚举这样的自定义类型，它们必须实现 <code>Store</code> trait。这可以使用 <code>#[derive(starknet::Store)]</code> 属性或编写你自己的实现来实现。</li>
<li><strong>存储变量的地址</strong>：存储变量的地址是使用其名称的 <code>sn_keccak</code> 哈希计算的，对于特殊类型还有额外的步骤。对于复杂类型，存储布局由类型的结构决定。</li>
<li><strong>结构体和枚举存储布局</strong>：结构体作为基本类型的序列存储，而枚举存储变体索引和潜在的关联值。</li>
<li><strong>存储节点</strong>：可以包含特定于存储的类型（如 <code>Map</code> 或 <code>Vec</code>）的特殊结构体。它们允许更复杂的存储布局，并且只能存在于合约存储中。</li>
</ul>
<p>接下来，我们将深入关注 <code>Map</code> 和 <code>Vec</code> 类型。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="使用映射存储键值对"><a class="header" href="#使用映射存储键值对">使用映射存储键值对</a></h1>
<p>Cairo 中的存储映射提供了一种将键与值相关联并将它们保存在合约存储中的方法。与传统的哈希表不同，存储映射不存储键数据本身；相反，它们使用键的哈希来计算对应于存储相应值的存储槽的地址。因此，不可能迭代存储映射的键。</p>
<div align="center">
    <img src="mappings.png" alt="mappings" width="500px" />
<div align="center">
    </div>

    {{#label fig-mappings}}
    <span class="caption">图 {{#ref fig-mappings}}: 将键映射到存储中的值</span>
</div>

<p>映射没有长度的概念，也没有键值对是否设置的概念。所有值默认都设置为 0。因此，从映射中删除条目的唯一方法是将其值设置为该类型的默认值，对于 <code>u64</code> 类型为 <code>0</code>。</p>
<p>Cairo 核心库在 <code>core::starknet::storage</code> 模块中提供的 <code>Map</code> 类型用于在合约中声明映射。</p>
<p>要声明映射，请使用尖括号 <code>&lt;&gt;</code> 括起来的 <code>Map</code> 类型，指定键和值类型。在清单 {{#ref storage-mappings}} 中，我们创建了一个简单的合约，该合约存储映射到调用者地址的值。</p>
<blockquote>
<p><code>Felt252Dict</code> 类型是 <strong>内存</strong> 类型，不能存储在合约存储中。对于键值对的持久存储，请使用 <code>Map</code> 类型，该类型是专为合约存储设计的 [幽灵类型 (phantom type)][phantom types]。然而，<code>Map</code> 有局限性：它不能作为常规变量实例化，不能用作函数参数，也不能作为常规结构体的成员包含在内。<code>Map</code> 只能作为合约存储结构体中的存储变量使用。要在内存中处理 <code>Map</code> 的内容或执行复杂操作，你需要将其元素复制到 <code>Felt252Dict</code> 或其他合适的数据结构中（或从中复制）。</p>
</blockquote>
<h2 id="声明和使用存储映射"><a class="header" href="#声明和使用存储映射">声明和使用存储映射</a></h2>
<!-- TODO PHANTOM TYPES -->
<!-- [phantom types]: ./ch12-03-intro-to-phantom-data.html -->
<pre><code class="language-cairo noplayground">#[starknet::contract]
mod UserValues {
    use starknet::storage::{
        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
    };
    use starknet::{ContractAddress, get_caller_address};

    #[storage]
    struct Storage {
        user_values: Map&lt;ContractAddress, u64&gt;,
    }

    #[abi(embed_v0)]
    impl UserValuesImpl of super::IUserValues&lt;ContractState&gt; {
        // ANCHOR: write
        fn set(ref self: ContractState, amount: u64) {
            let caller = get_caller_address();
            self.user_values.entry(caller).write(amount);
        }
        // ANCHOR_END: write

        // ANCHOR: read
        fn get(self: @ContractState, address: ContractAddress) -&gt; u64 {
            self.user_values.entry(address).read()
        }
        // ANCHOR_END: read
    }
}
</code></pre>
<p>{{#label storage-mappings}} <span class="caption">清单 {{#ref storage-mappings}}: 在 Storage 结构体中声明存储映射</span></p>
<p>要读取映射中对应于键的值，首先需要检索与该键关联的存储指针。这通过在存储映射变量上调用 <code>entry</code> 方法，传入键作为参数来完成。一旦有了 entry 路径，就可以在其上调用 <code>read</code> 函数来检索存储的值。</p>
<pre><code class="language-cairo noplayground">        fn get(self: @ContractState, address: ContractAddress) -&gt; u64 {
            self.user_values.entry(address).read()
        }
</code></pre>
<p>同样，要在存储映射中写入值，你需要检索对应于键的存储指针。一旦有了这个存储指针，就可以调用 <code>write</code> 函数并传入要写入的值。</p>
<pre><code class="language-cairo noplayground">        fn set(ref self: ContractState, amount: u64) {
            let caller = get_caller_address();
            self.user_values.entry(caller).write(amount);
        }
</code></pre>
<h2 id="嵌套映射"><a class="header" href="#嵌套映射">嵌套映射</a></h2>
<p>你还可以创建具有多个键的更复杂的映射。为了说明这一点，我们将实现一个代表分配给用户的仓库的合约，其中每个用户可以存储多个项目及其各自的数量。</p>
<p><code>user_warehouse</code> 映射是一个存储映射，它将 <code>ContractAddress</code> 映射到另一个将 <code>u64</code>（项目 ID）映射到 <code>u64</code>（数量）的映射。这可以通过在存储结构体中声明 <code>Map&lt;ContractAddress, Map&lt;u64, u64&gt;&gt;</code> 来实现。<code>user_warehouse</code> 映射中的每个 <code>ContractAddress</code> 键对应一个用户的仓库，每个用户的仓库包含一个项目 ID 到其各自数量的映射。</p>
<pre><code class="language-cairo noplayground">    #[storage]
    struct Storage {
        user_warehouse: Map&lt;ContractAddress, Map&lt;u64, u64&gt;&gt;,
    }
</code></pre>
<p>在这种情况下，访问存储值的原则相同。你需要逐步遍历键，使用 <code>entry</code> 方法获取序列中下一个键的存储路径，最后在最内层的映射上调用 <code>read</code> 或 <code>write</code>。</p>
<pre><code class="language-cairo noplayground">        fn set_quantity(ref self: ContractState, item_id: u64, quantity: u64) {
            let caller = get_caller_address();
            self.user_warehouse.entry(caller).entry(item_id).write(quantity);
        }

        fn get_item_quantity(self: @ContractState, address: ContractAddress, item_id: u64) -&gt; u64 {
            self.user_warehouse.entry(address).entry(item_id).read()
        }
</code></pre>
<h2 id="映射的存储地址计算"><a class="header" href="#映射的存储地址计算">映射的存储地址计算</a></h2>
<p>存储在映射中的变量在存储中的地址根据以下规则计算：</p>
<ul>
<li>对于单个键 <code>k</code>，键 <code>k</code> 处的值的地址是 <code>h(sn_keccak(variable_name), k)</code>，其中 <code>h</code> 是 Pedersen 哈希，最终值取模 \( {2^{251}} - 256\)。</li>
<li>对于多个键，地址计算为 <code>h(...h(h(sn_keccak(variable_name), k_1), k_2), ..., k_n)</code>，其中 <code>k_1, ..., k_n</code> 是构成映射的所有键。</li>
</ul>
<p>如果映射的键是结构体，则结构体的每个元素都构成一个键。此外，结构体应该实现 <code>Hash</code> trait，可以通过 <code>#[derive(Hash)]</code> 属性派生。</p>
<h2 id="总结-11"><a class="header" href="#总结-11">总结</a></h2>
<ul>
<li>存储映射允许你将键映射到合约存储中的值。</li>
<li>使用 <code>Map</code> 类型声明映射。</li>
<li>使用 <code>entry</code> 方法和 <code>read</code>/<code>write</code> 函数访问映射。</li>
<li>映射可以包含其他映射，创建嵌套存储映射。</li>
<li>映射变量的地址是使用 <code>sn_keccak</code> 和 Pedersen 哈希函数计算的。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="使用向量存储集合"><a class="header" href="#使用向量存储集合">使用向量存储集合</a></h1>
<p><code>Vec</code> 类型提供了一种在合约存储中存储值集合的方法。在本节中，我们将探讨如何声明、添加元素到 <code>Vec</code> 以及从中检索元素，以及如何计算 <code>Vec</code> 变量的存储地址。</p>
<p><code>Vec</code> 类型由 Cairo 核心库在 <code>starknet::storage</code> 模块内提供。其关联方法定义在 <code>VecTrait</code> 和 <code>MutableVecTrait</code> traits 中，你也需要导入它们以便对 <code>Vec</code> 类型进行读写操作。</p>
<blockquote>
<p><code>Array&lt;T&gt;</code> 类型是 <strong>内存</strong> 类型，不能直接存储在合约存储中。对于存储，请使用 <code>Vec&lt;T&gt;</code> 类型，该类型是专为合约存储设计的 [幽灵类型 (phantom type)][phantom types]。然而，<code>Vec&lt;T&gt;</code> 有局限性：它不能作为常规变量实例化，不能用作函数参数，也不能作为常规结构体的成员包含在内。要处理 <code>Vec&lt;T&gt;</code> 的全部内容，你需要将其元素复制到内存 <code>Array&lt;T&gt;</code> 中（或从中复制）。</p>
</blockquote>
<h2 id="声明和使用存储向量"><a class="header" href="#声明和使用存储向量">声明和使用存储向量</a></h2>
<p>要声明存储向量，请使用尖括号 <code>&lt;&gt;</code> 括起来的 <code>Vec</code> 类型，指定它将存储的元素类型。在清单 {{#ref storage-vecs}} 中，我们创建了一个简单的合约，该合约注册所有调用它的地址并将它们存储在 <code>Vec</code> 中。然后我们可以检索第 <code>n</code> 个注册的地址，或所有注册的地址。</p>
<pre><code class="language-cairo noplayground">#[starknet::contract]
pub mod AddressList {
    use starknet::storage::{
        MutableVecTrait, StoragePointerReadAccess, StoragePointerWriteAccess, Vec, VecTrait,
    };
    use starknet::{ContractAddress, get_caller_address};

    //ANCHOR: storage_vecs
    #[storage]
    struct Storage {
        addresses: Vec&lt;ContractAddress&gt;,
    }
    //ANCHOR_END: storage_vecs

    #[abi(embed_v0)]
    impl AddressListImpl of super::IAddressList&lt;ContractState&gt; {
        //ANCHOR: push
        fn register_caller(ref self: ContractState) {
            let caller = get_caller_address();
            self.addresses.push(caller);
        }
        //ANCHOR_END: push

        //ANCHOR: read
        fn get_n_th_registered_address(
            self: @ContractState, index: u64,
        ) -&gt; Option&lt;ContractAddress&gt; {
            self.addresses.get(index).map(|ptr| ptr.read())
        }

        fn get_all_addresses(self: @ContractState) -&gt; Array&lt;ContractAddress&gt; {
            let mut addresses = array![];
            for i in 0..self.addresses.len() {
                addresses.append(self.addresses[i].read());
            }
            addresses
        }
        //ANCHOR_END: read

        //ANCHOR: modify
        fn modify_nth_address(ref self: ContractState, index: u64, new_address: ContractAddress) {
            self.addresses[index].write(new_address);
        }
        //ANCHOR_END: modify

        //ANCHOR: pop
        fn pop_last_registered_address(ref self: ContractState) -&gt; Option&lt;ContractAddress&gt; {
            self.addresses.pop()
        }
        //ANCHOR_END: pop
    }
}
</code></pre>
<p>{{#label storage-vecs}} <span class="caption">清单 {{#ref storage-vecs}}: 在 Storage 结构体中声明存储 <code>Vec</code></span></p>
<p>要向 <code>Vec</code> 添加元素，可以使用 <code>push</code> 方法将元素添加到 <code>Vec</code> 的末尾。</p>
<pre><code class="language-cairo noplayground">        fn register_caller(ref self: ContractState) {
            let caller = get_caller_address();
            self.addresses.push(caller);
        }
</code></pre>
<p>要检索元素，你可以使用索引语法 (<code>vec[index]</code>) 或 <code>at</code>/<code>get</code> 方法来获取指向指定索引处元素的存储指针，然后调用 <code>read()</code> 来获取值。如果索引越界，<code>at</code>（和索引）会 panic，而 <code>get</code> 返回 <code>None</code>。</p>
<pre><code class="language-cairo noplayground">        fn get_n_th_registered_address(
            self: @ContractState, index: u64,
        ) -&gt; Option&lt;ContractAddress&gt; {
            self.addresses.get(index).map(|ptr| ptr.read())
        }

        fn get_all_addresses(self: @ContractState) -&gt; Array&lt;ContractAddress&gt; {
            let mut addresses = array![];
            for i in 0..self.addresses.len() {
                addresses.append(self.addresses[i].read());
            }
            addresses
        }
</code></pre>
<p>如果你想检索 Vec 的所有元素，你可以迭代存储 <code>Vec</code> 的索引，读取每个索引处的值，并将其追加到内存 <code>Array&lt;T&gt;</code> 中。同样，你不能在存储中存储 <code>Array&lt;T&gt;</code>：你需要迭代数组的元素并将它们追加到存储 <code>Vec&lt;T&gt;</code> 中。</p>
<p>在这一点上，你应该熟悉 <a href="#合约存储-contract-storage">“合约存储”</a> 一节中介绍的存储指针和存储路径的概念，以及如何使用它们通过基于指针的模型访问存储变量。那么你会如何修改存储在 <code>Vec</code> 特定索引处的地址呢？</p>
<pre><code class="language-cairo noplayground">        fn modify_nth_address(ref self: ContractState, index: u64, new_address: ContractAddress) {
            self.addresses[index].write(new_address);
        }
</code></pre>
<p>答案相当简单：获取指向所需索引处存储指针的可变指针，并使用 <code>write</code> 方法修改该索引处的值。</p>
<p>你还可以使用 <code>pop</code> 方法删除存储 <code>Vec</code> 的最后一个元素。如果向量非空，它返回 <code>Some(value)</code>，否则返回 <code>None</code>，并相应地更新存储的长度。</p>
<pre><code class="language-cairo noplayground">        fn pop_last_registered_address(ref self: ContractState) -&gt; Option&lt;ContractAddress&gt; {
            self.addresses.pop()
        }
</code></pre>
<h2 id="vecs-的存储地址计算"><a class="header" href="#vecs-的存储地址计算">Vecs 的存储地址计算</a></h2>
<p>存储在 <code>Vec</code> 中的变量在存储中的地址根据以下规则计算：</p>
<ul>
<li><code>Vec</code> 的长度存储在基地址，计算为 <code>sn_keccak(variable_name)</code>。</li>
<li><code>Vec</code> 的元素存储在计算为 <code>h(base_address, i)</code> 的地址处，其中 <code>i</code> 是元素在 <code>Vec</code> 中的索引，<code>h</code> 是 Pedersen 哈希函数。</li>
</ul>
<h2 id="总结-12"><a class="header" href="#总结-12">总结</a></h2>
<ul>
<li>使用 <code>Vec</code> 类型在合约存储中存储值集合</li>
<li>使用 <code>push</code> 方法添加元素，使用 <code>pop</code> 方法删除最后一个元素，使用 <code>at</code>/indexing 或 <code>get</code> 方法读取元素</li>
<li><code>Vec</code> 变量的地址是使用 <code>sn_keccak</code> 和 Pedersen 哈希函数计算的</li>
</ul>
<p>这就结束了我们的合约存储之旅！在下一节中，我们将开始查看合约中定义的不同类型的函数。你已经知道它们中的大多数，因为我们在前面的章节中使用过它们，但我们将更详细地解释它们。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="合约函数"><a class="header" href="#合约函数">合约函数</a></h1>
<p>在本节中，我们将查看你在 Starknet 智能合约中可能遇到的不同类型的函数。</p>
<p>函数可以通过 <code>self: ContractState</code> 对象轻松访问合约的状态，这抽象了底层系统调用（<code>storage_read_syscall</code> 和 <code>storage_write_syscall</code>）的复杂性。编译器提供了两个修饰符：<code>ref</code> 和 <code>@</code> 来修饰 <code>self</code>，旨在区分视图函数和外部函数。</p>
<p>让我们考虑清单 {{#ref reference-contract}} 中的 <code>NameRegistry</code> 合约，我们将在本章中使用它：</p>
<pre><code class="language-cairo noplayground">use starknet::ContractAddress;

#[starknet::interface]
pub trait INameRegistry&lt;TContractState&gt; {
    fn store_name(ref self: TContractState, name: felt252);
    fn get_name(self: @TContractState, address: ContractAddress) -&gt; felt252;
}

// ANCHOR: contract
#[starknet::contract]
mod NameRegistry {
    use starknet::storage::{
        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
    };
    use starknet::{ContractAddress, get_caller_address};

    //ANCHOR: storage
    #[storage]
    struct Storage {
        names: Map&lt;ContractAddress, felt252&gt;,
        total_names: u128,
    }
    //ANCHOR_END: storage

    //ANCHOR: person
    #[derive(Drop, Serde, starknet::Store)]
    pub struct Person {
        address: ContractAddress,
        name: felt252,
    }
    //ANCHOR_END: person

    //ANCHOR: constructor
    #[constructor]
    fn constructor(ref self: ContractState, owner: Person) {
        self.names.entry(owner.address).write(owner.name);
        self.total_names.write(1);
    }
    //ANCHOR_END: constructor

    //ANCHOR: impl_public
    // Public functions inside an impl block
    #[abi(embed_v0)]
    impl NameRegistry of super::INameRegistry&lt;ContractState&gt; {
        //ANCHOR: external
        fn store_name(ref self: ContractState, name: felt252) {
            let caller = get_caller_address();
            self._store_name(caller, name);
        }
        //ANCHOR_END: external

        //ANCHOR: view
        fn get_name(self: @ContractState, address: ContractAddress) -&gt; felt252 {
            //ANCHOR: read
            self.names.entry(address).read()
            //ANCHOR_END: read
        }
        //ANCHOR_END: view
    }
    //ANCHOR_END: impl_public

    //ANCHOR: standalone
    // Standalone public function
    #[external(v0)]
    fn get_contract_name(self: @ContractState) -&gt; felt252 {
        'Name Registry'
    }
    //ANCHOR_END: standalone

    // ANCHOR: state_internal
    // ANCHOR: generate_trait
    // Could be a group of functions about a same topic
    #[generate_trait]
    impl InternalFunctions of InternalFunctionsTrait {
        fn _store_name(ref self: ContractState, user: ContractAddress, name: felt252) {
            let total_names = self.total_names.read();

            //ANCHOR: write
            self.names.entry(user).write(name);
            //ANCHOR_END: write

            self.total_names.write(total_names + 1);
        }
    }
    // ANCHOR_END: generate_trait

    // Free function
    fn get_total_names_storage_address(self: @ContractState) -&gt; felt252 {
        //ANCHOR: total_names_address
        self.total_names.__base_address__
        //ANCHOR_END:total_names_address
    }
    // ANCHOR_END: state_internal
}
// ANCHOR_END: contract
</code></pre>
<p>{{#label reference-contract}} <span class="caption">清单 {{#ref reference-contract}}: 本章的参考合约</span></p>
<h2 id="1-构造函数-constructors"><a class="header" href="#1-构造函数-constructors">1. 构造函数 (Constructors)</a></h2>
<p>构造函数是一种特殊类型的函数，仅在部署合约时运行一次，可用于初始化合约的状态。</p>
<pre><code class="language-cairo noplayground">    #[constructor]
    fn constructor(ref self: ContractState, owner: Person) {
        self.names.entry(owner.address).write(owner.name);
        self.total_names.write(1);
    }
</code></pre>
<p>一些需要注意的重要规则：</p>
<ol>
<li>一个合约不能有多个构造函数。</li>
<li>构造函数必须命名为 <code>constructor</code>，并且必须用 <code>#[constructor]</code> 属性注释。</li>
</ol>
<p><code>constructor</code> 函数可能接受参数，这些参数在部署合约时传递。在我们的例子中，我们传递一些对应于 <code>Person</code> 类型的值作为参数，以便在合约中存储 <code>owner</code> 信息（地址和名称）。</p>
<p>注意，<code>constructor</code> 函数 <strong>必须</strong> 将 <code>self</code> 作为第一个参数，对应于合约的状态，通常使用 <code>ref</code> 关键字按引用传递，以便能够修改合约的状态。我们将很快解释 <code>self</code> 及其类型。</p>
<h2 id="2-公共函数-public-functions"><a class="header" href="#2-公共函数-public-functions">2. 公共函数 (Public Functions)</a></h2>
<p>如前所述，公共函数可以从合约外部访问。它们通常定义在用 <code>#[abi(embed_v0)]</code> 属性注释的实现块内，但也可能独立定义在 <code>#[external(v0)]</code> 属性下。</p>
<p><code>#[abi(embed_v0)]</code> 属性意味着嵌入在其中的所有函数都是合约 Starknet 接口的实现，因此是潜在的入口点。</p>
<p>用 <code>#[abi(embed_v0)]</code> 属性注释 impl 块只会影响它包含的函数的可见性（即，公开 vs 私有/内部），但它不会告知我们这些函数修改合约状态的能力。</p>
<pre><code class="language-cairo noplayground">    // Public functions inside an impl block
    #[abi(embed_v0)]
    impl NameRegistry of super::INameRegistry&lt;ContractState&gt; {
        //ANCHOR: external
        fn store_name(ref self: ContractState, name: felt252) {
            let caller = get_caller_address();
            self._store_name(caller, name);
        }
        //ANCHOR_END: external

        //ANCHOR: view
        fn get_name(self: @ContractState, address: ContractAddress) -&gt; felt252 {
            //ANCHOR: read
            self.names.entry(address).read()
            //ANCHOR_END: read
        }
        //ANCHOR_END: view
    }
</code></pre>
<blockquote>
<p>与 <code>constructor</code> 函数类似，所有公共函数，无论是用 <code>#[external(v0)]</code> 注释的独立函数，还是用 <code>#[abi(embed_v0)]</code> 属性注释的 impl 块内的函数，<strong>必须</strong> 将 <code>self</code> 作为第一个参数。私有函数则不是这种情况。</p>
</blockquote>
<h3 id="外部函数-external-functions"><a class="header" href="#外部函数-external-functions">外部函数 (External Functions)</a></h3>
<p>外部函数是 <em>公共</em> 函数，其中 <code>self: ContractState</code> 参数通过 <code>ref</code> 关键字按引用传递，这同时暴露了对存储变量的 <code>read</code> 和 <code>write</code> 访问权限。这允许直接通过 <code>self</code> 修改合约的状态。</p>
<pre><code class="language-cairo noplayground">        fn store_name(ref self: ContractState, name: felt252) {
            let caller = get_caller_address();
            self._store_name(caller, name);
        }
</code></pre>
<h3 id="视图函数-view-functions"><a class="header" href="#视图函数-view-functions">视图函数 (View Functions)</a></h3>
<p>视图函数是 <em>公共</em> 函数，其中 <code>self: ContractState</code> 参数作为快照传递，这只允许对存储变量的 <code>read</code> 访问，并通过导致编译错误来限制通过 <code>self</code> 对存储进行的写入。编译器会将其 <em>state_mutability</em> 标记为 <code>view</code>，防止通过 <code>self</code> 直接进行任何状态修改。</p>
<pre><code class="language-cairo noplayground">        fn get_name(self: @ContractState, address: ContractAddress) -&gt; felt252 {
            //ANCHOR: read
            self.names.entry(address).read()
            //ANCHOR_END: read
        }
</code></pre>
<h3 id="公共函数的状态可变性"><a class="header" href="#公共函数的状态可变性">公共函数的状态可变性</a></h3>
<p>然而，正如你可能已经注意到的，作为快照传递 <code>self</code> 仅限制了编译时通过 <code>self</code> 的存储写入访问。它并不阻止通过直接系统调用进行状态修改，也不阻止调用另一个会修改状态的合约。</p>
<p>视图函数的只读属性并未在 Starknet 上强制执行，发送针对视图函数的交易 <em>由于</em> 可以改变状态。</p>
<!-- TODO: add an example of a view function that could modify the state using low-level syscalls -->
<p>总之，尽管外部函数和视图函数由 Cairo 编译器区分，但 <strong>所有公共函数</strong> 都可以通过 invoke 交易调用，并且有可能修改 Starknet 状态。此外，所有公共函数都可以使用 <code>starknet_call</code> RPC 方法调用，这将不会创建交易，因此不会改变状态。</p>
<blockquote>
<p><strong>警告：</strong> 这与 EVM 不同，在 EVM 中提供了 <code>staticcall</code> 操作码，它可以防止当前上下文和子上下文中的存储修改。因此，开发人员 <strong>不应</strong> 假设在另一个合约上调用视图函数不会修改状态。</p>
</blockquote>
<h3 id="独立公共函数"><a class="header" href="#独立公共函数">独立公共函数</a></h3>
<p>也可以使用 <code>#[external(v0)]</code> 属性在 trait 实现之外定义公共函数。这样做会自动在合约 ABI 中生成一个条目，允许任何人从外部调用这些独立的公共函数。这些函数也可以像 Starknet 合约中的任何函数一样从合约内部调用。第一个参数必须是 <code>self</code>。</p>
<p>在这里，我们在 impl 块之外定义了一个独立的 <code>get_contract_name</code> 函数：</p>
<pre><code class="language-cairo noplayground">    // Standalone public function
    #[external(v0)]
    fn get_contract_name(self: @ContractState) -&gt; felt252 {
        'Name Registry'
    }
</code></pre>
<h2 id="3-私有函数-private-functions"><a class="header" href="#3-私有函数-private-functions">3. 私有函数 (Private Functions)</a></h2>
<p>没有使用 <code>#[external(v0)]</code> 属性定义的函数，或者不在用 <code>#[abi(embed_v0)]</code> 属性注释的块内的函数是私有函数（也称为内部函数）。它们只能从合约内部调用。</p>
<p>它们可以分组在一个专用的 impl 块中（例如，在组件中，以便在嵌入合约中一次性轻松导入内部函数），或者只是作为自由函数添加到合约模块中。注意这 2 种方法是等效的。只需选择使你的代码更具可读性和易于使用的一种即可。</p>
<pre><code class="language-cairo noplayground">    // ANCHOR: generate_trait
    // Could be a group of functions about a same topic
    #[generate_trait]
    impl InternalFunctions of InternalFunctionsTrait {
        fn _store_name(ref self: ContractState, user: ContractAddress, name: felt252) {
            let total_names = self.total_names.read();

            //ANCHOR: write
            self.names.entry(user).write(name);
            //ANCHOR_END: write

            self.total_names.write(total_names + 1);
        }
    }
    // ANCHOR_END: generate_trait

    // Free function
    fn get_total_names_storage_address(self: @ContractState) -&gt; felt252 {
        //ANCHOR: total_names_address
        self.total_names.__base_address__
        //ANCHOR_END:total_names_address
    }
</code></pre>
<blockquote>
<p>等等，这个 <code>#[generate_trait]</code> 属性是什么？这个实现的 trait 定义在哪里？嗯，<code>#[generate_trait]</code> 属性是一个特殊的属性，它告诉编译器为实现块生成 trait 定义。这允许你摆脱定义带有泛型参数的 trait 并为实现块实现它的样板代码。有了这个属性，我们可以简单地直接定义实现块，无需任何泛型参数，并在我们的函数中使用 <code>self: ContractState</code>。</p>
</blockquote>
<p><code>#[generate_trait]</code> 属性主要用于定义私有 impl 块。它也可以与 <code>#[abi(per_item)]</code> 一起使用来定义合约的各种入口点（见 <a href="#4-abiper_item-attribute">下一节</a>）。</p>
<blockquote>
<p>注意：对于公共 impl 块，不建议在 <code>#[abi(embed_v0)]</code> 属性之外使用 <code>#[generate_trait]</code>，因为这将导致无法生成相应的 ABI。只有当公共函数被定义在同时用 <code>#[abi(per_item)]</code> 属性注释的 impl 块中时，该块才应用 <code>#[generate_trait]</code> 注释。</p>
</blockquote>
<h2 id="abiper_item-属性"><a class="header" href="#abiper_item-属性"><code>[abi(per_item)]</code> 属性</a></h2>
<p>你也可以在 impl 块内使用 <code>#[abi(per_item)]</code> 属性单独定义函数的入口点类型。它通常与 <code>#[generate_trait]</code> 属性一起使用，因为它允许你在没有显式接口的情况下定义入口点。在这种情况下，函数不会在 ABI 中归类在 impl 下。注意，当使用 <code>#[abi(per_item)]</code> 属性时，公共函数需要用 <code>#[external(v0)]</code> 属性注释 - 否则，它们将不会被公开，并将被视为私有函数。</p>
<p>这是一个简短的例子：</p>
<pre><code class="language-cairo noplayground">#[starknet::contract]
mod ContractExample {
    #[storage]
    struct Storage {}

    #[abi(per_item)]
    #[generate_trait]
    impl SomeImpl of SomeTrait {
        #[constructor]
        // this is a constructor function
        fn constructor(ref self: ContractState) {}

        #[external(v0)]
        // this is a public function
        fn external_function(ref self: ContractState, arg1: felt252) {}

        #[l1_handler]
        // this is a l1_handler function
        fn handle_message(ref self: ContractState, from_address: felt252, arg: felt252) {}

        // this is an internal function
        fn internal_function(self: @ContractState) {}
    }
}
</code></pre>
<p>在不使用 <code>#[generate_trait]</code> 而使用 <code>#[abi(per_item)]</code> 属性的情况下，只能在 trait 实现中包含 <code>constructor</code>、<code>l1-handler</code> 和 <code>internal</code> 函数。实际上，<code>#[abi(per_item)]</code> 仅适用于未定义为 Starknet 接口的 trait。因此，必须创建另一个定义为接口的 trait 来实现公共函数。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="合约事件"><a class="header" href="#合约事件">合约事件</a></h1>
<p>事件是智能合约通知外部世界再其执行过程中发生了任何变化的一种方式。它们在智能合约集成到现实世界应用程序中起着关键作用。</p>
<p>从技术上讲，事件是智能合约在执行期间发出的自定义数据结构，并存储在相应的交易收据中，允许任何外部工具解析和索引它（最常见的是 <a href="https://docs.starknet.io/tools/overview/">Starknet SDK</a>，如 <a href="https://starknetjs.com/docs/guides/contracts/events/">Starknet.js</a>）。</p>
<h2 id="定义事件"><a class="header" href="#定义事件">定义事件</a></h2>
<p>智能合约的事件定义在一个用属性 <code>#[event]</code> 注释的枚举中。此枚举必须命名为 <code>Event</code>。</p>
<pre><code class="language-cairo noplayground">    //ANCHOR: full_events
    #[event]
    #[derive(Drop, starknet::Event)]
    pub enum Event {
        BookAdded: BookAdded,
        #[flat]
        FieldUpdated: FieldUpdated,
        BookRemoved: BookRemoved,
    }
</code></pre>
<p>每个变体，如 <code>BookAdded</code> 或 <code>FieldUpdated</code> 代表一个可以由合约发出的事件。变体数据表示与事件关联的数据。它可以是任何实现了 <code>starknet::Event</code> trait 的 <code>struct</code> 或 <code>enum</code>。这可以通过在你的类型定义之上简单地添加 <code>#[derive(starknet::Event)]</code> 属性来实现。</p>
<p>每个事件数据字段都可以用属性 <code>#[key]</code> 注释。键字段与数据字段分开存储，以供外部工具使用，以便轻松地根据这些键过滤事件。</p>
<p>让我们看看这个示例的完整事件定义，用于添加、更新和删除书籍：</p>
<pre><code class="language-cairo noplayground">    #[event]
    #[derive(Drop, starknet::Event)]
    pub enum Event {
        BookAdded: BookAdded,
        #[flat]
        FieldUpdated: FieldUpdated,
        BookRemoved: BookRemoved,
    }
    //ANCHOR_END: event

    #[derive(Drop, starknet::Event)]
    pub struct BookAdded {
        pub id: u32,
        pub title: felt252,
        #[key]
        pub author: felt252,
    }

    #[derive(Drop, starknet::Event)]
    pub enum FieldUpdated {
        Title: UpdatedTitleData,
        Author: UpdatedAuthorData,
    }

    #[derive(Drop, starknet::Event)]
    pub struct UpdatedTitleData {
        #[key]
        pub id: u32,
        pub new_title: felt252,
    }

    #[derive(Drop, starknet::Event)]
    pub struct UpdatedAuthorData {
        #[key]
        pub id: u32,
        pub new_author: felt252,
    }

    #[derive(Drop, starknet::Event)]
    pub struct BookRemoved {
        pub id: u32,
    }
</code></pre>
<p>在这个例子中：</p>
<ul>
<li>有 3 个事件：<code>BookAdded</code>、<code>FieldUpdated</code> 和 <code>BookRemoved</code>，</li>
<li><code>BookAdded</code> 和 <code>BookRemoved</code> 事件使用简单的 <code>struct</code> 来存储它们的数据，而 <code>FieldUpdated</code> 事件使用结构体的 <code>enum</code>，</li>
<li>在 <code>BookAdded</code> 事件中，<code>author</code> 字段是一个键字段，将在智能合约外部用于按 <code>author</code> 过滤 <code>BookAdded</code> 事件，而 <code>id</code> 和 <code>title</code> 是数据字段。</li>
</ul>
<blockquote>
<p><strong>变体</strong> 及其关联的数据结构可以命名不同，尽管通常的做法是使用相同的名称。<strong>变体名称</strong> 在内部用作 <strong>第一个事件键</strong> 来表示事件的名称并帮助过滤事件，而 <strong>变体数据名称</strong> 在智能合约中用于在发出事件之前 <strong>构建事件</strong>。</p>
</blockquote>
<h3 id="flat-属性"><a class="header" href="#flat-属性">#[flat] 属性</a></h3>
<p>有时你可能有一个复杂的事件结构，其中嵌套了一些枚举，例如前一个示例中的 <code>FieldUpdated</code> 事件。在这种情况下，你可以使用 <code>#[flat]</code> 属性展平此结构，这意味着使用内部变体名称作为事件名称，而不是注释枚举的变体名称。在前面的示例中，因为 <code>FieldUpdated</code> 变体用 <code>#[flat]</code> 注释，当你发出 <code>FieldUpdated::Title</code> 事件时，它的名称将是 <code>Title</code> 而不是 <code>FieldUpdated</code>。如果你的嵌套枚举超过 2 层，你可以在多个级别上使用 <code>#[flat]</code> 属性。</p>
<h2 id="发出事件"><a class="header" href="#发出事件">发出事件</a></h2>
<p>定义了事件列表后，你想在智能合约中发出它们。这可以通过调用 <code>self.emit()</code> 并传入事件数据结构作为参数来简单实现。</p>
<pre><code class="language-cairo noplayground">        fn add_book(ref self: ContractState, id: u32, title: felt252, author: felt252) {
            // ... logic to add a book in the contract storage ...
            self.emit(BookAdded { id, title, author });
        }

        fn change_book_title(ref self: ContractState, id: u32, new_title: felt252) {
            self.emit(FieldUpdated::Title(UpdatedTitleData { id, new_title }));
        }

        fn change_book_author(ref self: ContractState, id: u32, new_author: felt252) {
            self.emit(FieldUpdated::Author(UpdatedAuthorData { id, new_author }));
        }

        fn remove_book(ref self: ContractState, id: u32) {
            self.emit(BookRemoved { id });
        }
</code></pre>
<p>为了更好地理解幕后发生的事情，让我们看两个发出的事件以及它们如何存储在交易收据中的示例：</p>
<h3 id="示例-1-添加一本书"><a class="header" href="#示例-1-添加一本书">示例 1: 添加一本书</a></h3>
<p>在这个例子中，我们发送一个交易，调用 <code>add_book</code> 函数，参数为 <code>id</code> = 42, <code>title</code> = ‘Misery’ 和 <code>author</code> = ‘S. King’。</p>
<p>如果你阅读交易收据的 “events” 部分，你会得到类似以下内容：</p>
<pre><code class="language-json">"events": [
    {
      "from_address": "0x27d07155a12554d4fd785d0b6d80c03e433313df03bb57939ec8fb0652dbe79",
      "keys": [
        "0x2d00090ebd741d3a4883f2218bd731a3aaa913083e84fcf363af3db06f235bc",
        "0x532e204b696e67"
      ],
      "data": [
        "0x2a",
        "0x4d6973657279"
      ]
    }
  ]
</code></pre>
<p>在此收据中：</p>
<ul>
<li><code>from_address</code> 是你的智能合约的地址，</li>
<li><code>keys</code> 包含发出的 <code>BookAdded</code> 事件的键字段，序列化为 <code>felt252</code> 数组。
<ul>
<li>第一个键 <code>0x2d00090ebd741d3a4883f2218bd731a3aaa913083e84fcf363af3db06f235bc</code> 是事件名称的选择器，即 <code>Event</code> 枚举中的变体名称，所以是 <code>selector!("BookAdded")</code>，</li>
<li>第二个键 <code>0x532e204b696e67 = 'S. King'</code> 是事件的 <code>author</code> 字段，因为它已使用 <code>#[key]</code> 属性定义，</li>
</ul>
</li>
<li><code>data</code> 包含发出的 <code>BookAdded</code> 事件的数据字段，序列化为 <code>felt252</code> 数组。第一项 <code>0x2a = 42</code> 是 <code>id</code> 数据字段，<code>0x4d6973657279 = 'Misery'</code> 是 <code>title</code> 数据字段。</li>
</ul>
<h3 id="示例-2-更新书籍作者"><a class="header" href="#示例-2-更新书籍作者">示例 2: 更新书籍作者</a></h3>
<p>现在我们想更改书籍的作者姓名，所以我们发送一个交易，调用 <code>change_book_author</code>，参数为 <code>id</code> = <code>42</code> 和 <code>new_author</code> = ‘Stephen King’。</p>
<p>此 <code>change_book_author</code> 调用发出一个 <code>FieldUpdated</code> 事件，事件数据为 <code>FieldUpdated::Author(UpdatedAuthorData { id: 42, title: author: 'Stephen King' })</code>。如果你阅读交易收据的 “events” 部分，你会得到类似以下内容：</p>
<pre><code class="language-json">"events": [
    {
      "from_address": "0x27d07155a12554d4fd785d0b6d80c03e433313df03bb57939ec8fb0652dbe79",
      "keys": [
        "0x1b90a4a3fc9e1658a4afcd28ad839182217a69668000c6104560d6db882b0e1",
        "0x2a"
      ],
      "data": [
        "0x5374657068656e204b696e67"
      ]
    }
  ]
</code></pre>
<p>由于 <code>Event</code> 枚举中的 <code>FieldUpdated</code> 变体已用 <code>#[flat]</code> 属性注释，因此使用内部变体 <code>Author</code> 作为事件名称，而不是 <code>FieldUpdated</code>。所以：</p>
<ul>
<li>第一个键是 <code>selector!("Author")</code>，</li>
<li>第二个键是 <code>id</code> 字段，用 <code>#[key]</code> 注释，</li>
<li>数据字段是 <code>0x5374657068656e204b696e67 = 'Stephen King'</code>。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="与-starknet-合约交互"><a class="header" href="#与-starknet-合约交互">与 Starknet 合约交互</a></h1>
<p>如果没有外部触发，智能合约无法自行执行。它需要由外部实体调用，例如用户或另一个智能合约。智能合约相互交互的可能性使得创建复杂的应用程序成为可能，其中每个合约的范围仅限于特定的功能。</p>
<p>本章阐明了如何与智能合约交互并使它们相互交互。具体来说，你将了解什么是 <em>应用程序二进制接口 (Application Binary Interface, ABI)</em>，如何调用智能合约，以及如何使合约相互通信。你还将学习如何正确地将类用作 <em>库 (libraries)</em>，以及何时使用它们。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="合约类-abi"><a class="header" href="#合约类-abi">合约类 ABI</a></h1>
<p>合约类 <em>应用程序二进制接口 (Application Binary Interface, ABI)</em> 是合约接口的高级规范。它描述了可以调用的函数、它们的预期参数和返回值，以及这些参数和返回值的类型。它允许外部源（包括区块链外部和其他合约）通过根据合约接口对数据进行编码和解码来与合约进行通信。</p>
<p>通常，区块链外部的源使用 ABI 的 JSON 表示形式与合约进行交互。此 JSON 表示形式是从合约类生成的，并且包含一个项目数组，这些项目可以是类型、函数或事件。</p>
<p>另一方面，合约通过 <em>分发器 (dispatcher)</em> 模式直接在 Cairo 中使用另一个合约的 ABI，这是一种实现调用另一个合约函数的方法的特定类型。这些方法是自动生成的，并且包含对发送到合约的数据进行编码和解码所需的全部逻辑。</p>
<p>当你使用像 <a href="https://voyager.online/">Voyager</a> 或 <a href="https://starkscan.co/">Starkscan</a> 这样的区块浏览器与智能合约交互时，JSON ABI 用于正确编码你发送给合约的数据并解码它返回的数据。</p>
<h2 id="入口点-entrypoints"><a class="header" href="#入口点-entrypoints">入口点 (Entrypoints)</a></h2>
<p>合约 ABI 中公开的所有函数都称为 <em>入口点</em>。入口点是可以从合约类外部调用的函数。</p>
<p>Starknet 合约中有 3 种不同类型的入口点：</p>
<ul>
<li><a href="#2-public-functions">公共函数</a>，最常见的入口点，根据其状态可变性作为 <code>view</code> 或 <code>external</code> 公开。</li>
</ul>
<blockquote>
<p>注意：入口点可以标记为 <code>view</code>，但如果合约使用不可变性未由编译器强制执行的低级调用，则在随交易一起调用时仍可能修改合约的状态。</p>
</blockquote>
<ul>
<li>
<p>可选的唯一 <a href="#1-constructors"><em>构造函数</em></a>，这是一个特定的入口点，仅在合约部署期间调用一次。</p>
</li>
<li>
<p>L1 处理程序 (L1-Handlers)，这些函数只能由定序器在收到来自 L1 网络的包含调用合约指令的 <a href="#l1-l2-消息传递">消息</a> 后触发。</p>
</li>
</ul>
<p>在 Cairo 合约类中，函数入口点由 <em>选择器 (selector)</em> 和 <code>function_idx</code> 表示。</p>
<h2 id="函数选择器-function-selector"><a class="header" href="#函数选择器-function-selector">函数选择器 (Function Selector)</a></h2>
<p>虽然函数是用名称定义的，但入口点是由它们的 <em>选择器</em> 标识的。选择器是从函数名称派生的唯一标识符，简单地计算为 <code>sn_keccak(function_name)</code>。由于在 Cairo 中无法使用不同参数重载函数，因此函数名称的哈希足以唯一标识要调用的函数。</p>
<p>虽然此过程通常由库和使用分发器时抽象化，但要知道可以通过提供其选择器直接调用函数，例如在使用低级系统调用如 <code>starknet::call_contract_syscall</code> 或与 RPC 交互时。</p>
<h2 id="编码-encoding"><a class="header" href="#编码-encoding">编码 (Encoding)</a></h2>
<p>智能合约是用像 Cairo 这样的高级语言编写的，使用强类型来告知我们要处理的数据。然而，在区块链上执行的代码被编译成低级 CASM 指令序列。Starknet 中的基本数据类型是 <code>felt252</code>，这也是 CASM 级别操作的唯一数据。因此，所有数据必须在发送到合约之前序列化为 <code>felt252</code>。ABI 指定了类型如何编码为 <code>felt252</code> 序列，以及如何解码回其原始形式。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="与另一个合约交互"><a class="header" href="#与另一个合约交互">与另一个合约交互</a></h1>
<p>在上一节中，我们介绍了用于合约交互的分发器模式。本章将深入探讨这种模式并演示如何使用它。</p>
<p>分发器模式允许我们通过使用一个包装了合约地址并没有实现了由编译器从合约类 ABI 生成的分发器 trait 的结构体来调用另一个合约上的函数。这利用了 Cairo 的 trait 系统，提供了一种清晰且类型安全的方式与其他合约进行交互。</p>
<p>当定义了 <a href="#the-interface-the-contracts-blueprint">合约接口</a> 时，编译器会自动生成并导出多个分发器。例如，对于 <code>IERC20</code> 接口，编译器将生成以下分发器：</p>
<ul>
<li><em>合约分发器</em>：<code>IERC20Dispatcher</code> 和 <code>IERC20SafeDispatcher</code></li>
<li><em>库分发器</em>：<code>IERC20LibraryDispatcher</code> 和 <code>IERC20SafeLibraryDispatcher</code></li>
</ul>
<p>这些分发器有不同的用途：</p>
<ul>
<li>合约分发器包装合约地址，用于调用其他合约上的函数。</li>
<li>库分发器包装类哈希，用于调用类上的函数。库分发器将在下一章 <a href="#从另一个类执行代码">“从另一个类执行代码”</a> 中讨论。</li>
<li><em>‘Safe’</em> 分发器允许调用者处理调用执行期间可能发生的错误。</li>
</ul>
<p>在底层，这些分发器使用低级的 <a href="#附录-a---系统调用"><code>contract_call_syscall</code></a>，它允许我们通过传递合约地址、函数选择器和函数参数来调用其他合约上的函数。分发器抽象了这个系统调用的复杂性，提供了一种清晰且类型安全的方式与其他合约进行交互。</p>
<p>为了有效地分解涉及的概念，我们将使用 <code>ERC20</code> 接口作为示例。</p>
<h2 id="分发器模式-the-dispatcher-pattern"><a class="header" href="#分发器模式-the-dispatcher-pattern">分发器模式 (The Dispatcher Pattern)</a></h2>
<p>我们提到编译器会自动为给定的接口生成分发器结构体和分发器 trait。清单 {{#ref expanded-ierc20dispatcher}} 显示了为公开 <code>name</code> 视图函数和 <code>transfer</code> 外部函数的 <code>IERC20</code> 接口生成的项目的示例：</p>
<pre><code class="language-cairo noplayground">use starknet::ContractAddress;

trait IERC20DispatcherTrait&lt;T&gt; {
    fn name(self: T) -&gt; felt252;
    fn transfer(self: T, recipient: ContractAddress, amount: u256);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IERC20Dispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IERC20DispatcherImpl of IERC20DispatcherTrait&lt;IERC20Dispatcher&gt; {
    fn name(self: IERC20Dispatcher) -&gt; felt252 {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address, selector!("name"), core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(
            __dispatcher_return_data__,
        );
        core::option::OptionTrait::expect(
            core::serde::Serde::&lt;felt252&gt;::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
    fn transfer(self: IERC20Dispatcher, recipient: ContractAddress, amount: u256) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::&lt;ContractAddress&gt;::serialize(@recipient, ref __calldata__);
        core::serde::Serde::&lt;u256&gt;::serialize(@amount, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("transfer"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(
            __dispatcher_return_data__,
        );
        ()
    }
}
</code></pre>
<p>{{#label expanded-ierc20dispatcher}} <span class="caption">清单 {{#ref expanded-ierc20dispatcher}}: <code>IERC20Dispatcher</code> 及其关联 trait 和 impl 的简化示例</span></p>
<p>如你所见，合约分发器是一个简单的结构体，它包装了一个合约地址并实现了编译器生成的 <code>IERC20DispatcherTrait</code>。对于每个函数，trait 的实现将包含以下元素：</p>
<ul>
<li>将函数参数序列化为 <code>felt252</code> 数组 <code>__calldata__</code>。</li>
<li>使用 <code>contract_call_syscall</code> 进行低级合约调用，包含合约地址、函数选择器和 <code>__calldata__</code> 数组。</li>
<li>将返回值反序列化为预期的返回类型。</li>
</ul>
<h2 id="使用合约分发器调用合约"><a class="header" href="#使用合约分发器调用合约">使用合约分发器调用合约</a></h2>
<p>为了说明合约分发器的使用，让我们创建一个简单的合约，它与 ERC20 合约交互。这个包装器合约将允许我们调用 ERC20 合约上的 <code>name</code> 和 <code>transfer_from</code> 函数，如清单 {{#ref contract-dispatcher}} 所示：</p>
<pre><code class="language-cairo noplayground">//**** Specify interface here ****//
#[starknet::contract]
mod TokenWrapper {
    //ANCHOR: import
    use starknet::{ContractAddress, get_caller_address};
    //ANCHOR_END: import
    use super::ITokenWrapper;
    use super::{IERC20Dispatcher, IERC20DispatcherTrait};

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl TokenWrapper of ITokenWrapper&lt;ContractState&gt; {
        fn token_name(self: @ContractState, contract_address: ContractAddress) -&gt; felt252 {
            IERC20Dispatcher { contract_address }.name()
        }

        fn transfer_token(
            ref self: ContractState,
            address: ContractAddress,
            recipient: ContractAddress,
            amount: u256,
        ) -&gt; bool {
            let erc20_dispatcher = IERC20Dispatcher { contract_address: address };
            erc20_dispatcher.transfer_from(get_caller_address(), recipient, amount)
        }
    }
}
</code></pre>
<p>{{#label contract-dispatcher}} <span class="caption">清单 {{#ref contract-dispatcher}}: 使用分发器模式调用另一个合约的示例合约</span></p>
<p>在这个合约中，我们导入了 <code>IERC20Dispatcher</code> 结构体和 <code>IERC20DispatcherTrait</code> trait。然后我们将 ERC20 合约的地址包装在 <code>IERC20Dispatcher</code> 结构体的一个实例中。这允许我们在 ERC20 合约上调用 <code>name</code> 和 <code>transfer</code> 函数。</p>
<p>调用 <code>transfer_token</code> 外部函数将修改部署在 <code>contract_address</code> 的合约的状态。</p>
<h2 id="使用安全分发器处理错误"><a class="header" href="#使用安全分发器处理错误">使用安全分发器处理错误</a></h2>
<p>如前所述，像 <code>IERC20SafeDispatcher</code> 这样的 ‘Safe’ 分发器允许调用合约优雅地处理在执行被调用函数期间可能发生的潜在错误。</p>
<p>当通过安全分发器调用的函数发生 panic 时，执行将返回到调用者合约，并且安全分发器返回包含 panic 原因的 <code>Result::Err</code>。这允许开发人员在其合约中实现自定义错误处理逻辑。</p>
<p>考虑以下使用假设的 <code>IFailableContract</code> 接口的示例：</p>
<pre><code class="language-cairo noplayground">#[starknet::interface]
pub trait IFailableContract&lt;TState&gt; {
    fn can_fail(self: @TState) -&gt; u32;
}

#[feature("safe_dispatcher")]
fn interact_with_failable_contract() -&gt; u32 {
    let contract_address = 0x123.try_into().unwrap();
    // Use the Safe Dispatcher
    let faillable_dispatcher = IFailableContractSafeDispatcher { contract_address };
    let response: Result&lt;u32, Array&lt;felt252&gt;&gt; = faillable_dispatcher.can_fail();

    // Match the result to handle success or failure
    match response {
        Result::Ok(x) =&gt; x, // Return the value on success
        Result::Err(_panic_reason) =&gt; {
            // Handle the error, e.g., log it or return a default value
            // The panic_reason is an array of felts detailing the error
            0 // Return 0 in case of failure
        },
    }
}
</code></pre>
<p>{{#label safe-dispatcher}} <span class="caption">清单 {{#ref safe-dispatcher}}: 使用安全分发器处理错误</span></p>
<p>在此代码中，我们首先获取目标合约地址的 <code>IFailableContractSafeDispatcher</code> 实例。使用此安全分发器调用 <code>can_fail()</code> 函数返回 <code>Result&lt;u32, Array&lt;felt252&gt;&gt;</code>，它封装了成功的 <code>u32</code> 结果或失败信息。然后我们可以正确处理此结果，如 <a href="#错误处理">第 {{#chap error-handling}} 章：错误处理</a> 中所示。</p>
<blockquote>
<p>重要的是要注意，某些情况仍会导致立即的交易回滚，这意味着错误无法被调用者使用安全分发器捕获。这些包括：</p>
<ul>
<li>Cairo Zero 合约调用失败。</li>
<li>使用不存在的类哈希进行库调用。</li>
<li>对不存在的合约地址进行合约调用。</li>
<li><code>deploy</code> 系统调用内部失败（例如，构造函数中的 panic，部署到现有地址）。</li>
<li>使用不存在的类哈希使用 <code>deploy</code> 系统调用。</li>
<li>使用不存在的类哈希使用 <code>replace_class</code> 系统调用。</li>
</ul>
<p>预计在未来的 Starknet 版本中处理这些情况。</p>
</blockquote>
<h2 id="使用低级调用调用合约"><a class="header" href="#使用低级调用调用合约">使用低级调用调用合约</a></h2>
<p>调用其他合约的另一种方法是直接使用 <code>call_contract_syscall</code>。虽然不如使用分发器模式方便，但此系统调用提供了对序列化和反序列化过程的更多控制，并允许更自定义的错误处理。</p>
<p>清单 {{#ref syscalls}} 显示了一个示例，演示如何使用低级 <code>call_contract_sycall</code> 系统调用调用 <code>ERC20</code> 合约的 <code>transfer_from</code> 函数：</p>
<pre><code class="language-cairo noplayground">use starknet::ContractAddress;

#[starknet::interface]
trait ITokenWrapper&lt;TContractState&gt; {
    fn transfer_token(
        ref self: TContractState,
        address: ContractAddress,
        recipient: ContractAddress,
        amount: u256,
    ) -&gt; bool;
}

#[starknet::contract]
mod TokenWrapper {
    use starknet::{ContractAddress, SyscallResultTrait, get_caller_address, syscalls};
    use super::ITokenWrapper;

    #[storage]
    struct Storage {}

    impl TokenWrapper of ITokenWrapper&lt;ContractState&gt; {
        fn transfer_token(
            ref self: ContractState,
            address: ContractAddress,
            recipient: ContractAddress,
            amount: u256,
        ) -&gt; bool {
            let mut call_data: Array&lt;felt252&gt; = array![];
            Serde::serialize(@get_caller_address(), ref call_data);
            Serde::serialize(@recipient, ref call_data);
            Serde::serialize(@amount, ref call_data);

            let mut res = syscalls::call_contract_syscall(
                address, selector!("transfer_from"), call_data.span(),
            )
                .unwrap_syscall();

            Serde::&lt;bool&gt;::deserialize(ref res).unwrap()
        }
    }
}
</code></pre>
<p>{{#label syscalls}} <span class="caption">清单 {{#ref syscalls}}: 使用 <code>call_contract_sycall</code> 系统调用的示例合约</span></p>
<p>要使用此系统调用，我们传入合约地址、我们想要调用的函数的选择器和调用参数。调用参数必须作为参数数组提供，序列化为 <code>Span&lt;felt252&gt;</code>。要序列化参数，我们可以简单地使用 <code>Serde</code> trait，前提是要序列化的类型实现了此 trait。调用返回一个序列化值的数组，我们需要自己反序列化！</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="从另一个类执行代码"><a class="header" href="#从另一个类执行代码">从另一个类执行代码</a></h1>
<p>在前面的章节中，我们探讨了如何调用外部 <em>合约</em> 来执行其逻辑并更新其状态。但是如果我们想执行来自另一个类的代码而不更新另一个合约的状态呢？Starknet 通过 <em>库调用 (library calls)</em> 使这成为可能，它允许合约在自己的上下文中执行另一个类的逻辑，更新其自己的状态。</p>
<h2 id="库调用-library-calls"><a class="header" href="#库调用-library-calls">库调用 (Library calls)</a></h2>
<p><em>合约调用</em> 和 <em>库调用</em> 之间的主要区别在于类中定义的逻辑的执行上下文。虽然合约调用用于调用已部署 <strong>合约</strong> 中的函数，但库调用用于在调用者的上下文中调用无状态 <strong>类</strong>。</p>
<p>为了说明这一点，让我们考虑两个合约 <em>A</em> 和 <em>B</em>。</p>
<p>当 A 对 <strong>合约</strong> B 执行 <em>合约调用</em> 时，B 中定义的逻辑的执行上下文是 B 的上下文。因此，B 中的 <code>get_caller_address()</code> 将返回 A 的地址，B 中的 <code>get_contract_address()</code> 将返回 B 的地址，并且 B 中的任何存储更新都将更新 B 的存储。</p>
<p>然而，当 A 使用 <em>库调用</em> 来调用 B 的 <strong>类</strong> 时，B 中定义的逻辑的执行上下文是 A 的上下文。这意味着 B 中 <code>get_caller_address()</code> 返回的值将是 A 的调用者的地址，B 的类中 <code>get_contract_address()</code> 将返回 A 的地址，并且在 B 的类中更新存储变量将更新 A 的存储。</p>
<p>可以使用前一章介绍的分发器模式执行库调用，只是使用类哈希而不是合约地址。</p>
<p>清单 {{#ref expanded-ierc20-library}} 使用相同的 <code>IERC20</code> 示例描述了库分发器及其关联的 <code>IERC20DispatcherTrait</code> trait 和 impl：</p>
<pre><code class="language-cairo noplayground">//TAG: does_not_compile
use starknet::ContractAddress;

trait IERC20DispatcherTrait&lt;T&gt; {
    fn name(self: T) -&gt; felt252;
    fn transfer(self: T, recipient: ContractAddress, amount: u256);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IERC20LibraryDispatcher {
    class_hash: starknet::ClassHash,
}

impl IERC20LibraryDispatcherImpl of IERC20DispatcherTrait&lt;IERC20LibraryDispatcher&gt; {
    fn name(
        self: IERC20LibraryDispatcher,
    ) -&gt; felt252 { // starknet::syscalls::library_call_syscall  is called in here
    }
    fn transfer(
        self: IERC20LibraryDispatcher, recipient: ContractAddress, amount: u256,
    ) { // starknet::syscalls::library_call_syscall  is called in here
    }
}
</code></pre>
<p>{{#label expanded-ierc20-library}} <span class="caption">清单 {{#ref expanded-ierc20-library}}: <code>IERC20LibraryDispatcher</code> 及其关联 trait 和 impl 的简化示例</span></p>
<p>与合约分发器的一个显著区别是，库分发器使用 <code>library_call_syscall</code> 而不是 <code>call_contract_syscall</code>。否则，过程是相似的。</p>
<p>让我们看看如何使用库调用在当前合约的上下文中执行另一个类的逻辑。</p>
<h2 id="使用库分发器"><a class="header" href="#使用库分发器">使用库分发器</a></h2>
<p>清单 {{#ref library-dispatcher}} 定义了两个合约：<code>ValueStoreLogic</code>，它定义了我们示例的逻辑，以及 <code>ValueStoreExecutor</code>，它只是执行 <code>ValueStoreLogic</code> 类的逻辑。</p>
<p>我们首先需要导入 <code>IValueStoreDispatcherTrait</code> 和 <code>IValueStoreLibraryDispatcher</code>，它们是由编译器从我们的接口生成的。然后，我们可以创建一个 <code>IValueStoreLibraryDispatcher</code> 的实例，传入我们想要进行库调用的类的 <code>class_hash</code>。从那里，我们可以调用在该类中定义的函数，在我们的合约上下文中执行其逻辑。</p>
<pre><code class="language-cairo noplayground">#[starknet::interface]
trait IValueStore&lt;TContractState&gt; {
    fn set_value(ref self: TContractState, value: u128);
    fn get_value(self: @TContractState) -&gt; u128;
}

#[starknet::contract]
mod ValueStoreLogic {
    use starknet::ContractAddress;
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};

    #[storage]
    struct Storage {
        value: u128,
    }

    #[abi(embed_v0)]
    impl ValueStore of super::IValueStore&lt;ContractState&gt; {
        fn set_value(ref self: ContractState, value: u128) {
            self.value.write(value);
        }

        fn get_value(self: @ContractState) -&gt; u128 {
            self.value.read()
        }
    }
}

#[starknet::contract]
mod ValueStoreExecutor {
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
    use starknet::{ClassHash, ContractAddress};
    use super::{IValueStoreDispatcherTrait, IValueStoreLibraryDispatcher};

    #[storage]
    struct Storage {
        logic_library: ClassHash,
        value: u128,
    }

    #[constructor]
    fn constructor(ref self: ContractState, logic_library: ClassHash) {
        self.logic_library.write(logic_library);
    }

    #[abi(embed_v0)]
    impl ValueStoreExecutor of super::IValueStore&lt;ContractState&gt; {
        fn set_value(ref self: ContractState, value: u128) {
            IValueStoreLibraryDispatcher { class_hash: self.logic_library.read() }
                .set_value((value));
        }

        fn get_value(self: @ContractState) -&gt; u128 {
            IValueStoreLibraryDispatcher { class_hash: self.logic_library.read() }.get_value()
        }
    }

    #[external(v0)]
    fn get_value_local(self: @ContractState) -&gt; u128 {
        self.value.read()
    }
}
</code></pre>
<p>{{#label library-dispatcher}} <span class="caption">清单 {{#ref library-dispatcher}}: 使用库分发器的示例合约</span></p>
<p>当我们调用 <code>ValueStoreExecutor</code> 上的 <code>set_value</code> 函数时，它将对 <code>ValueStoreLogic</code> 中定义的 <code>set_value</code> 函数进行库调用。因为我们使用的是库调用，<code>ValueStoreExecutor</code> 的存储变量 <code>value</code> 将被更新。同样，当我们调用 <code>get_value</code> 函数时，它将对 <code>ValueStoreLogic</code> 中定义的 <code>get_value</code> 函数进行库调用，返回存储变量 <code>value</code> 的值 —— 仍然是在 <code>ValueStoreExecutor</code> 的上下文中。</p>
<p>因此，<code>get_value</code> 和 <code>get_value_local</code> 都返回相同的值，因为它们读取相同的存储槽。</p>
<h2 id="使用低级调用调用类"><a class="header" href="#使用低级调用调用类">使用低级调用调用类</a></h2>
<p>调用类的另一种方法是直接使用 <code>library_call_syscall</code>。虽然不如使用分发器模式方便，但此系统调用提供了对序列化和反序列化过程的更多控制，并允许更自定义的错误处理。</p>
<p>清单 {{#ref library_syscall}} 显示了一个示例，演示如何使用 <code>library_call_syscall</code> 调用 <code>ValueStore</code> 合约的 <code>set_value</code> 函数：</p>
<pre><code class="language-cairo noplayground">#[starknet::contract]
mod ValueStore {
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
    use starknet::{ClassHash, SyscallResultTrait, syscalls};

    #[storage]
    struct Storage {
        logic_library: ClassHash,
        value: u128,
    }

    #[constructor]
    fn constructor(ref self: ContractState, logic_library: ClassHash) {
        self.logic_library.write(logic_library);
    }

    #[external(v0)]
    fn set_value(ref self: ContractState, value: u128) -&gt; bool {
        let mut call_data: Array&lt;felt252&gt; = array![];
        Serde::serialize(@value, ref call_data);

        let mut res = syscalls::library_call_syscall(
            self.logic_library.read(), selector!("set_value"), call_data.span(),
        )
            .unwrap_syscall();

        Serde::&lt;bool&gt;::deserialize(ref res).unwrap()
    }

    #[external(v0)]
    fn get_value(self: @ContractState) -&gt; u128 {
        self.value.read()
    }
}
</code></pre>
<p>{{#label library_syscall}} <span class="caption">清单 {{#ref library_syscall}}: 使用 <code>library_call_syscall</code> 系统调用的示例合约</span></p>
<p>要使用此系统调用，我们传入类哈希、我们想要调用的函数的选择器和调用参数。调用参数必须作为参数数组提供，序列化为 <code>Span&lt;felt252&gt;</code>。要序列化参数，我们可以简单地使用 <code>Serde</code> trait，前提是要序列化的类型实现了此 trait。调用返回一个序列化值的数组，我们需要自己反序列化！</p>
<h2 id="总结-13"><a class="header" href="#总结-13">总结</a></h2>
<p>祝贺你完成本章！你已经学到了很多新概念：</p>
<ul>
<li><em>合约</em> 与 <em>类</em> 有何不同，以及 ABI 如何为外部源描述它们</li>
<li>如何使用 <em>分发器</em> 模式调用其他合约和类中的函数</li>
<li>如何使用 <em>库调用</em> 在调用者的上下文中执行另一个类的逻辑</li>
<li>Starknet 提供的用于与合约和类交互的两个系统调用</li>
</ul>
<p>你现在拥有开发跨多个合约和类分布逻辑的复杂应用程序所需的所有工具。在下一章中，我们将探索更高级的主题，这将帮助你释放 Starknet 的全部潜力。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cairo-类型的序列化"><a class="header" href="#cairo-类型的序列化">Cairo 类型的序列化</a></h1>
<p>字段元素 (<code>felt252</code>) 包含 252 位，是 Cairo 虚拟机中唯一的实际类型，因此 <a href="#data-types-using-at-most-252-bits">所有适合 252 位的数据类型</a> 都由单个 felt 表示，而 <a href="#data-types-using-more-than-252-bits">所有大于 252 位的数据类型</a> 都由 felt 列表表示。因此，为了与合约交互，你必须知道如何 <a href="#serialization-of-data-types-using-more-than-252-bits">将任何大于 252 位的参数序列化为 felt 列表</a> ，以便你可以正确地制定交易中的调用数据 (calldata)。</p>
<blockquote>
<p>注意：对于任何不开发 Starknet 库或 SDK 的开发人员，强烈建议使用现有的 <a href="https://docs.starknet.io/tools/overview/">Starknet SDKs</a> 之一或使用 <a href="https://foundry-rs.github.io/starknet-foundry/starknet/calldata-transformation.html#using---arguments">Starknet Foundry 的 <code>sncast</code> 的 <code>--argument</code> 标志</a> 来极大地简化序列化过程。从 <code>sncast</code> v0.43.0 开始，<code>sncast call</code> 的结果也被解析为可读信息，如下例所示：</p>
<pre><code>sncast call \
  --contract-address=0x00e270c8396d333f88556edf143ac751240f050d907e5190525accbe275f2348 \
  --function=get_order \
  --network=sepolia
response: Order {
  position_id: PositionId { value: 1_u32 },
  base_asset_id: AssetId { value: 0x3 },
  base_amount: -10_i64,
  quote_asset_id: AssetId { value: 0x2d },
  fee_asset_id: AssetId { value: 0x4d2 },
  fee_amount: 0_u64,
  expiration: Timestamp { seconds: 12341432_u64 },
  salt: 0x0,
  name: "This is my order"
}
</code></pre>
</blockquote>
<h2 id="使用最多-252-位的数据类型"><a class="header" href="#使用最多-252-位的数据类型">使用最多 252 位的数据类型</a></h2>
<p>以下 Cairo 数据类型使用最多 252 位：</p>
<ul>
<li><code>ContractAddress</code></li>
<li><code>EthAddress</code></li>
<li><code>StorageAddress</code></li>
<li><code>ClassHash</code></li>
<li>使用最多 252 位的无符号整数：<code>u8</code>、<code>u16</code>、<code>u32</code>、<code>u64</code>、<code>u128</code> 和 <code>usize</code></li>
<li><code>bytes31</code></li>
<li><code>felt252</code></li>
<li>有符号整数：<code>i8</code>、<code>i16</code>、<code>i32</code>、<code>i64</code> 和 <code>i128</code>
<blockquote>
<p>注意：负值 \( -x \) 序列化为 \( P-x \)，其中 \( P = 2^{251} + 17*2^{192} + 1 \)</p>
</blockquote>
</li>
</ul>
<p>对于这些类型，每个值都序列化为包含一个 <code>felt252</code> 值的单成员列表。</p>
<h2 id="使用超过-252-位的数据类型"><a class="header" href="#使用超过-252-位的数据类型">使用超过 252 位的数据类型</a></h2>
<p>以下 Cairo 数据类型使用超过 252 位，因此具有非平凡的序列化：</p>
<ul>
<li>大于 252 位的无符号整数：<code>u256</code> 和 <code>u512</code></li>
<li>数组和 Span</li>
<li>枚举</li>
<li>结构体和元组</li>
<li>字节数组（表示字符串）</li>
</ul>
<h2 id="使用超过-252-位的数据类型的序列化"><a class="header" href="#使用超过-252-位的数据类型的序列化">使用超过 252 位的数据类型的序列化</a></h2>
<h3 id="u256-的序列化"><a class="header" href="#u256-的序列化"><code>u256</code> 的序列化</a></h3>
<p>Cairo 中的 <code>u256</code> 值由两个 <code>felt252</code> 值表示，如下所示：</p>
<ul>
<li>第一个 <code>felt252</code> 值包含 128 个最低有效位，通常称为原始 <code>u256</code> 值的低部分。</li>
<li>第二个 <code>felt252</code> 值包含 128 个最高有效位，通常称为原始 <code>u256</code> 值的高部分。</li>
</ul>
<p>例如：</p>
<ul>
<li>
<p>十进制值为 2 的 <code>u256</code> 变量序列化为 <code>[2,0]</code>。要理解原因，请检查 2 的二进制表示并将其分成两个 128 位部分，如下所示：</p>
<ul>
<li>128 个高位：\(0 \cdots 0 \)</li>
<li>128 个低位：\( 0 \cdots 10 \)</li>
</ul>
</li>
<li>
<p>十进制值为 \( 2^{128} \) 的 <code>u256</code> 变量序列化为 <code>[0,1]</code>。要理解原因，请检查 \( 2^{128} \) 的二进制表示并将其分成两个 128 位部分，如下所示：</p>
<ul>
<li>128 个高位：\( 0 \cdots 01 \)</li>
<li>128 个低位：\(0 \cdots 0 \)</li>
</ul>
</li>
<li>
<p>十进制值为 \( 2^{129}+2^{128}+20 \) 的 <code>u256</code> 变量序列化为 <code>[20,3]</code>。要理解原因，请检查 \( 2^{129}+2^{128}+20 \) 的二进制表示并将其分成两个 128 位部分，如下所示：</p>
<ul>
<li>128 个高位：\( 0 \cdots 011 \)</li>
<li>128 个低位：\( 0 \cdots 10100 \)</li>
</ul>
</li>
</ul>
<h3 id="u512-的序列化"><a class="header" href="#u512-的序列化"><code>u512</code> 的序列化</a></h3>
<p>Cairo 中的 <code>u512</code> 类型是一个包含四个 <code>felt252</code> 成员的结构体，每个成员代表原始整数的一个 128 位肢体 (limb)，类似于 <code>u256</code> 类型。</p>
<h3 id="数组和-span-的序列化"><a class="header" href="#数组和-span-的序列化">数组和 Span 的序列化</a></h3>
<p>数组和 Span 序列化如下：</p>
<p><code>&lt;array/span_length&gt;, &lt;first_serialized_member&gt;,..., &lt;last_serialized_member&gt;</code></p>
<p>例如，考虑以下 <code>u256</code> 值数组：</p>
<pre><code class="language-cairo noplayground">let POW_2_128: u256 = 0x100000000000000000000000000000000
let array: Array&lt;u256&gt; = array![10, 20, POW_2_128]
</code></pre>
<p>数组中的每个 <code>u256</code> 值由两个 <code>felt252</code> 值表示。所以上面的数组序列化如下：</p>
<ol>
<li><code>3</code>: 数组乘员数</li>
<li><code>10,0</code>: 序列化的第一个成员</li>
<li><code>20,0</code>: 序列化的第二个成员</li>
<li><code>0,1</code>: 序列化的第三个成员</li>
</ol>
<p>结合以上内容，数组被序列化为 <code>[3,10,0,20,0,0,1]</code>。</p>
<h3 id="枚举的序列化"><a class="header" href="#枚举的序列化">枚举的序列化</a></h3>
<p>枚举序列化如下：</p>
<p><code>&lt;index_of_enum_variant&gt;,&lt;serialized_variant&gt;</code></p>
<p>注意，枚举变体索引是基于 0 的，不要与其基于 1 的存储布局混淆，后者是为了区分第一个变体和未初始化的存储槽。</p>
<p><strong>枚举序列化示例 #1</strong></p>
<p>考虑以下名为 <code>Week</code> 的枚举定义：</p>
<pre><code class="language-cairo noplayground">enum Week {
    Sunday: (), // Index=0. 变体类型是单元类型 (0-tuple)。
    Monday: u256, // Index=1. 变体类型是 u256。
}
</code></pre>
<p>现在考虑如下表所示的 <code>Week</code> 枚举变体的实例化：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>实例</th><th>索引</th><th>类型</th><th>序列化</th></tr>
</thead>
<tbody>
<tr><td><code>Week::Sunday</code></td><td><code>0</code></td><td>unit</td><td><code>[0]</code></td></tr>
<tr><td><code>Week::Monday(5)</code></td><td><code>1</code></td><td><code>u256</code></td><td><code>[1,5,0]</code></td></tr>
</tbody>
</table>
</div>
<p><strong>枚举序列化示例 #2</strong></p>
<p>考虑以下名为 <code>MessageType</code> 的枚举定义：</p>
<pre><code class="language-cairo noplayground">enum MessageType {
    A,
    #[default]
    B: u128,
    C
}
</code></pre>
<p>现在考虑如下表所示的 <code>MessageType</code> 枚举变体的实例化：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>实例</th><th>索引</th><th>类型</th><th>序列化</th></tr>
</thead>
<tbody>
<tr><td><code>MessageType::A</code></td><td><code>1</code></td><td>unit</td><td><code>[0]</code></td></tr>
<tr><td><code>MessageType::B(6)</code></td><td><code>0</code></td><td><code>u128</code></td><td><code>[1,6]</code></td></tr>
<tr><td><code>MessageType::C</code></td><td><code>2</code></td><td>unit</td><td><code>[2]</code></td></tr>
</tbody>
</table>
</div>
<p>如你所见，<code>#[default]</code> 属性不影响序列化。它只影响 <code>MessageType</code> 的存储布局，其中默认变体 <code>B</code> 将存储为 <code>0</code>。</p>
<h3 id="结构体和元组的序列化"><a class="header" href="#结构体和元组的序列化">结构体和元组的序列化</a></h3>
<p>结构体和元组通过一次序列化其一个成员来序列化。</p>
<p>结构体的成员按其定义中出现的顺序序列化。</p>
<p>例如，考虑以下结构体 <code>MyStruct</code> 的定义：</p>
<pre><code class="language-cairo noplayground">struct MyStruct {
    a: u256,
    b: felt252,
    c: Array&lt;felt252&gt;
}
</code></pre>
<p>对于以下两个结构体成员的实例化，序列化是相同的：</p>
<pre><code class="language-cairo noplayground">let my_struct = MyStruct {
    a: 2, b: 5, c: [1,2,3]
};

let my_struct = MyStruct {
    b: 5, c: [1,2,3], a: 2
};
</code></pre>
<p><code>MyStruct</code> 的序列化如下表所示：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>成员</th><th>类型</th><th>序列化</th><th></th></tr>
</thead>
<tbody>
<tr><td><code>a: 2</code></td><td><code>u256</code></td><td><code>[2,0]</code></td><td>有关序列化 <code>u256</code> 值的更多信息请参见上文</td></tr>
<tr><td><code>b: 5</code></td><td><code>felt252</code></td><td><code>5</code></td><td></td></tr>
<tr><td><code>c: [1,2,3]</code></td><td>大小为 3 的 <code>felt252</code> 数组</td><td><code>[3,1,2,3]</code></td><td></td></tr>
</tbody>
</table>
</div>
<p>结合以上内容，结构体被序列化为 <code>[2,0,5,3,1,2,3]</code>。</p>
<h3 id="字节数组的序列化"><a class="header" href="#字节数组的序列化">字节数组的序列化</a></h3>
<p>字符串在 Cairo 中表示为 <code>ByteArray</code> 类型。字节数组实际上是一个具有以下成员的结构体：</p>
<ul>
<li><code>data: Array&lt;felt252&gt;</code>: 包含字节数组的 31 字节块。每个 <code>felt252</code> 值正好有 31 个字节。如果字节数组中的字节数少于 31，则此数组为空。</li>
<li><code>pending_word: felt252</code>: 用完整的 31 字节块填充 <code>data</code> 数组后剩余的字节。挂起字最多包含 30 个字节。</li>
<li><code>pending_word_len: usize</code>: <code>pending_word</code> 中的字节数。</li>
</ul>
<p><strong>示例 #1: 短于 31 个字符的字符串</strong></p>
<p>考虑字符串 <code>hello</code>，其 ASCII 编码为 5 字节十六进制值 <code>0x68656c6c6f</code>。生成的字节数组序列化如下：</p>
<pre><code class="language-cairo noplayground">0, // data 数组中 31 字节字的梳理。
0x68656c6c6f, // 挂起字 (Pending word)
5 // 挂起字的长度，以字节为单位
</code></pre>
<p><strong>示例 2: 长于 31 个字节的字符串</strong></p>
<p>考虑字符串 <code>Long string, more than 31 characters.</code>，它由以下十六进制值表示：</p>
<ul>
<li><code>0x4c6f6e6720737472696e672c206d6f7265207468616e203331206368617261</code> (31 字节字)</li>
<li><code>0x63746572732e</code> (6 字节挂起字)</li>
</ul>
<p>生成的字节数组序列化如下：</p>
<pre><code class="language-cairo noplayground">1, // 数组构造中 31 字节字的数量。
0x4c6f6e6720737472696e672c206d6f7265207468616e203331206368617261, // 31 字节字。
0x63746572732e, // 挂起字
6 // 挂起字的长度，以字节为单位
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="构建高级-starknet-智能合约"><a class="header" href="#构建高级-starknet-智能合约">构建高级 Starknet 智能合约</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="优化存储成本"><a class="header" href="#优化存储成本">优化存储成本</a></h1>
<p>位打包 (Bit-packing) 是一个简单的概念：使用尽可能少的位来存储一条数据。如果做得好，它可以显着减少你需要存储的数据的大小。这在智能合约中尤其重要，因为存储非常昂贵。</p>
<p>在编写 Cairo 智能合约时，优化存储使用以降低 gas 成本非常重要。实际上，与交易相关的大部分成本都与存储更新有关；并且每个存储槽的写入都要花费 gas。这意味着通过将多个值打包到更少的槽中，你可以减少智能合约用户产生的 gas 成本。</p>
<h2 id="整数结构和位运算符"><a class="header" href="#整数结构和位运算符">整数结构和位运算符</a></h2>
<p>整数是在一定数量的位上编码的，具体取决于其大小（例如，<code>u8</code> 整数是在 8 位上编码的）。</p>
<div align="center">
    <img src="integer_in_bits.png" alt="a u8 integer in bits" width="500px" />
<div align="center">
</div>

    <span class="caption">u8 整数在位中的表示</span>
</div>

<p>直观地说，如果单个整数的大小大于或等于整数大小的总和（例如，一个 <code>u32</code> 中的两个 <code>u8</code> 和一个 <code>u16</code>），则可以将多个整数合并为一个整数。</p>
<p>但是，要做到这一点，我们需要一些位运算符：</p>
<ul>
<li>乘以或除以 2 的幂分别将整数值向左或向右移动</li>
</ul>
<div align="center">
    <img src="shift.png" alt="shift operators" width="500px" />
<div align="center">
</div>

    <span class="caption">向左或向右移动整数值</span>
</div>

<ul>
<li>对整数值应用掩码（<code>AND</code> 运算符）会隔离此整数的某些位</li>
</ul>
<div align="center">
    <img src="mask.png" alt="applying a mask" width="500px" />
<div align="center">
</div>

    <span class="caption">用掩码隔离位</span>
</div>

<ul>
<li>相加（<code>OR</code> 运算符）两个整数将把两个值合并为一个。</li>
</ul>
<div align="center">
    <img src="combine.png" alt="combining two values" width="500px" />
<div align="center">
</div>

    <span class="caption">合并两个整数</span>
</div>

<p>有了这些位运算符，让我们在以下示例中看看如何将两个 <code>u8</code> 整数合并为一个 <code>u16</code> 整数（称为 <code>packing</code>，打包）以及反向操作（称为 <code>unpacking</code>，解包）：</p>
<div align="center">
    <img src="pack.png" alt="packing and unpacking integer values" width="500px" />
<div align="center">
</div>

    <span class="caption">打包和解包整数值</span>
</div>

<h2 id="cairo-中的位打包"><a class="header" href="#cairo-中的位打包">Cairo 中的位打包</a></h2>
<p>Starknet 智能合约的存储是一个具有 2<sup>251</sup> 个槽位的映射 (map)，其中每个槽位是一个初始化为 0 的 <code>felt252</code>。</p>
<p>正如我们之前所看到的，为了减少由于存储更新引起的 gas 成本，我们必须使用尽可能少的位，因此我们必须通过打包它们来组织存储的变量。</p>
<p>例如，考虑以下具有 3 个不同类型字段的 <code>Sizes</code> 结构体：一个 <code>u8</code>，一个 <code>u32</code> 和一个 <code>u64</code>。总大小为 8 + 32 + 64 = 104 位。这小于一个槽位大小（即 251 位），因此我们可以将它们打包在一起存储到一个槽位中。</p>
<p>注意，因为它也适合 <code>u128</code>，所以使用最小的类型来打包所有变量是一个好习惯，因此这里应该使用 <code>u128</code>。</p>
<pre><code class="language-cairo noplayground">struct Sizes {
    tiny: u8,
    small: u32,
    medium: u64,
}
</code></pre>
<p>要将这 3 个变量打包到一个 <code>u128</code> 中，我们需要依次向左移动它们，最后将它们相加。</p>
<div align="center">
    <img src="sizes-packing.png" alt="Sizes packing" width="800px" />
<div align="center">
</div>

    <span class="caption">Sizes 打包</span>
</div>

<p>要从 <code>u128</code> 中解包这 3 个变量，我们需要依次向右移动它们并使用掩码来隔离它们。</p>
<div align="center">
    <img src="sizes-unpacking.png" alt="Sizes unpacking" width="800px" />
<div align="center">
</div>

    <span class="caption">Sizes 解包</span>
</div>

<h2 id="storepacking-trait"><a class="header" href="#storepacking-trait"><code>StorePacking</code> Trait</a></h2>
<p>Cairo 提供了 <code>StorePacking</code> trait 来支持将结构体字段打包到更少的存储槽中。<code>StorePacking&lt;T, PackedT&gt;</code> 是一个泛型 trait，它将你要打包的类型 (<code>T</code>) 和目标类型 (<code>PackedT</code>) 作为参数。它提供了两个要实现的函数：<code>pack</code> 和 <code>unpack</code>。</p>
<p>这是上一章示例的实现：</p>
<pre><code class="language-cairo noplayground">use starknet::storage_access::StorePacking;

#[derive(Drop, Serde)]
//ANCHOR:struct
struct Sizes {
    tiny: u8,
    small: u32,
    medium: u64,
}
//ANCHOR_END:struct

const TWO_POW_8: u128 = 0x100;
const TWO_POW_40: u128 = 0x10000000000;

const MASK_8: u128 = 0xff;
const MASK_32: u128 = 0xffffffff;

impl SizesStorePacking of StorePacking&lt;Sizes, u128&gt; {
    fn pack(value: Sizes) -&gt; u128 {
        value.tiny.into() + (value.small.into() * TWO_POW_8) + (value.medium.into() * TWO_POW_40)
    }

    fn unpack(value: u128) -&gt; Sizes {
        let tiny = value &amp; MASK_8;
        let small = (value / TWO_POW_8) &amp; MASK_32;
        let medium = (value / TWO_POW_40);

        Sizes {
            tiny: tiny.try_into().unwrap(),
            small: small.try_into().unwrap(),
            medium: medium.try_into().unwrap(),
        }
    }
}

#[starknet::contract]
mod SizeFactory {
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
    use super::Sizes;
    use super::SizesStorePacking; //don't forget to import it!

    #[storage]
    struct Storage {
        remaining_sizes: Sizes,
    }

    #[abi(embed_v0)]
    fn update_sizes(ref self: ContractState, sizes: Sizes) {
        // This will automatically pack the
        // struct into a single u128
        self.remaining_sizes.write(sizes);
    }


    #[abi(embed_v0)]
    fn get_sizes(ref self: ContractState) -&gt; Sizes {
        // this will automatically unpack the
        // packed-representation into the Sizes struct
        self.remaining_sizes.read()
    }
}
</code></pre>
<div align="center">
    <span class="caption">通过实现 `StorePacking` trait 优化存储。</span>
</div>

<p>在这个代码片段中，你可以看到：</p>
<ul>
<li><code>TWO_POW_8</code> 和 <code>TWO_POW_40</code> 用在 <code>pack</code> 函数中左移，和在 <code>unpack</code> 函数中右移，</li>
<li><code>MASK_8</code> 和 <code>MASK_32</code> 用在 <code>unpack</code> 函数中隔离变量，</li>
<li>所有来自存储的变量都转换为 <code>u128</code> 以便能够使用位运算符。</li>
</ul>
<p>此技术可用于适合打包存储类型位大小的任何字段组。例如，如果你有一个包含多个字段的结构体，其位大小加起来为 256 位，你可以将它们打包到一个 <code>u256</code> 变量中。如果位大小加起来为 512 位，你可以将它们打包到一个 <code>u512</code> 变量中，依此类推。你可以定义自己的结构体和逻辑来打包和解包它们。</p>
<p>剩下的工作由编译器神奇地完成 —— 如果一个类型实现了 <code>StorePacking</code> trait，那么编译器就会知道它可以使用 <code>Store</code> trait 的 <code>StoreUsingPacking</code> 实现，以便在写入前打包和从存储读取后解包。然而，一个重要的细节是，<code>StorePacking::pack</code> 输出的类型也必须实现 <code>Store</code> 以便 <code>StoreUsingPacking</code> 工作。大多数时候，我们会想要打包成 <code>felt252</code> 或 <code>u256</code> —— 但如果你想打包成你自己的类型，请确保这一个实现了 <code>Store</code> trait。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="组件-components智能合约的乐高积木"><a class="header" href="#组件-components智能合约的乐高积木">组件 (Components)：智能合约的乐高积木</a></h1>
<p>开发共享通用逻辑和存储的合约可能会很痛苦且容易出错，因为这些逻辑很难重用，并且需要在每个合约中重新实现。但是，如果有办法只将你需要的额外功能插入到你的合约中，将你合约的核心逻辑与其余部分分开呢？</p>
<p>组件正是提供了这一点。它们是封装了可重用的逻辑、存储和事件的模块化附加组件，可以合并到多个合约中。它们可用于扩展合约的功能，而不必一遍又一遍地重新实现相同的逻辑。</p>
<p>将组件视为乐高积木。它们允许你通过插入你或其他人编写的模块来丰富你的合约。这个模块可以是一个简单的模块，比如所有权组件，也可以是更复杂的模块，比如一个完整的 ERC20 代币。</p>
<p>组件是一个单独的模块，可以包含存储、事件和函数。与合约不同，组件不能被声明或部署。它的逻辑最终将成为嵌入它的合约字节码的一部分。</p>
<h2 id="组件里有什么"><a class="header" href="#组件里有什么">组件里有什么？</a></h2>
<p>组件非常类似于合约。它可以包含：</p>
<ul>
<li>存储变量</li>
<li>事件</li>
<li>外部和内部函数</li>
</ul>
<p>与合约不同，组件不能单独部署。组件的代码成为它嵌入的合约的一部分。</p>
<h2 id="创建组件"><a class="header" href="#创建组件">创建组件</a></h2>
<p>要创建组件，首先在用 <code>#[starknet::component]</code> 属性装饰的自己的模块中定义它。在这个模块中，你可以声明 <code>Storage</code> 结构体和 <code>Event</code> 枚举，就像通常在 <a href="#">合约</a> 中所做的那样。</p>
<p>下一步是定义组件接口，包含允许外部访问组件逻辑的函数签名。你可以通过声明带有 <code>#[starknet::interface]</code> 属性的 Trait 来定义组件的接口，就像对合约所做的那样。此接口将用于使用 <a href="#与另一个合约交互">分发器</a> 模式启用对组件函数的外部访问。</p>
<p>组件外部逻辑的实际实现是在标记为 <code>#[embeddable_as(name)]</code> 的 <code>impl</code> 块中完成的。通常，这个 <code>impl</code> 块将是定义组件接口的 trait 的实现。</p>
<blockquote>
<p>注意：<code>name</code> 是我们在合约中用来引用组件的名称。它不同于你的 impl 的名称。</p>
</blockquote>
<p>你也可以定义不能从外部访问的内部函数，只需省略内部 <code>impl</code> 块上方的 <code>#[embeddable_as(name)]</code> 属性。你将能够在嵌入组件的合约内部使用这些内部函数，但不能从外部与它交互，因为它们不是合约 ABI 的一部分。</p>
<p>这些 <code>impl</code> 块中的函数期望像 <code>ref self: ComponentState&lt;TContractState&gt;</code>（对于状态修改函数）或 <code>self: @ComponentState&lt;TContractState&gt;</code>（对于视图函数）这样的参数。这使得 impl 对 <code>TContractState</code> 是通用的，允许我们在任何合约中使用此组件。</p>
<h3 id="示例一个-ownable-组件"><a class="header" href="#示例一个-ownable-组件">示例：一个 Ownable 组件</a></h3>
<blockquote>
<p>⚠️ 下面显示的示例未经审计，不适用于生产用途。作者不对使用此代码造成的任何损害负责。</p>
</blockquote>
<p>Ownable 组件的接口，定义了用于管理合约所有权的外部可用方法，如下所示：</p>
<pre><code class="language-cairo noplayground">#[starknet::interface]
trait IOwnable&lt;TContractState&gt; {
    //ANCHOR: trait_def
    fn owner(self: @TContractState) -&gt; ContractAddress;
    fn transfer_ownership(ref self: TContractState, new_owner: ContractAddress);
    fn renounce_ownership(ref self: TContractState);
    //ANCHOR_END: trait_def
}
</code></pre>
<p>组件本身定义为：</p>
<pre><code class="language-cairo noplayground">#[starknet::component]
pub mod OwnableComponent {
    use core::num::traits::Zero;
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
    use starknet::{ContractAddress, get_caller_address};
    use super::Errors;

    #[storage]
    pub struct Storage {
        owner: ContractAddress,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    pub enum Event {
        OwnershipTransferred: OwnershipTransferred,
    }

    #[derive(Drop, starknet::Event)]
    struct OwnershipTransferred {
        previous_owner: ContractAddress,
        new_owner: ContractAddress,
    }

    //ANCHOR: impl_signature
    #[embeddable_as(OwnableImpl)]
    impl Ownable&lt;
        TContractState, +HasComponent&lt;TContractState&gt;,
    &gt; of super::IOwnable&lt;ComponentState&lt;TContractState&gt;&gt; {
        //ANCHOR_END: impl_signature
        fn owner(self: @ComponentState&lt;TContractState&gt;) -&gt; ContractAddress {
            self.owner.read()
        }

        fn transfer_ownership(
            ref self: ComponentState&lt;TContractState&gt;, new_owner: ContractAddress,
        ) {
            assert(!new_owner.is_zero(), Errors::ZERO_ADDRESS_OWNER);
            self.assert_only_owner();
            self._transfer_ownership(new_owner);
        }

        fn renounce_ownership(ref self: ComponentState&lt;TContractState&gt;) {
            self.assert_only_owner();
            self._transfer_ownership(Zero::zero());
        }
    }

    #[generate_trait]
    pub impl InternalImpl&lt;
        TContractState, +HasComponent&lt;TContractState&gt;,
    &gt; of InternalTrait&lt;TContractState&gt; {
        fn initializer(ref self: ComponentState&lt;TContractState&gt;, owner: ContractAddress) {
            self._transfer_ownership(owner);
        }

        fn assert_only_owner(self: @ComponentState&lt;TContractState&gt;) {
            let owner: ContractAddress = self.owner.read();
            let caller: ContractAddress = get_caller_address();
            assert(!caller.is_zero(), Errors::ZERO_ADDRESS_CALLER);
            assert(caller == owner, Errors::NOT_OWNER);
        }

        fn _transfer_ownership(
            ref self: ComponentState&lt;TContractState&gt;, new_owner: ContractAddress,
        ) {
            let previous_owner: ContractAddress = self.owner.read();
            self.owner.write(new_owner);
            self
                .emit(
                    OwnershipTransferred { previous_owner: previous_owner, new_owner: new_owner },
                );
        }
    }
}
</code></pre>
<p>这种语法实际上与用于合约的语法非常相似。唯一的区别在于 impl 上方的 <code>#[embeddable_as]</code> 属性以及我们将详细剖析的 impl 块的泛型性。</p>
<p>如你所见，我们的组件有两个 <code>impl</code> 块：一个对应于接口 trait 的实现，另一个包含不应在外部公开且仅供内部使用的方法。作为接口的一部分公开 <code>assert_only_owner</code> 是没有意义的，因为它只意味着由嵌入组件的合约在内部使用。</p>
<h2 id="仔细看看-impl-块"><a class="header" href="#仔细看看-impl-块">仔细看看 <code>impl</code> 块</a></h2>
<pre><code class="language-cairo noplayground">    #[embeddable_as(OwnableImpl)]
    impl Ownable&lt;
        TContractState, +HasComponent&lt;TContractState&gt;,
    &gt; of super::IOwnable&lt;ComponentState&lt;TContractState&gt;&gt; {
</code></pre>
<p><code>#[embeddable_as]</code> 属性用于将 impl 标记为可嵌入合约内部。它允许我们指定在合约中用于引用此组件的 impl 的名称。在这种情况下，组件将在嵌入它的合约中被称为 <code>OwnableImpl</code>。</p>
<p>实现本身对 <code>ComponentState&lt;TContractState&gt;</code> 是通用的，并增加了 <code>TContractState</code> 必须实现 <code>HasComponent&lt;T&gt;</code> trait 的限制。这允许我们在任何合约中使用该组件，只要该合约实现了 <code>HasComponent</code> trait。使用组件不需要详细了解此机制，但如果你对内部工作原理感到好奇，可以在 <a href="#组件底层原理">“组件底层原理”</a> 部分阅读更多内容。</p>
<p>与常规智能合约的主要区别之一是，对存储和事件的访问是通过泛型 <code>ComponentState&lt;TContractState&gt;</code> 类型而不是 <code>ContractState</code> 完成的。注意，虽然类型不同，但访问存储或发出事件的方式类似，都是通过 <code>self.storage_var_name.read()</code> 或 <code>self.emit(...)</code>。</p>
<blockquote>
<p>注意：为避免混淆，请遵循 OpenZeppelin 的模式：在可嵌入名称和合约的 impl 别名中保留 <code>Impl</code> 后缀（例如，<code>OwnableImpl</code>），而本地组件 impl 以 trait 命名，不带后缀（例如，<code>impl Ownable&lt;...&gt;</code>）。</p>
</blockquote>
<h2 id="将合约迁移到组件"><a class="header" href="#将合约迁移到组件">将合约迁移到组件</a></h2>
<p>由于合约和组件都有很多相似之处，因此从合约迁移到组件实际上非常容易。唯一需要的更改是：</p>
<ul>
<li>向模块添加 <code>#[starknet::component]</code> 属性。</li>
<li>向将嵌入另一个合约的 <code>impl</code> 块添加 <code>#[embeddable_as(name)]</code> 属性。</li>
<li>向 <code>impl</code> 块添加泛型参数：
<ul>
<li>添加 <code>TContractState</code> 作为泛型参数。</li>
<li>添加 <code>+HasComponent&lt;TContractState&gt;</code> 作为 impl 限制。</li>
</ul>
</li>
<li>将 <code>impl</code> 块内部函数中的 <code>self</code> 参数的类型更改为 <code>ComponentState&lt;TContractState&gt;</code> 而不是 <code>ContractState</code>。</li>
</ul>
<p>对于没有显式定义并使用 <code>#[generate_trait]</code> 生成的 trait，逻辑是相同的 —— 但 trait 对 <code>TContractState</code> 是通用的，而不是 <code>ComponentState&lt;TContractState&gt;</code>，如 <code>InternalTrait</code> 的示例所示。</p>
<h2 id="在合约内部使用组件"><a class="header" href="#在合约内部使用组件">在合约内部使用组件</a></h2>
<p>组件的主要优势在于它允许在你的合约中重用已构建的原语，且样板代码量受到限制。要将组件集成到你的合约中，你需要：</p>
<ol>
<li>
<p>使用 <code>component!()</code> 宏声明它，指定</p>
<ol>
<li>组件的路径 <code>path::to::component</code>。</li>
<li>你的合约存储中引用此组件存储的变量名称（例如 <code>ownable</code>）。</li>
<li>你的合约事件枚举中引用此组件事件的变体名称（例如 <code>OwnableEvent</code>）。</li>
</ol>
</li>
<li>
<p>将组件的存储和事件的路径添加到合约的 <code>Storage</code> 和 <code>Event</code>。它们必须匹配步骤 1 中提供的名称（例如 <code>ownable: ownable_component::Storage</code> 和 <code>OwnableEvent: ownable_component::Event</code>）。</p>
<p>存储变量 <strong>必须</strong> 用 <code>#[substorage(v0)]</code> 属性注释。</p>
</li>
<li>
<p>嵌入定义在你的合约内的组件逻辑，通过使用 impl 别名用具体的 <code>ContractState</code> 实例化组件的泛型 impl。此别名必须用 <code>#[abi(embed_v0)]</code> 注释以在外部公开组件的函数。</p>
<p>如你所见，InternalImpl 没有标记为 <code>#[abi(embed_v0)]</code>。确实，我们不想在外部公开在此 impl 中定义的函数。但是，我们可能仍然希望在内部访问它们。</p>
</li>
</ol>
<p>例如，要嵌入上面定义的 <code>Ownable</code> 组件，我们会做以下操作：</p>
<pre><code class="language-cairo noplayground">#[starknet::contract]
mod OwnableCounter {
    use listing_01_ownable::component::OwnableComponent;
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);

    //ANCHOR:  embedded_impl
    #[abi(embed_v0)]
    impl OwnableImpl = OwnableComponent::OwnableImpl&lt;ContractState&gt;;

    impl OwnableInternalImpl = OwnableComponent::InternalImpl&lt;ContractState&gt;;
    //ANCHOR_END: embedded_impl

    #[storage]
    struct Storage {
        counter: u128,
        #[substorage(v0)]
        ownable: OwnableComponent::Storage,
    }


    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        OwnableEvent: OwnableComponent::Event,
    }


    #[abi(embed_v0)]
    fn foo(ref self: ContractState) {
        self.ownable.assert_only_owner();
        self.counter.write(self.counter.read() + 1);
    }
}
</code></pre>
<p>组件的逻辑现在无缝地成为了合约的一部分！我们可以通过使用以合约地址实例化的 <code>IOwnableDispatcher</code> 来在外部调用组件函数。</p>
<pre><code class="language-cairo">#[starknet::interface]
trait IOwnable&lt;TContractState&gt; {
    //ANCHOR: trait_def
    fn owner(self: @TContractState) -&gt; ContractAddress;
    fn transfer_ownership(ref self: TContractState, new_owner: ContractAddress);
    fn renounce_ownership(ref self: TContractState);
    //ANCHOR_END: trait_def
}
</code></pre>
<h2 id="堆叠组件以实现最大的可组合性"><a class="header" href="#堆叠组件以实现最大的可组合性">堆叠组件以实现最大的可组合性</a></h2>
<p>当将多个组件组合在一起时，组件的可组合性才真正闪耀。每个组件都将其功能添加到合约中。你可以依靠 <a href="https://github.com/OpenZeppelin/cairo-contracts">Openzeppelin 的组件实现</a> 来快速插入你需要合约拥有的所有常用功能。</p>
<p>开发人员可以专注于他们的核心合约逻辑，同时依靠经过实战测试和审计的组件来处理其他所有事情。</p>
<p>组件甚至可以 <a href="#组件依赖">依赖</a> 其他组件，通过限制它们通用的 <code>TContractstate</code> 来实现另一个组件的 trait。在我们深入研究这种机制之前，让我们先看看 <a href="#组件底层原理">组件在底层是如何工作的</a>。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="组件底层原理"><a class="header" href="#组件底层原理">组件：底层原理</a></h1>
<p>组件为 Starknet 合约提供了强大的模块化。但这一切背后的魔法究竟是如何发生的呢？</p>
<p>本章将深入研究编译器内部机制，解释实现组件可组合性的机制。</p>
<h2 id="可嵌入-impl-入门"><a class="header" href="#可嵌入-impl-入门">可嵌入 Impl 入门</a></h2>
<p>在深入研究组件之前，我们需要了解 <em>可嵌入 impl (embeddable impls)</em>。</p>
<p>Starknet 接口 trait（标记为 <code>#[starknet::interface]</code>）的 impl 可以变为可嵌入的。可嵌入 impl 可以注入到任何合约中，添加新的入口点并修改合约的 ABI。</p>
<p>让我们看一个例子来观察它的实际效果：</p>
<pre><code class="language-cairo noplayground">#[starknet::interface]
trait SimpleTrait&lt;TContractState&gt; {
    fn ret_4(self: @TContractState) -&gt; u8;
}

#[starknet::embeddable]
impl SimpleImpl&lt;TContractState&gt; of SimpleTrait&lt;TContractState&gt; {
    fn ret_4(self: @TContractState) -&gt; u8 {
        4
    }
}

#[starknet::contract]
mod simple_contract {
    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl MySimpleImpl = super::SimpleImpl&lt;ContractState&gt;;
}
</code></pre>
<p>通过嵌入 <code>SimpleImpl</code>，我们在合约的 ABI 中外部公开了 <code>ret4</code>。</p>
<p>现在我们对嵌入机制有了更深入的了解，现在我们可以看看组件是如何在此基础上构建的。</p>
<h2 id="组件内部泛型-impl"><a class="header" href="#组件内部泛型-impl">组件内部：泛型 Impl</a></h2>
<p>回想一下组件中使用的 impl 块语法：</p>
<pre><code class="language-cairo noplayground">    #[embeddable_as(OwnableImpl)]
    impl Ownable&lt;
        TContractState, +HasComponent&lt;TContractState&gt;,
    &gt; of super::IOwnable&lt;ComponentState&lt;TContractState&gt;&gt; {
</code></pre>
<p>关键点：</p>
<ul>
<li>
<p>泛型 impl <code>Ownable</code> 需要底层合约实现 <code>HasComponent&lt;TContractState&gt;</code> trait，这在使用 <code>component!()</code> 宏在合约内使用组件时会自动生成。</p>
<p>编译器将生成一个可嵌入的 impl，它包装 <code>Ownable</code> 中的任何函数，将 <code>self: ComponentState&lt;TContractState&gt;</code> 参数替换为 <code>self: TContractState</code>，其中对组件状态的访问是通过 <code>HasComponent&lt;TContractState&gt;</code> trait 中的 <code>get_component</code> 函数进行的。</p>
<p>对于每个组件，编译器生成一个 <code>HasComponent</code> trait。此 trait 定义了在通用合约的实际 <code>TContractState</code> 和 <code>ComponentState&lt;TContractState&gt;</code> 之间建立桥梁的接口。</p>
<pre><code class="language-cairo noplayground">// 每个组件生成
trait HasComponent&lt;TContractState&gt; {
    fn get_component(self: @TContractState) -&gt; @ComponentState&lt;TContractState&gt;;
    fn get_component_mut(ref self: TContractState) -&gt; ComponentState&lt;TContractState&gt;;
    fn get_contract(self: @ComponentState&lt;TContractState&gt;) -&gt; @TContractState;
    fn get_contract_mut(ref self: ComponentState&lt;TContractState&gt;) -&gt; TContractState;
    fn emit&lt;S, impl IntoImp: traits::Into&lt;S, Event&gt;&gt;(ref self: ComponentState&lt;TContractState&gt;, event: S);
}
</code></pre>
<p>在我们的上下文中，<code>ComponentState&lt;TContractState&gt;</code> 是特定于 ownable 组件的类型，即它具有基于 <code>ownable_component::Storage</code> 中定义的存储变量的成员。从通用的 <code>TContractState</code> 转移到 <code>ComponentState&lt;TContractState&gt;</code> 将允许我们将 <code>OwnableImpl</code> 嵌入到任何想要使用它的合约中。相反的方向（<code>ComponentState&lt;TContractState&gt;</code> 到 <code>ContractState</code>）对于依赖项很有用（参见 <a href="#组件依赖">组件依赖</a> 部分中的 <code>Upgradeable</code> 组件依赖 <code>IOwnable</code> 实现的示例）。</p>
<p>简而言之，可以将上述 <code>HasComponent&lt;T&gt;</code> 的实现理解为：<strong>“其状态 T 具有 upgradeable 组件的合约”。</strong></p>
</li>
<li>
<p><code>Ownable</code> 用 <code>embeddable_as(&lt;name&gt;)</code> 属性注释：</p>
<p><code>embeddable_as</code> 类似于 <code>embeddable</code>；它仅适用于 <code>starknet::interface</code> trait 的 impl，并允许将此 impl 嵌入到合约模块中。话虽如此，<code>embeddable_as(&lt;name&gt;)</code> 在组件的上下文中具有另一个作用。最终，当将 <code>OwnableImpl</code> 嵌入到某个合约中时，我们期望得到一个具有以下函数的 impl：</p>
<pre><code class="language-cairo noplayground">  fn owner(self: @TContractState) -&gt; ContractAddress;
  fn transfer_ownership(ref self: TContractState, new_owner: ContractAddress);
  fn renounce_ownership(ref self: TContractState);
</code></pre>
<p>注意，虽然从接收泛型类型 <code>ComponentState&lt;TContractState&gt;</code> 的函数开始，但我们希望最终得到一个接收 <code>ContractState</code> 的函数。这就是 <code>embeddable_as(&lt;name&gt;)</code> 出现的地方。为了看到全貌，我们需要看看编译器由于 <code>embeddable_as(OwnableImpl)</code> 注释而生成的 impl 是什么样的：</p>
</li>
</ul>
<pre><code class="language-cairo noplayground">//TAG: does_not_compile
#[starknet::embeddable]
impl OwnableImpl&lt;
    TContractState, +HasComponent&lt;TContractState&gt;, impl TContractStateDrop: Drop&lt;TContractState&gt;,
&gt; of super::IOwnable&lt;TContractState&gt; {
    fn owner(self: @TContractState) -&gt; ContractAddress {
        let component = HasComponent::get_component(self);
        Ownable::owner(component)
    }

    fn transfer_ownership(ref self: TContractState, new_owner: ContractAddress) {
        let mut component = HasComponent::get_component_mut(ref self);
        Ownable::transfer_ownership(ref component, new_owner)
    }

    fn renounce_ownership(ref self: TContractState) {
        let mut component = HasComponent::get_component_mut(ref self);
        Ownable::renounce_ownership(ref component)
    }
}
</code></pre>
<p>注意，多亏有了 <code>HasComponent&lt;TContractState&gt;</code> 的 impl，编译器能够将我们的函数包装在一个新的 impl 中，该 impl 不直接了解 <code>ComponentState</code> 类型。<code>OwnableImpl</code>（我们在编写 <code>embeddable_as(OwnableImpl)</code> 时选择的名称）是我们将嵌入到想要所有权的合约中的 impl。</p>
<h2 id="合约集成"><a class="header" href="#合约集成">合约集成</a></h2>
<p>我们已经看到了泛型 impl 如何实现组件的可重用性。接下来让我们看看合约如何集成组件。</p>
<p>合约使用 <strong>impl 别名</strong> 用合约的具体 <code>ContractState</code> 实例化组件的泛型 impl。</p>
<pre><code class="language-cairo noplayground">    #[abi(embed_v0)]
    impl OwnableImpl = OwnableComponent::OwnableImpl&lt;ContractState&gt;;

    impl OwnableInternalImpl = OwnableComponent::InternalImpl&lt;ContractState&gt;;
</code></pre>
<p>上述行使用 Cairo impl 嵌入机制和 impl 别名语法。我们要用具体类型 <code>ContractState</code> 实例化可嵌入的生成 impl <code>OwnableImpl&lt;TContractState&gt;</code>。回想一下，泛型 impl 是 <code>Ownable&lt;TContractState&gt;</code>，而 <code>component!</code> 宏提供了 <code>HasComponent&lt;TContractState&gt;</code> 以便包装器可以委托给它。</p>
<p>注意，只有使用合约才能实现此 trait，因为只有它知道合约状态和组件状态。</p>
<p>这将所有内容粘合在一起，将组件逻辑注入到合约中。</p>
<h2 id="关键要点"><a class="header" href="#关键要点">关键要点</a></h2>
<ul>
<li>可嵌入 impl 允许通过添加入口点和修改合约 ABI 将组件逻辑注入到合约中。</li>
<li>当在合约中使用组件时，编译器会自动生成 <code>HasComponent</code> trait 实现。这在合约状态和组件状态之间建立了一座桥梁，使两者之间能够进行交互。</li>
<li>组件以通用的、与合约无关的方式封装可重用的逻辑。合约通过 impl 别名集成组件，并通过生成的 <code>HasComponent</code> trait 访问它们。</li>
<li>组件建立在可嵌入 impl 之上，通过定义可以集成到任何想要使用该组件的合约中的通用组件逻辑。Impl 别名使用合约的具体存储类型实例化这些通用 impl。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="组件依赖"><a class="header" href="#组件依赖">组件依赖</a></h1>
<p>当我们尝试在一个组件内部使用另一个组件时，使用组件变得更加复杂。如前所述，组件只能嵌入在合约中，这意味着不可能在另一个组件中嵌入一个组件。但是，这并不意味着我们不能在一个组件内部使用另一个组件。在本节中，我们将看到如何将一个组件用作另一个组件的依赖项。</p>
<p>考虑一个名为 <code>OwnableCounter</code> 的组件，其目的是创建一个只能由所有者增减的计数器。此组件可以嵌入在任何合约中，以便任何使用它的合约都将拥有一个只能由其所有者增减的计数器。</p>
<p>实现此目的的第一种方法是创建一个单独的组件，该组件在单个组件内包含计数器和所有权功能。然而，不建议这样做：我们的目标是最大程度地减少代码重复量并利用组件的可重用性。相反，我们可以创建一个新组件，它 <em>依赖</em> 于 <code>Ownable</code> 组件来获取所有权功能，并在内部定义计数器的逻辑。</p>
<p>清单 {{#ref ownable_component}} 显示了完整的实现，我们将紧接着对其进行分解：</p>
<pre><code class="language-cairo noplayground">//ANCHOR: interface

#[starknet::interface]
trait IOwnableCounter&lt;TContractState&gt; {
    fn get_counter(self: @TContractState) -&gt; u32;
    fn increment(ref self: TContractState);
}
//ANCHOR_END: interface

//ANCHOR: component
#[starknet::component]
pub mod OwnableCounterComponent {
    use listing_03_component_dep::owner::OwnableComponent;
    use listing_03_component_dep::owner::OwnableComponent::InternalImpl;
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};

    #[storage]
    pub struct Storage {
        value: u32,
    }

    //ANCHOR: component_impl
    #[embeddable_as(OwnableCounterImpl)]
    //ANCHOR: component_signature
    impl OwnableCounter&lt;
        TContractState,
        +HasComponent&lt;TContractState&gt;,
        +Drop&lt;TContractState&gt;,
        impl Owner: OwnableComponent::HasComponent&lt;TContractState&gt;,
    &gt; of super::IOwnableCounter&lt;ComponentState&lt;TContractState&gt;&gt; {
        //ANCHOR_END: component_signature
        //ANCHOR: get_counter
        fn get_counter(self: @ComponentState&lt;TContractState&gt;) -&gt; u32 {
            self.value.read()
        }
        //ANCHOR_END: get_counter

        //ANCHOR: increment
        fn increment(ref self: ComponentState&lt;TContractState&gt;) {
            let ownable_comp = get_dep_component!(@self, Owner);
            ownable_comp.assert_only_owner();
            self.value.write(self.value.read() + 1);
        }
        //ANCHOR_END: increment
    }
    //ANCHOR_END: component_impl
}
//ANCHOR_END: component
</code></pre>
<p>{{#label ownable_component}} <span class="caption">清单 {{#ref ownable_component}}: 一个 OwnableCounter 组件</span></p>
<h2 id="特性"><a class="header" href="#特性">特性</a></h2>
<h3 id="指定对另一个组件的依赖"><a class="header" href="#指定对另一个组件的依赖">指定对另一个组件的依赖</a></h3>
<pre><code class="language-cairo noplayground">    impl OwnableCounter&lt;
        TContractState,
        +HasComponent&lt;TContractState&gt;,
        +Drop&lt;TContractState&gt;,
        impl Owner: OwnableComponent::HasComponent&lt;TContractState&gt;,
    &gt; of super::IOwnableCounter&lt;ComponentState&lt;TContractState&gt;&gt; {
</code></pre>
<p>在 <a href="#cairo-中的-traits">第 8 章</a> 中，我们介绍了 trait 约束 (trait bounds)，用于指定泛型类型必须实现某个 trait。同样，我们可以通过限制 <code>impl</code> 块仅适用于包含所需组件的合约来指定一个组件依赖于另一个组件。在我们的例子中，这是通过添加限制 <code>impl Owner: ownable_component::HasComponent&lt;TContractState&gt;</code> 来完成的，这表明此 <code>impl</code> 块仅适用于包含 <code>ownable_component::HasComponent</code> trait 实现的合约。这本质上意味着 <code>TContractState</code> 类型可以访问 ownable 组件。有关更多信息，请参阅 <a href="#inside-components-generic-impls">组件底层原理</a>。</p>
<p>尽管大多数 trait 约束是使用 <a href="#anonymous-generic-implementation-parameter--operator">匿名参数</a> 定义的，但对 <code>Ownable</code> 组件的依赖是使用命名参数（这里是 <code>Owner</code>）定义的。当在 <code>impl</code> 块内访问 <code>Ownable</code> 组件时，我们将需要使用此显式名称。</p>
<p>虽然这种机制很冗长，一开始可能不容易上手，但它是 Cairo 中 trait 系统的强大杠杆。这种机制的内部工作原理对用户来说是抽象的，你只需要知道，当你在合约中嵌入组件时，同一合约中的所有其他组件都可以访问它。</p>
<h3 id="使用依赖项"><a class="header" href="#使用依赖项">使用依赖项</a></h3>
<p>既然我们已经让我们的 <code>impl</code> 依赖于 <code>Ownable</code> 组件，我们就可以在实现块内访问它的函数、存储和事件。要将 <code>Ownable</code> 组件带入作用域，我们有两个选择，这取决于我们是否打算改变 <code>Ownable</code> 组件的状态。如果我们想访问 <code>Ownable</code> 组件的状态而不改变它，我们使用 <code>get_dep_component!</code> 宏。如果我们想改变 <code>Ownable</code> 组件的状态（例如，更改当前所有者），我们使用 <code>get_dep_component_mut!</code> 宏。这两个宏都接受两个参数：第一个是 <code>self</code>，根据可变性作为快照或引用，表示使用依赖项的组件的状态，第二个是要访问的组件。</p>
<pre><code class="language-cairo noplayground">        fn increment(ref self: ComponentState&lt;TContractState&gt;) {
            let ownable_comp = get_dep_component!(@self, Owner);
            ownable_comp.assert_only_owner();
            self.value.write(self.value.read() + 1);
        }
</code></pre>
<p>在这个函数中，我们要确保只有所有者才能调用 <code>increment</code> 函数。我们需要使用 <code>Ownable</code> 组件中的 <code>assert_only_owner</code> 函数。我们将使用 <code>get_dep_component!</code> 宏，它将返回请求的组件状态的快照，并在其上调用 <code>assert_only_owner</code>，作为该组件的方法。</p>
<p>对于 <code>transfer_ownership</code> 函数，我们要改变该状态以更改当前所有者。因为我们知道嵌入此组件的合约实现了 <code>OwnableComponent</code> trait，所以不需要在 <code>OwnableCounterComponent</code> 组件中定义此函数：宿主合约将通过 <code>OwnableComponent</code> 公开它。</p>
<p>最终的宿主合约如清单 {{#ref contract}} 所示。</p>
<pre><code class="language-cairo noplayground">#[starknet::contract]
mod OwnableCounter {
    use listing_03_component_dep::counter::OwnableCounterComponent;
    use listing_03_component_dep::owner::OwnableComponent;
    use starknet::ContractAddress;

    component!(path: OwnableCounterComponent, storage: counter, event: CounterEvent);
    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);

    //ANCHOR:  embedded_impl
    #[abi(embed_v0)]
    impl OwnableCounterImpl =
        OwnableCounterComponent::OwnableCounterImpl&lt;ContractState&gt;;
    //ANCHOR_END: embedded_impl

    #[abi(embed_v0)]
    impl OwnableImpl = OwnableComponent::OwnableImpl&lt;ContractState&gt;;
    impl OwnableInternalImpl = OwnableComponent::InternalImpl&lt;ContractState&gt;;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        counter: OwnableCounterComponent::Storage,
        #[substorage(v0)]
        ownable: OwnableComponent::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        CounterEvent: OwnableCounterComponent::Event,
        OwnableEvent: OwnableComponent::Event,
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: ContractAddress) {
        self.ownable.initializer(owner);
    }
}
</code></pre>
<p>{{#label contract}} <span class="caption">清单 {{#ref contract}}: 宿主合约</span></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="测试组件"><a class="header" href="#测试组件">测试组件</a></h1>
<p>测试组件与测试合约略有不同。合约需要针对特定状态进行测试，这可以通过在测试中部署合约，或者通过简单地获取 <code>ContractState</code> 对象并在测试上下文中修改它来实现。</p>
<p>组件是一个通用的结构，旨在集成到合约中，不能单独部署，也没有我们可以使用的 <code>ContractState</code> 对象。那么我们如何测试它们呢？</p>
<p>让我们考虑我们要测试一个非常简单的名为 “Counter” 的组件，它允许每个合约拥有一个可以递增的计数器。组件定义在清单 {{#ref test_component}} 中：</p>
<pre><code class="language-cairo noplayground">#[starknet::component]
pub mod CounterComponent {
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};

    #[storage]
    pub struct Storage {
        value: u32,
    }

    #[embeddable_as(CounterImpl)]
    pub impl Counter&lt;
        TContractState, +HasComponent&lt;TContractState&gt;,
    &gt; of super::ICounter&lt;ComponentState&lt;TContractState&gt;&gt; {
        //ANCHOR: get_counter
        fn get_counter(self: @ComponentState&lt;TContractState&gt;) -&gt; u32 {
            self.value.read()
        }
        //ANCHOR_END: get_counter

        //ANCHOR: increment
        fn increment(ref self: ComponentState&lt;TContractState&gt;) {
            self.value.write(self.value.read() + 1);
        }
        //ANCHOR_END: increment
    }
}
</code></pre>
<p>{{#label test_component}} <span class="caption">清单 {{#ref test_component}}: 一个简单的 Counter 组件</span></p>
<h2 id="通过部署模拟合约测试组件"><a class="header" href="#通过部署模拟合约测试组件">通过部署模拟合约测试组件</a></h2>
<p>测试组件最简单的方法是将它集成到一个模拟合约中。这个模拟合约仅用于测试目的，并且仅集成你要测试的组件。这允许你在合约的上下文中测试组件，并使用分发器调用组件的入口点。</p>
<p>我们可以如下定义这样的模拟合约：</p>
<pre><code class="language-cairo noplayground">#[starknet::contract]
mod MockContract {
    use super::counter::CounterComponent;

    component!(path: CounterComponent, storage: counter, event: CounterEvent);

    #[storage]
    struct Storage {
        #[substorage(v0)]
        counter: CounterComponent::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        CounterEvent: CounterComponent::Event,
    }

    #[abi(embed_v0)]
    impl CounterImpl = CounterComponent::CounterImpl&lt;ContractState&gt;;
}
</code></pre>
<p>该合约完全致力于测试 <code>Counter</code> 组件。它使用 <code>component!</code> 宏嵌入组件，通过用 <code>#[abi(embed_v0)]</code> 注释 impl 别名来公开组件的入口点。</p>
<p>我们还需要定义一个接口，以便在外部与此模拟合约进行交互。</p>
<pre><code class="language-cairo noplayground">#[starknet::interface]
pub trait ICounter&lt;TContractState&gt; {
    fn get_counter(self: @TContractState) -&gt; u32;
    fn increment(ref self: TContractState);
}
</code></pre>
<p>我们现在可以通过部署此模拟合约并调用其入口点来为组件编写测试，就像我们对典型合约所做的那样。</p>
<pre><code class="language-cairo noplayground">use starknet::SyscallResultTrait;
use starknet::syscalls::deploy_syscall;
use super::MockContract;
use super::counter::{ICounterDispatcher, ICounterDispatcherTrait};

fn setup_counter() -&gt; ICounterDispatcher {
    let (address, _) = deploy_syscall(
        MockContract::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), false,
    )
        .unwrap_syscall();
    ICounterDispatcher { contract_address: address }
}

#[test]
fn test_constructor() {
    let counter = setup_counter();
    assert_eq!(counter.get_counter(), 0);
}

#[test]
fn test_increment() {
    let counter = setup_counter();
    counter.increment();
    assert_eq!(counter.get_counter(), 1);
}
</code></pre>
<h2 id="在不部署合约的情况下测试组件"><a class="header" href="#在不部署合约的情况下测试组件">在不部署合约的情况下测试组件</a></h2>
<p>在 <a href="#组件底层原理">组件底层原理</a> 中，我们看到组件利用泛型来定义可以嵌入多个合约的存储和逻辑。如果一个合约嵌入了一个组件，该合约中就会创建一个 <code>HasComponent</code> trait，并且组件方法变得可用。</p>
<p>这告诉我们，如果我们能为 <code>ComponentState</code> 结构体提供一个实现了 <code>HasComponent</code> trait 的具体 <code>TContractState</code>，就应该能够使用这个具体的 <code>ComponentState</code> 对象直接调用组件的方法，而不必部署模拟合约。</p>
<p>让我们看看如何使用类型别名来做到这一点。我们仍然需要定义一个模拟合约 —— 让我们使用与上面相同的合约 —— 但这次我们不需要部署它。</p>
<p>首先，我们需要使用类型别名定义泛型 <code>ComponentState</code> 类型的具体实现。我们将使用 <code>MockContract::ContractState</code> 类型来做到这一点。</p>
<pre><code class="language-cairo noplayground">type TestingState = CounterComponent::ComponentState&lt;MockContract::ContractState&gt;;

// You can derive even `Default` on this type alias
impl TestingStateDefault of Default&lt;TestingState&gt; {
    fn default() -&gt; TestingState {
        CounterComponent::component_state_for_testing()
    }
}
</code></pre>
<p>我们将 <code>TestingState</code> 类型定义为 <code>CounterComponent::ComponentState&lt;MockContract::ContractState&gt;</code> 类型的别名。通过传递 <code>MockContract::ContractState</code> 类型作为 <code>ComponentState</code> 的具体类型，我们将 <code>ComponentState</code> 结构体的具体实现别名为 <code>TestingState</code>。</p>
<p>因为 <code>MockContract</code> 嵌入了 <code>CounterComponent</code>，在 <code>Counter</code> impl 块中定义的 <code>CounterComponent</code> 方法（通过 <code>CounterImpl</code> 可嵌入别名公开）现在可以在 <code>TestingState</code> 对象上使用。</p>
<p>既然我们已经使这些方法可用，我们需要实例化一个 <code>TestingState</code> 类型的对象，我们将用它来测试组件。我们可以通过调用 <code>component_state_for_testing</code> 函数来做到这一点，该函数会自动推断它应该返回一个 <code>TestingState</code> 类型的对象。</p>
<p>我们甚至可以将其作为 <code>Default</code> trait 的一部分来实现，这允许我们使用 <code>Default::default()</code> 语法返回一个空的 <code>TestingState</code>。</p>
<p>让我们总结一下到目前为止我们所做的工作：</p>
<ul>
<li>我们定义了一个模拟合约，它嵌入了我们要测试的组件。</li>
<li>我们使用类型别名和 <code>MockContract::ContractState</code> 定义了 <code>ComponentState&lt;TContractState&gt;</code> 的具体实现，我们将其命名为 <code>TestingState</code>。</li>
<li>我们定义了一个函数，使用 <code>component_state_for_testing</code> 返回 <code>TestingState</code> 对象。</li>
</ul>
<p>我们现在可以通过直接调用其函数来为组件编写测试，而不必部署模拟合约。这种方法比前一种方法更轻量级，并且它允许测试通常不向外界公开的组件内部函数。</p>
<pre><code class="language-cairo noplayground">#[test]
fn test_increment() {
    let mut counter: TestingState = Default::default();

    counter.increment();
    counter.increment();

    assert_eq!(counter.get_counter(), 2);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="可升级合约"><a class="header" href="#可升级合约">可升级合约</a></h1>
<p>Starknet 通过更新合约源代码的系统调用具有原生可升级性，消除了对代理的需求。</p>
<blockquote>
<p><strong>⚠️ 警告</strong> 升级前请确保遵循安全建议。</p>
</blockquote>
<h2 id="starknet-中的可升级性如何工作"><a class="header" href="#starknet-中的可升级性如何工作">Starknet 中的可升级性如何工作</a></h2>
<p>为了更好地理解 Starknet 中的可升级性如何工作，重要的是要理解合约及其合约类之间的区别。</p>
<p><a href="https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/class-hash">合约类 (Contract Classes)</a> 代表程序的源代码。所有合约都与一个类相关联，许多合约可以是同一个类的实例。类通常由 <a href="https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/class-hash">类哈希 (class hash)</a> 表示，在部署某个类的合约之前，需要声明类哈希。</p>
<p>合约实例是对应于一个类的已部署合约，具有其自己的存储。</p>
<h2 id="替换合约类"><a class="header" href="#替换合约类">替换合约类</a></h2>
<h3 id="replace_class_syscall"><a class="header" href="#replace_class_syscall"><code>replace_class_syscall</code></a></h3>
<p><code>replace_class</code> <a href="https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/system-calls-cairo1/">系统调用</a> 允许合约在部署后通过替换其类哈希来更新其源代码。</p>
<p>要升级合约，请公开一个执行 <code>replace_class_syscall</code> 的入口点，将新类哈希作为参数：</p>
<pre><code class="language-cairo noplayground">use core::num::traits::Zero;
use starknet::{ClassHash, syscalls};

fn upgrade(new_class_hash: ClassHash) {
    assert!(!new_class_hash.is_zero(), "Class hash cannot be zero");
    syscalls::replace_class_syscall(new_class_hash).unwrap();
}
</code></pre>
<p>{{#label replace-class}} <span class="caption">清单 {{#ref replace-class}}: 公开 <code>replace_class_syscall</code> 以更新合约的类</span></p>
<blockquote>
<p><strong>📌 注意</strong>: 如果合约在部署时没有此机制，其类哈希仍可以通过 <a href="https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/system-calls-cairo1/#library_call">库调用</a> 进行替换。</p>
</blockquote>
<blockquote>
<p><strong>⚠️ 警告</strong>: 升级前彻底审查更改及其潜在影响，因为这是一个具有安全隐患的微妙过程。不要允许任意地址升级你的合约。</p>
</blockquote>
<h2 id="openzeppelin-的-upgradeable-组件"><a class="header" href="#openzeppelin-的-upgradeable-组件">OpenZeppelin 的 Upgradeable 组件</a></h2>
<p>OpenZeppelin Contracts for Cairo 提供了 <code>Upgradeable</code> 组件，可以嵌入到你的合约中使其可升级。此组件是向你的合约添加可升级性的简单方法，同时依靠经过审计的库。</p>
<h3 id="用法"><a class="header" href="#用法">用法</a></h3>
<p>升级通常是非常敏感的操作，通常需要某种形式的访问控制来避免未经授权的升级。本示例中使用 <code>Ownable</code> 组件将可升级性限制为单个地址，以便合约所有者拥有升级合约的独占权利。</p>
<pre><code class="language-cairo noplayground">#[starknet::contract]
mod UpgradeableContract {
    use openzeppelin::access::ownable::OwnableComponent;
    use openzeppelin_upgrades::UpgradeableComponent;
    use openzeppelin_upgrades::interface::IUpgradeable;
    use starknet::{ClassHash, ContractAddress};

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);
    component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);

    // Ownable Mixin
    #[abi(embed_v0)]
    impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl&lt;ContractState&gt;;
    impl OwnableInternalImpl = OwnableComponent::InternalImpl&lt;ContractState&gt;;

    // Upgradeable
    impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl&lt;ContractState&gt;;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        ownable: OwnableComponent::Storage,
        #[substorage(v0)]
        upgradeable: UpgradeableComponent::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        OwnableEvent: OwnableComponent::Event,
        #[flat]
        UpgradeableEvent: UpgradeableComponent::Event,
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: ContractAddress) {
        self.ownable.initializer(owner);
    }

    #[abi(embed_v0)]
    impl UpgradeableImpl of IUpgradeable&lt;ContractState&gt; {
        fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {
            // This function can only be called by the owner
            self.ownable.assert_only_owner();

            // Replace the class hash upgrading the contract
            self.upgradeable.upgrade(new_class_hash);
        }
    }
}
</code></pre>
<p>{{#label upgradeable-contract}} <span class="caption">清单 {{#ref upgradeable-contract}} 在合约中集成 OpenZeppelin 的 Upgradeable 组件</span></p>
<p><code>UpgradeableComponent</code> 提供：</p>
<ul>
<li>一个安全执行类替换的内部 <code>upgrade</code> 函数</li>
<li>一个当升级成功时发出的 <code>Upgraded</code> 事件</li>
<li>防止升级到零类哈希的保护</li>
</ul>
<p>有关更多信息，请参阅 <a href="https://docs.openzeppelin.com/contracts-cairo/alpha/api/upgrades">OpenZeppelin 文档 API 参考</a>。</p>
<h2 id="安全注意事项"><a class="header" href="#安全注意事项">安全注意事项</a></h2>
<p>升级可能是非常敏感的操作，执行升级时应始终将安全性放在首位。升级前请确保彻底审查更改及其后果。需要考虑的一些方面包括：</p>
<ul>
<li><strong>API 更改</strong> 可能会影响集成。例如，更改外部函数的参数可能会破坏调用你的合约的现有合约或链下系统。</li>
<li><strong>存储更改</strong> 可能会导致数据丢失（例如，更改存储槽名称，使现有存储无法访问）或数据损坏（例如，更改存储槽类型，或存储在存储中的结构体的组织方式）。</li>
<li><strong>存储冲突</strong>（例如，错误地重用来自另一个组件的相同存储槽）也是可能的，尽管如果遵循最佳实践（例如在存储变量前加上组件名称）则不太可能发生。</li>
<li>在 OpenZeppelin 合约版本之间升级之前，请务必检查向后兼容性。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="l1-l2-消息传递"><a class="header" href="#l1-l2-消息传递">L1-L2 消息传递</a></h1>
<p>Layer 2 的一个关键特性是其与 Layer 1 交互的能力。</p>
<p>Starknet 拥有自己的 <code>L1-L2</code> 消息传递系统，该系统与其共识机制和 L1 上状态更新的提交不同。消息传递是 L1 上的智能合约与 L2 上的智能合约（反之亦然）交互的一种方式，允许我们进行“跨链”交易。例如，我们可以在一条链上进行一些计算，并在另一条链上使用该计算的结果。</p>
<p>Starknet 上的桥接器都使用 <code>L1-L2</code> 消息传递。假设你想将代币从以太坊桥接到 Starknet。你只需将代币存入 L1 桥接合约，该合约将自动触发在 L2 上铸造相同的代币。<code>L1-L2</code> 消息传递的另一个好用例是 <a href="https://starkware.co/resource/defi-pooling/">DeFi 池 (DeFi pooling)</a>。</p>
<p>在 Starknet 上，重要的是要注意消息传递系统是 <strong>异步</strong> 和 <strong>不对称</strong> 的。</p>
<ul>
<li><strong>异步</strong>：这意味着在你的合约代码中（无论是 Solidity 还是 Cairo），你无法在合约代码执行中等待另一条链上发送消息的结果。</li>
<li><strong>不对称</strong>：从以太坊向 Starknet 发送消息 (<code>L1-&gt;L2</code>) 是由 Starknet 定序器完全自动化的，这意味着消息会自动传递到 L2 上的目标合约。但是，当从 Starknet 向以太坊发送消息 (<code>L2-&gt;L1</code>) 时，只有消息的哈希值由 Starknet 定序器发送到 L1。然后，你必须通过 L1 上的交易手动消费该消息。</li>
</ul>
<p>让我们深入了解细节。</p>
<h2 id="starknetmessaging-合约"><a class="header" href="#starknetmessaging-合约">StarknetMessaging 合约</a></h2>
<p><code>L1-L2</code> 消息传递系统的关键组件是 <a href="https://etherscan.io/address/0xc662c410C0ECf747543f5bA90660f6ABeBD9C8c4"><code>StarknetCore</code></a> 合约。它是部署在以太坊上的一组 Solidity 合约，允许 Starknet 正常运行。<code>StarknetCore</code> 的合约之一名为 <code>StarknetMessaging</code>，它是负责在 Starknet 和 Ethereum 之间传递消息的合约。<code>StarknetMessaging</code> 遵循一个 <a href="https://github.com/starkware-libs/cairo-lang/blob/4e233516f52477ad158bc81a86ec2760471c1b65/src/starkware/starknet/eth/IStarknetMessaging.sol#L6">接口</a>，该接口具有允许向 L2 发送消息、在 L1 上接收来自 L2 的消息以及取消消息的功能。</p>
<pre><code class="language-js">interface IStarknetMessaging is IStarknetMessagingEvents {

    function sendMessageToL2(
        uint256 toAddress,
        uint256 selector,
        uint256[] calldata payload
    ) external returns (bytes32);

    function consumeMessageFromL2(uint256 fromAddress, uint256[] calldata payload)
        external
        returns (bytes32);

    function startL1ToL2MessageCancellation(
        uint256 toAddress,
        uint256 selector,
        uint256[] calldata payload,
        uint256 nonce
    ) external;

    function cancelL1ToL2Message(
        uint256 toAddress,
        uint256 selector,
        uint256[] calldata payload,
        uint256 nonce
    ) external;
}
</code></pre>
<p><span class="caption"> Starknet 消息传递合约接口</span></p>
<p>在 <code>L1-&gt;L2</code> 消息的情况下，Starknet 定序器不断监听以太坊上 <code>StarknetMessaging</code> 合约发出的日志。一旦在日志中检测到消息，定序器就会准备并执行 <code>L1HandlerTransaction</code> 以调用目标 L2 合约上的函数。这需要 1-2 分钟才能完成（以太坊区块被挖掘需要几秒钟，然后定序器必须构建并执行交易）。</p>
<p><code>L2-&gt;L1</code> 消息是由 L2 上的合约执行准备的，并且是生成的区块的一部分。确定序器生成一个区块时，它将合约执行准备的每条消息的哈希发送到 L1 上的 <code>StarknetCore</code> 合约，一旦它们所属的区块在以太坊上得到证明和验证（目前大约需要 3-4 小时），就可以在那里消费它们。</p>
<h2 id="从以太坊向-starknet-发送消息"><a class="header" href="#从以太坊向-starknet-发送消息">从以太坊向 Starknet 发送消息</a></h2>
<p>如果你想从以太坊向 Starknet 发送消息，你的 Solidity 合约必须调用 <code>StarknetMessaging</code> 合约的 <code>sendMessageToL2</code> 函数。要在 Starknet 上接收这些消息，你需要用 <code>#[l1_handler]</code> 属性注释可以从 L1 调用的函数。</p>
<p>让我们来看一个取自 <a href="https://github.com/glihm/starknet-messaging-dev/blob/main/solidity/src/ContractMsg.sol">本教程</a> 的简单合约，我们要向 Starknet 发送一条消息。<code>_snMessaging</code> 是一个状态变量，已经用 <code>StarknetMessaging</code> 合约的地址初始化。你可以 <a href="https://docs.starknet.io/documentation/tools/important_addresses/">在这里</a> 查看所有 Starknet 合约和定序器地址。</p>
<pre><code class="language-js">// Sends a message on Starknet with a single felt.
function sendMessageFelt(
    uint256 contractAddress,
    uint256 selector,
    uint256 myFelt
)
    external
    payable
{
    // We "serialize" here the felt into a payload, which is an array of uint256.
    uint256[] memory payload = new uint256[](1);
    payload[0] = myFelt;

    // msg.value must always be &gt;= 20_000 wei.
    _snMessaging.sendMessageToL2{value: msg.value}(
        contractAddress,
        selector,
        payload
    );
}
</code></pre>
<p>该函数向 <code>StarknetMessaging</code> 合约发送一条包含单个 felt 值的消息。请注意，你的 Cairo 合约只能理解 <code>felt252</code> 数据类型，因此如果你想发送更复杂的数据，你必须确保将数据序列化为 <code>uint256</code> 数组遵循 Cairo 序列化方案。</p>
<p>重要的是要注意我们有 <code>{value: msg.value}</code>。事实上，我们这里必须发送的最小值为 <code>20k wei</code>，这是因为 <code>StarknetMessaging</code> 合约将在以太坊的存储中注册我们消息的哈希。</p>
<p>除了这 <code>20k wei</code> 之外，由于定序器执行的 <code>L1HandlerTransaction</code> 不绑定到任何账户（消息源自 L1），你还必须确保在 L1 上支付足够的费用，以便你的消息在 L2 上被反序列化和处理。</p>
<p><code>L1HandlerTransaction</code> 的费用以常规方式计算，就像 <code>Invoke</code> 交易一样。为此，你可以使用 <code>starkli</code> 或 <code>snforge</code> 分析 gas 消耗，以估算消息执行的成本。</p>
<p><code>sendMessageToL2</code> 的签名是：</p>
<pre><code class="language-js">function sendMessageToL2(
        uint256 toAddress,
        uint256 selector,
        uint256[] calldata payload
    ) external override returns (bytes32);
</code></pre>
<p>参数如下：</p>
<ul>
<li><code>toAddress</code>：将被调用的 L2 上的合约地址。</li>
<li><code>selector</code>：此合约在 <code>toAddress</code> 处的函数的选择器。此选择器（函数）必须具有 <code>#[l1_handler]</code> 属性才能被调用。</li>
<li><code>payload</code>：有效负载始终是 <code>felt252</code> 数组（在 Solidity 中用 <code>uint256</code> 表示）。由于这个原因，我们将输入 <code>myFelt</code> 插入到数组中。这就是为什么我们需要将输入数据插入到数组中的原因。</li>
</ul>
<p>在 Starknet 端，为了接收这条消息，我们有：</p>
<pre><code class="language-cairo noplayground">    #[l1_handler]
    fn msg_handler_felt(ref self: ContractState, from_address: felt252, my_felt: felt252) {
        assert!(from_address == self.allowed_message_sender.read(), "Invalid message sender");

        // You can now use the data, automatically deserialized from the message payload.
        assert!(my_felt == 123, "Invalid value");
    }
</code></pre>
<p>我们需要将 <code>#[l1_handler]</code> 属性添加到我们的函数中。L1 处理程序是只能由 <code>L1HandlerTransaction</code> 执行的特殊函数。接收来自 L1 的交易没有什么特别要做的，因为消息由定序器自动中继。在你的 <code>#[l1_handler]</code> 函数中，验证 L1 消息的发送者非常重要，以确保我们的合约只能接收来自受信任的 L1 合约的消息。</p>
<h2 id="从-starknet-向以太坊发送消息"><a class="header" href="#从-starknet-向以太坊发送消息">从 Starknet 向以太坊发送消息</a></h2>
<p>当从 Starknet 向以太坊发送消息时，你必须在你的 Cairo 合约中使用 <code>send_message_to_l1</code> 系统调用。此系统调用允许你向 L1 上的 <code>StarknetMessaging</code> 合约发送消息。与 <code>L1-&gt;L2</code> 消息不同，<code>L2-&gt;L1</code> 消息必须手动消费，这意味着你需要你的 Solidity 合约显式调用 <code>StarknetMessaging</code> 合约的 <code>consumeMessageFromL2</code> 函数才能消费该消息。</p>
<p>要将消息从 L2 发送到 L1，我们在 Starknet 上要做的是：</p>
<pre><code class="language-cairo noplayground">        fn send_message_felt(ref self: ContractState, to_address: EthAddress, my_felt: felt252) {
            // Note here, we "serialize" my_felt, as the payload must be
            // a `Span&lt;felt252&gt;`.
            syscalls::send_message_to_l1_syscall(to_address.into(), array![my_felt].span())
                .unwrap();
        }
</code></pre>
<p>我们只需构建有效负载并将其与 L1 合约地址一起传递给系统调用函数。</p>
<p>在 L1 上，重要的部分是构建 L2 发送的相同有效负载。然后在你的 Solidity 合约中，你可以通过传递 L2 合约地址和有效负载来调用 <code>consumeMessageFromL2</code>。请注意，<code>consumeMessageFromL2</code> 期望的 L2 合约地址是通过调用 <code>send_message_to_l1_syscall</code> 在 L2 上发送消息的合约地址。</p>
<pre><code class="language-js">function consumeMessageFelt(
    uint256 fromAddress,
    uint256[] calldata payload
)
    external
{
    let messageHash = _snMessaging.consumeMessageFromL2(fromAddress, payload);

    // You can use the message hash if you want here.

    // We expect the payload to contain only a felt252 value (which is a uint256 in Solidity).
    require(payload.length == 1, "Invalid payload");

    uint256 my_felt = payload[0];

    // From here, you can safely use `my_felt` as the message has been verified by StarknetMessaging.
    require(my_felt &gt; 0, "Invalid value");
}
</code></pre>
<p>正如你所看到的，在这个上下文中，我们不必验证哪个 L2 合约正在发送消息（就像我们在 L2 上验证哪个 L1 合约正在发送消息一样）。但我们实际上正在使用 <code>StarknetCore</code> 合约的 <code>consumeMessageFromL2</code> 来验证输入（L2 上的合约地址和有效负载），以确保我们只消费有效的消息。</p>
<blockquote>
<p><strong>注意：</strong> <code>StarknetCore</code> 合约的 <code>consumeMessageFromL2</code> 函数应该从 Solidity 合约中调用，而不是直接在 <code>StarknetCore</code> 合约上调用。其原因是因为 <code>StarknetCore</code> 合约正在使用 <code>msg.sender</code> 来实际计算消息的哈希值。而这个 <code>msg.sender</code> 必须对应于在 Starknet 上调用的 <code>send_message_to_l1_syscall</code> 函数中给出的 <code>to_address</code> 字段。</p>
</blockquote>
<h2 id="cairo-序列化"><a class="header" href="#cairo-序列化">Cairo 序列化</a></h2>
<p>在 L1 和 L2 之间发送消息之前，你必须记住，用 Cairo 编写的 Starknet 合约只能理解序列化数据。序列化数据始终是 <code>felt252</code> 数组。在 Solidity 中，我们有 <code>uint256</code> 类型，而 <code>felt252</code> 比 <code>uint256</code> 小大约 4 位。所以我们要特别注意我们正在发送的消息的有效负载中包含的值。如果在 L1 上，我们构建了一条包含超过最大 <code>felt252</code> 的值的消息，则该消息将被卡住，永远无法在 L2 上消费。</p>
<p>例如，Cairo 中的实际 <code>uint256</code> 值由如下结构体表示：</p>
<pre><code class="language-cairo does_not_compile">struct u256 {
    low: u128,
    high: u128,
}
</code></pre>
<p>它将被序列化为 <strong>两个</strong> felt，一个用于 <code>low</code>，一个用于 <code>high</code>。这意味着要向 Cairo 仅发送一个 <code>u256</code>，你需要从 L1 发送具有 <strong>两个</strong> 值的有效负载。</p>
<pre><code class="language-js">uint256[] memory payload = new uint256[](2);
// Let's send the value 1 as a u256 in cairo: low = 1, high = 0.
payload[0] = 1;
payload[1] = 0;
</code></pre>
<p>如果你想了解有关消息传递机制的更多信息，可以访问 <a href="https://docs.starknet.io/documentation/architecture_and_concepts/Network_Architecture/messaging-mechanism/">Starknet 文档</a>。</p>
<p>你也可以 <a href="https://github.com/glihm/starknet-messaging-dev">在这里找到详细指南</a> 以在本地测试消息传递系统。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="预言机交互-oracle-interactions"><a class="header" href="#预言机交互-oracle-interactions">预言机交互 (Oracle Interactions)</a></h1>
<p>本节重点介绍使用预言机将链下数据带到 Starknet 区块链的概念。预言机是第三方服务，充当中介，安全地将外部数据（如资产价格、天气信息或其他现实世界数据）传输到区块链和智能合约。它还提供了实际示例和代码片段，包括如何为游戏使用
<a href="https://docs.pragma.build/Resources/Starknet/data-feeds/consuming-data">Pragma 价格喂送</a>
和 <a href="https://github.com/cartridge-gg/vrf">Cartridge VRF</a> 来获取可验证随机数。</p>
<p>延伸阅读：</p>
<ul>
<li>Pragma Oracle 价格喂送:
https://docs.pragma.build/Resources/Starknet/data-feeds/consuming-data</li>
<li>Cartridge VRF 概述和用法: https://github.com/cartridge-gg/vrf</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="价格喂送-price-feeds"><a class="header" href="#价格喂送-price-feeds">价格喂送 (Price Feeds)</a></h1>
<p>由预言机启用的价格喂送充当现实世界数据源和区块链之间的桥梁。它们将来自多个可信外部来源（例如加密货币交易所、金融数据提供商等）的实时定价数据聚合到区块链网络。</p>
<p>对于本书本节中的示例，我们将使用 Pragma Oracle 读取 <code>ETH/USD</code> 资产对的价格喂送，并展示一个利用此喂送的迷你应用程序。</p>
<p><a href="https://www.pragma.build/">Pragma Oracle</a> 是一种领先的零知识预言机，它提供在 Starknet 区块链上以可验证的方式访问链下数据。</p>
<h2 id="设置你的合约以进行价格喂送"><a class="header" href="#设置你的合约以进行价格喂送">设置你的合约以进行价格喂送</a></h2>
<h3 id="添加-pragma-作为项目依赖项"><a class="header" href="#添加-pragma-作为项目依赖项">添加 Pragma 作为项目依赖项</a></h3>
<p>要开始在 Cairo 智能合约上集成 Pragma 以获取价格喂送数据，请编辑项目的 <code>Scarb.toml</code> 文件以包含使用 Pragma 的路径。</p>
<pre><code class="language-toml">[dependencies]
pragma_lib = { git = "https://github.com/astraly-labs/pragma-lib" }
</code></pre>
<h3 id="创建价格喂送合约"><a class="header" href="#创建价格喂送合约">创建价格喂送合约</a></h3>
<p>为项目添加必要的依赖项后，你需要定义一个包含所需 Pragma 价格喂送入口点的合约接口。</p>
<pre><code class="language-cairo noplayground">#[starknet::interface]
pub trait IPriceFeedExample&lt;TContractState&gt; {
    fn buy_item(ref self: TContractState);
    fn get_asset_price(self: @TContractState, asset_id: felt252) -&gt; u128;
}
</code></pre>
<p>在 <code>IPriceFeedExample</code> 中公开的两个公共函数中，与 Pragma 价格喂送预言机交互所需的是 <code>get_asset_price</code> 函数，这是一个接收 <code>asset_id</code> 参数并返回 <code>u128</code> 值的视图函数。</p>
<h3 id="导入-pragma-依赖项"><a class="header" href="#导入-pragma-依赖项">导入 Pragma 依赖项</a></h3>
<pre><code class="language-cairo noplayground">    use pragma_lib::abi::{IPragmaABIDispatcher, IPragmaABIDispatcherTrait};
    use pragma_lib::types::{DataType, PragmaPricesResponse};
    use starknet::contract_address::contract_address_const;
    use starknet::get_caller_address;
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
    use super::{ContractAddress, IPriceFeedExample};

    const ETH_USD: felt252 = 19514442401534788;
    const EIGHT_DECIMAL_FACTOR: u256 = 100000000;

    #[storage]
    struct Storage {
        pragma_contract: ContractAddress,
        product_price_in_usd: u256,
    }

    #[constructor]
    fn constructor(ref self: ContractState, pragma_contract: ContractAddress) {
        self.pragma_contract.write(pragma_contract);
        self.product_price_in_usd.write(100);
    }

    #[abi(embed_v0)]
    impl PriceFeedExampleImpl of IPriceFeedExample&lt;ContractState&gt; {
        fn buy_item(ref self: ContractState) {
            let caller_address = get_caller_address();
            let eth_price = self.get_asset_price(ETH_USD).into();
            let product_price = self.product_price_in_usd.read();

            // Calculate the amount of ETH needed
            let eth_needed = product_price * EIGHT_DECIMAL_FACTOR / eth_price;

            let eth_dispatcher = ERC20ABIDispatcher {
                contract_address: contract_address_const::&lt;
                    0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7,
                &gt;() // ETH Contract Address
            };

            // Transfer the ETH to the caller
            eth_dispatcher
                .transfer_from(
                    caller_address,
                    contract_address_const::&lt;
                        0x0237726d12d3c7581156e141c1b132f2db9acf788296a0e6e4e9d0ef27d092a2,
                    &gt;(),
                    eth_needed,
                );
        }

        //ANCHOR: price_feed_impl
        fn get_asset_price(self: @ContractState, asset_id: felt252) -&gt; u128 {
            // Retrieve the oracle dispatcher
            let oracle_dispatcher = IPragmaABIDispatcher {
                contract_address: self.pragma_contract.read(),
            };

            // Call the Oracle contract, for a spot entry
            let output: PragmaPricesResponse = oracle_dispatcher
                .get_data_median(DataType::SpotEntry(asset_id));

            return output.price;
        }
        //ANCHOR_END: price_feed_impl
    }
}
//ANCHOR_END: here


</code></pre>
<p>上面的代码片段显示了为了与 Pragma 预言机交互，你需要添加到合约模块的必要导入。</p>
<h3 id="合约中所需的价格喂送函数实现"><a class="header" href="#合约中所需的价格喂送函数实现">合约中所需的价格喂送函数实现</a></h3>
<pre><code class="language-cairo noplayground">        fn get_asset_price(self: @ContractState, asset_id: felt252) -&gt; u128 {
            // Retrieve the oracle dispatcher
            let oracle_dispatcher = IPragmaABIDispatcher {
                contract_address: self.pragma_contract.read(),
            };

            // Call the Oracle contract, for a spot entry
            let output: PragmaPricesResponse = oracle_dispatcher
                .get_data_median(DataType::SpotEntry(asset_id));

            return output.price;
        }
</code></pre>
<p><code>get_asset_price</code> 函数负责从 Pragma Oracle 检索由 <code>asset_id</code> 参数指定的资产价格。通过传递 <code>DataType::SpotEntry(asset_id)</code> 作为参数从 <code>IPragmaDispatcher</code> 实例调用的 <code>get_data_median</code> 方法，其输出被分配给名为 <code>output</code> 的 <code>PragmaPricesResponse</code> 类型变量。最后，该函数以 <code>u128</code> 形式返回请求资产的价格。</p>
<h2 id="使用-pragma-价格喂送的示例应用程序"><a class="header" href="#使用-pragma-价格喂送的示例应用程序">使用 Pragma 价格喂送的示例应用程序</a></h2>
<pre><code class="language-cairo noplayground">#[starknet::contract]
mod PriceFeedExample {
    //ANCHOR_END: pragma_lib
    use openzeppelin::token::erc20::interface::{ERC20ABIDispatcher, ERC20ABIDispatcherTrait};
    //ANCHOR: pragma_lib
    use pragma_lib::abi::{IPragmaABIDispatcher, IPragmaABIDispatcherTrait};
    use pragma_lib::types::{DataType, PragmaPricesResponse};
    use starknet::contract_address::contract_address_const;
    use starknet::get_caller_address;
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
    use super::{ContractAddress, IPriceFeedExample};

    const ETH_USD: felt252 = 19514442401534788;
    const EIGHT_DECIMAL_FACTOR: u256 = 100000000;

    #[storage]
    struct Storage {
        pragma_contract: ContractAddress,
        product_price_in_usd: u256,
    }

    #[constructor]
    fn constructor(ref self: ContractState, pragma_contract: ContractAddress) {
        self.pragma_contract.write(pragma_contract);
        self.product_price_in_usd.write(100);
    }

    #[abi(embed_v0)]
    impl PriceFeedExampleImpl of IPriceFeedExample&lt;ContractState&gt; {
        fn buy_item(ref self: ContractState) {
            let caller_address = get_caller_address();
            let eth_price = self.get_asset_price(ETH_USD).into();
            let product_price = self.product_price_in_usd.read();

            // Calculate the amount of ETH needed
            let eth_needed = product_price * EIGHT_DECIMAL_FACTOR / eth_price;

            let eth_dispatcher = ERC20ABIDispatcher {
                contract_address: contract_address_const::&lt;
                    0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7,
                &gt;() // ETH Contract Address
            };

            // Transfer the ETH to the caller
            eth_dispatcher
                .transfer_from(
                    caller_address,
                    contract_address_const::&lt;
                        0x0237726d12d3c7581156e141c1b132f2db9acf788296a0e6e4e9d0ef27d092a2,
                    &gt;(),
                    eth_needed,
                );
        }

        //ANCHOR: price_feed_impl
        fn get_asset_price(self: @ContractState, asset_id: felt252) -&gt; u128 {
            // Retrieve the oracle dispatcher
            let oracle_dispatcher = IPragmaABIDispatcher {
                contract_address: self.pragma_contract.read(),
            };

            // Call the Oracle contract, for a spot entry
            let output: PragmaPricesResponse = oracle_dispatcher
                .get_data_median(DataType::SpotEntry(asset_id));

            return output.price;
        }
        //ANCHOR_END: price_feed_impl
    }
}
</code></pre>
<blockquote>
<p><strong>注意</strong>：Pragma 使用 6 或 8 的小数位数因子返回不同代币对的值。你可以通过将值除以 \( {10^{n}} \) 来将值转换为所需的小数位数因子，其中 <code>n</code> 是小数位数因子。</p>
</blockquote>
<p>上面的代码是一个使用来自 Pragma 预言机的价格喂送的应用程序的实现示例。合约导入了必要的模块和接口，包括用于与 Pragma 预言机合约交互的 <code>IPragmaABIDispatcher</code> 和用于与 ETH ERC20 代币合约交互的 <code>ERC20ABIDispatcher</code>。</p>
<p>该合约有一个存储 <code>ETH/USD</code> 代币对 ID 的 <code>const</code>，和一个包含两个字段 <code>pragma_contract</code> 和 <code>product_price_in_usd</code> 的 <code>Storage</code> 结构体。构造函数初始化 <code>pragma_contract</code> 地址并将 <code>product_price_in_usd</code> 设置为 100。</p>
<p><code>buy_item</code> 函数是以太坊购买产品的主要入口点。它检索调用者的地址。它调用 <code>get_asset_price</code> 函数使用 <code>ETH_USD</code> 资产 ID 获取以美元计价的当前 ETH 价格。它根据相应 ETH 价格下的美元产品价格计算购买产品所需的 ETH 数量。然后，它通过调用 ERC20 ETH 合约上的 <code>balance_of</code> 方法来检查调用者是否有足够的 ETH。如果调用者有足够的 ETH，它会调用 <code>eth_dispatcher</code> 实例的 <code>transfer_from</code> 方法，将所需数量的 ETH 从调用者转移到另一个合约地址。</p>
<p><code>get_asset_price</code> 函数是与 Pragma 预言机交互的入口点，在上一节已经解释过。</p>
<p>你可以从他们的 <a href="https://docs.pragma.build/Resources/Starknet/data-feeds/consuming-data">文档</a> 中获得有关使用 Pragma 价格喂送消费数据的详细指南。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="随机性-randomness"><a class="header" href="#随机性-randomness">随机性 (Randomness)</a></h1>
<p>由于所有区块链在根本上都是确定性的，并且大多数是公共账本，因此在链上生成真正不可预测的随机性是一个挑战。这种随机性对于游戏、彩票和 NFT 的唯一生成中的公平结果至关重要。为了解决这个问题，预言机提供的可验证随机函数 (VRF) 提供了一种解决方案。VRF 保证随机性无法被预测或篡改，从而确保这些应用程序中的信任和透明度。</p>
<h2 id="vrf-概述"><a class="header" href="#vrf-概述">VRF 概述</a></h2>
<p>VRF 使用密钥和 nonce（唯一的输入）来生成看似随机的输出。虽然技术上是“伪随机”，但如果没有密钥，另一方实际上不可能预测结果。</p>
<p>VRF 不仅产生随机数，还产生一个证明，任何人都可以使用该证明来独立验证结果是否根据函数的参数正确生成。</p>
<h2 id="使用-cartridge-vrf-生成随机性"><a class="header" href="#使用-cartridge-vrf-生成随机性">使用 Cartridge VRF 生成随机性</a></h2>
<p><a href="https://github.com/cartridge-gg/vrf">Cartridge VRF</a> 提供了专为 Starknet 上的游戏设计的同步、链上可验证随机性 —— 尽管它也可以用于其他目的。它使用一个简单的流程：交易在对 VRF 提供者的 <code>request_random</code> 调用之前加上前缀，然后你的合约调用 <code>consume_random</code> 在同一交易中获取已验证的随机值。</p>
<h3 id="添加-cartridge-vrf-作为依赖项"><a class="header" href="#添加-cartridge-vrf-作为依赖项">添加 Cartridge VRF 作为依赖项</a></h3>
<p>编辑你的 Cairo 项目的 <code>Scarb.toml</code> 文件以包含 Cartridge VRF。</p>
<pre><code class="language-toml">[dependencies]
cartridge_vrf = { git = "https://github.com/cartridge-gg/vrf" }
</code></pre>
<h3 id="定义合约接口"><a class="header" href="#定义合约接口">定义合约接口</a></h3>
<pre><code class="language-cairo noplayground">use starknet::ContractAddress;

#[starknet::interface]
pub trait IVRFGame&lt;TContractState&gt; {
    fn get_last_random_number(self: @TContractState) -&gt; felt252;
    fn settle_random(ref self: TContractState);
    fn set_vrf_provider(ref self: TContractState, new_vrf_provider: ContractAddress);
}

#[starknet::interface]
pub trait IDiceGame&lt;TContractState&gt; {
    fn guess(ref self: TContractState, guess: u8);
    fn toggle_play_window(ref self: TContractState);
    fn get_game_window(self: @TContractState) -&gt; bool;
    fn process_game_winners(ref self: TContractState);
}
</code></pre>
<p>{{#label cartridge_vrf_interface}} <span class="caption">清单 {{#ref cartridge_vrf_interface}} 展示了将 Cartridge VRF 与简单骰子游戏集成的接口。</span></p>
<h3 id="cartridge-vrf-流程和关键入口点"><a class="header" href="#cartridge-vrf-流程和关键入口点">Cartridge VRF 流程和关键入口点</a></h3>
<p>Cartridge VRF 在单个交易中使用两个调用工作：</p>
<ol>
<li><code>request_random(caller, source)</code> — 必须是交易 multicall 中的第一个调用。它表明你在 <code>caller</code> 处的合约将使用指定的 <code>source</code> 消费随机值。</li>
<li><code>consume_random(source)</code> — 由你的游戏合约调用以同步检索随机值。VRF 证明在链上验证，该值立即可用。</li>
</ol>
<p>常见的 <code>source</code> 选择：</p>
<ul>
<li><code>Source::Nonce(ContractAddress)</code> — 对提供的地址使用提供者的内部 nonce，确保每个请求都有唯一的随机值。</li>
<li><code>Source::Salt(felt252)</code> — 使用静态盐。使用相同的盐将返回相同的随机值。</li>
</ul>
<h2 id="骰子游戏合约"><a class="header" href="#骰子游戏合约">骰子游戏合约</a></h2>
<p>这个骰子游戏合约允许玩家在活动游戏窗口期间猜测 1 到 6 之间的数字。合约所有者可以切换游戏窗口以禁用新猜测。为了确定中奖号码，合约所有者调用 <code>settle_random</code>，它从 Cartridge VRF 提供者那里消费一个随机值并将其存储在 <code>last_random_number</code> 中。每个玩家然后调用 <code>process_game_winners</code> 来确定他们赢了还是输了。存储的 <code>last_random_number</code> 被归约为 1 到 6 之间的数字，并与玩家的猜测进行比较，发出 <code>GameWinner</code> 或 <code>GameLost</code>。</p>
<pre><code class="language-cairo noplayground">#[starknet::contract]
mod DiceGame {
    use cartridge_vrf::Source;

    // Cartridge VRF consumer component and types
    use cartridge_vrf::vrf_consumer::vrf_consumer_component::VrfConsumerComponent;
    use openzeppelin::access::ownable::OwnableComponent;
    use starknet::storage::{
        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
    };
    use starknet::{ContractAddress, get_caller_address, get_contract_address};

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);
    component!(path: VrfConsumerComponent, storage: vrf_consumer, event: VrfConsumerEvent);

    #[abi(embed_v0)]
    impl OwnableImpl = OwnableComponent::OwnableImpl&lt;ContractState&gt;;
    impl InternalImpl = OwnableComponent::InternalImpl&lt;ContractState&gt;;

    // Expose VRF consumer helpers
    #[abi(embed_v0)]
    impl VrfConsumerImpl = VrfConsumerComponent::VrfConsumerImpl&lt;ContractState&gt;;
    impl VrfConsumerInternalImpl = VrfConsumerComponent::InternalImpl&lt;ContractState&gt;;

    #[storage]
    struct Storage {
        user_guesses: Map&lt;ContractAddress, u8&gt;,
        game_window: bool,
        last_random_number: felt252,
        #[substorage(v0)]
        ownable: OwnableComponent::Storage,
        #[substorage(v0)]
        vrf_consumer: VrfConsumerComponent::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        GameWinner: ResultAnnouncement,
        GameLost: ResultAnnouncement,
        #[flat]
        OwnableEvent: OwnableComponent::Event,
        #[flat]
        VrfConsumerEvent: VrfConsumerComponent::Event,
    }

    #[derive(Drop, starknet::Event)]
    struct ResultAnnouncement {
        caller: ContractAddress,
        guess: u8,
        random_number: u256,
    }

    #[constructor]
    fn constructor(ref self: ContractState, vrf_provider: ContractAddress, owner: ContractAddress) {
        self.ownable.initializer(owner);
        self.vrf_consumer.initializer(vrf_provider);
        self.game_window.write(true);
    }

    #[abi(embed_v0)]
    impl DiceGame of super::IDiceGame&lt;ContractState&gt; {
        fn guess(ref self: ContractState, guess: u8) {
            assert!(self.game_window.read(), "GAME_INACTIVE");
            assert!(guess &gt;= 1 &amp;&amp; guess &lt;= 6, "INVALID_GUESS");

            let caller = get_caller_address();
            self.user_guesses.entry(caller).write(guess);
        }

        fn toggle_play_window(ref self: ContractState) {
            self.ownable.assert_only_owner();

            let current: bool = self.game_window.read();
            self.game_window.write(!current);
        }

        fn get_game_window(self: @ContractState) -&gt; bool {
            self.game_window.read()
        }

        fn process_game_winners(ref self: ContractState) {
            assert!(!self.game_window.read(), "GAME_ACTIVE");
            assert!(self.last_random_number.read() != 0, "NO_RANDOM_NUMBER_YET");

            let caller = get_caller_address();
            let user_guess: u8 = self.user_guesses.entry(caller).read();
            let reduced_random_number: u256 = self.last_random_number.read().into() % 6 + 1;

            if user_guess == reduced_random_number.try_into().unwrap() {
                self
                    .emit(
                        Event::GameWinner(
                            ResultAnnouncement {
                                caller: caller,
                                guess: user_guess,
                                random_number: reduced_random_number,
                            },
                        ),
                    );
            } else {
                self
                    .emit(
                        Event::GameLost(
                            ResultAnnouncement {
                                caller: caller,
                                guess: user_guess,
                                random_number: reduced_random_number,
                            },
                        ),
                    );
            }
        }
    }

    #[abi(embed_v0)]
    impl VRFGame of super::IVRFGame&lt;ContractState&gt; {
        fn get_last_random_number(self: @ContractState) -&gt; felt252 {
            self.last_random_number.read()
        }

        // Settle randomness for the current round using Cartridge VRF.
        // Requires the caller to prefix the multicall with:
        //   VRF.request_random(caller: &lt;this contract&gt;, source: Source::Nonce(&lt;this contract&gt;))
        fn settle_random(ref self: ContractState) {
            self.ownable.assert_only_owner();
            // Consume a random value tied to this contract's own nonce
            let random = self.vrf_consumer.consume_random(Source::Nonce(get_contract_address()));
            self.last_random_number.write(random);
        }

        fn set_vrf_provider(ref self: ContractState, new_vrf_provider: ContractAddress) {
            self.ownable.assert_only_owner();
            self.vrf_consumer.set_vrf_provider(new_vrf_provider);
        }
    }
}
</code></pre>
<p>{{#label dice_game_vrf}} <span class="caption">清单 {{#ref dice_game_vrf}}: 使用 Cartridge VRF 的简单骰子游戏合约。</span></p>
<h4 id="cartridge-vrf-的调用模式"><a class="header" href="#cartridge-vrf-的调用模式">Cartridge VRF 的调用模式</a></h4>
<p>当你从帐户调用 <code>settle_random</code> 入口点时，在交易的 multicall 前加上对 VRF 提供者的 <code>request_random</code> 的调用，使用与合约将传递给 <code>consume_random</code> 相同的 <code>source</code>（在此示例中，为 <code>Source::Nonce(&lt;dice_contract&gt;)</code>）。例如：</p>
<ol>
<li><code>VRF.request_random(caller: &lt;dice_contract&gt;, source: Source::Nonce(&lt;dice_contract&gt;))</code></li>
<li><code>&lt;dice_contract&gt;.settle_random()</code></li>
</ol>
<p>这确保了 VRF 服务器可以在链上提交并验证证明，并且随机值在执行期间可供你的合约使用。</p>
<h4 id="部署"><a class="header" href="#部署">部署</a></h4>
<ul>
<li>Mainnet
<ul>
<li>类哈希:
https://voyager.online/class/0x00be3edf412dd5982aa102524c0b8a0bcee584c5a627ed1db6a7c36922047257</li>
<li>合约:
https://voyager.online/contract/0x051fea4450da9d6aee758bdeba88b2f665bcbf549d2c61421aa724e9ac0ced8f</li>
</ul>
</li>
<li>Sepolia
<ul>
<li>类哈希:
https://sepolia.voyager.online/class/0x00be3edf412dd5982aa102524c0b8a0bcee584c5a627ed1db6a7c36922047257</li>
<li>合约:
https://sepolia.voyager.online/contract/0x051fea4450da9d6aee758bdeba88b2f665bcbf549d2c61421aa724e9ac0ced8f</li>
</ul>
</li>
</ul>
<p>在示例合约中使用网络的 VRF 提供者地址作为 <code>vrf_provider</code> 构造函数参数（或通过 <code>set_vrf_provider</code>）。</p>
<p>更多详细信息和更新：请参阅 <a href="https://github.com/cartridge-gg/vrf">Cartridge VRF 存储库</a>。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="其他示例"><a class="header" href="#其他示例">其他示例</a></h1>
<p>本节包含 Starknet 智能合约的其他示例，利用了 Cairo 编程语言的各种特性。欢迎并鼓励你的贡献，因为我们的目标是收集尽可能多的不同示例。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="部署投票合约并与之交互"><a class="header" href="#部署投票合约并与之交互">部署投票合约并与之交互</a></h1>
<p>Starknet 中的 <strong><code>Vote</code></strong> 合约首先通过合约的构造函数注册选民。在这个阶段初始化了三个选民，并将他们的地址传递给内部函数 <strong><code>_register_voters</code></strong>。此函数将选民添加到合约的状态中，标记他们已注册并有资格投票。</p>
<p>在合约中，定义了常量 <strong><code>YES</code></strong> 和 <strong><code>NO</code></strong> 来代表投票选项（分别为 1 和 0）。这些常量通过标准化输入值来促进投票过程。</p>
<p>一旦注册，选民就可以使用 <strong><code>vote</code></strong> 函数投票，选择 1 (YES) 或 0 (NO) 作为他们的投票。投票时，合约的状态会更新，记录投票并标记选民已投票。这确保了选民无法要在同一提案中再次投票。投票触发 <strong><code>VoteCast</code></strong> 事件，记录该操作。</p>
<p>合约还监控未经授权的投票尝试。如果检测到未经授权的操作，例如未注册的用户试图投票或用户试图再次投票，则会发出 <strong><code>UnauthorizedAttempt</code></strong> 事件。</p>
<p>这些函数、状态、常量和事件共同创建了一个结构化的投票系统，在 Starknet 环境中管理从注册到投、事件记录和结果检索的投票生命周期。像 <strong><code>YES</code></strong> 和 <strong><code>NO</code></strong> 这样的常量有助于简化投票过程，而事件在确保透明度和可追溯性方面起着至关重要的作用。</p>
<p>清单 {{#ref voting_contract}} 详细显示了 <code>Vote</code> 合约：</p>
<pre><code class="language-cairo noplayground">/// Core Library Imports for the Traits outside the Starknet Contract
use starknet::ContractAddress;

/// Trait defining the functions that can be implemented or called by the Starknet Contract
#[starknet::interface]
trait VoteTrait&lt;T&gt; {
    /// Returns the current vote status
    fn get_vote_status(self: @T) -&gt; (u8, u8, u8, u8);
    /// Checks if the user at the specified address is allowed to vote
    fn voter_can_vote(self: @T, user_address: ContractAddress) -&gt; bool;
    /// Checks if the specified address is registered as a voter
    fn is_voter_registered(self: @T, address: ContractAddress) -&gt; bool;
    /// Allows a user to vote
    fn vote(ref self: T, vote: u8);
}

/// Starknet Contract allowing three registered voters to vote on a proposal
#[starknet::contract]
mod Vote {
    use starknet::storage::{
        Map, StorageMapReadAccess, StorageMapWriteAccess, StoragePointerReadAccess,
        StoragePointerWriteAccess,
    };
    use starknet::{ContractAddress, get_caller_address};

    const YES: u8 = 1_u8;
    const NO: u8 = 0_u8;

    #[storage]
    struct Storage {
        yes_votes: u8,
        no_votes: u8,
        can_vote: Map&lt;ContractAddress, bool&gt;,
        registered_voter: Map&lt;ContractAddress, bool&gt;,
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        voter_1: ContractAddress,
        voter_2: ContractAddress,
        voter_3: ContractAddress,
    ) {
        self._register_voters(voter_1, voter_2, voter_3);

        self.yes_votes.write(0_u8);
        self.no_votes.write(0_u8);
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        VoteCast: VoteCast,
        UnauthorizedAttempt: UnauthorizedAttempt,
    }

    #[derive(Drop, starknet::Event)]
    struct VoteCast {
        voter: ContractAddress,
        vote: u8,
    }

    #[derive(Drop, starknet::Event)]
    struct UnauthorizedAttempt {
        unauthorized_address: ContractAddress,
    }

    #[abi(embed_v0)]
    impl VoteImpl of super::VoteTrait&lt;ContractState&gt; {
        fn get_vote_status(self: @ContractState) -&gt; (u8, u8, u8, u8) {
            let (n_yes, n_no) = self._get_voting_result();
            let (yes_percentage, no_percentage) = self._get_voting_result_in_percentage();
            (n_yes, n_no, yes_percentage, no_percentage)
        }

        fn voter_can_vote(self: @ContractState, user_address: ContractAddress) -&gt; bool {
            self.can_vote.read(user_address)
        }

        fn is_voter_registered(self: @ContractState, address: ContractAddress) -&gt; bool {
            self.registered_voter.read(address)
        }

        fn vote(ref self: ContractState, vote: u8) {
            assert!(vote == NO || vote == YES, "VOTE_0_OR_1");
            let caller: ContractAddress = get_caller_address();
            self._assert_allowed(caller);
            self.can_vote.write(caller, false);

            if (vote == NO) {
                self.no_votes.write(self.no_votes.read() + 1_u8);
            }
            if (vote == YES) {
                self.yes_votes.write(self.yes_votes.read() + 1_u8);
            }

            self.emit(VoteCast { voter: caller, vote: vote });
        }
    }

    #[generate_trait]
    impl InternalFunctions of InternalFunctionsTrait {
        fn _register_voters(
            ref self: ContractState,
            voter_1: ContractAddress,
            voter_2: ContractAddress,
            voter_3: ContractAddress,
        ) {
            self.registered_voter.write(voter_1, true);
            self.can_vote.write(voter_1, true);

            self.registered_voter.write(voter_2, true);
            self.can_vote.write(voter_2, true);

            self.registered_voter.write(voter_3, true);
            self.can_vote.write(voter_3, true);
        }
    }

    #[generate_trait]
    impl AssertsImpl of AssertsTrait {
        fn _assert_allowed(ref self: ContractState, address: ContractAddress) {
            let is_voter: bool = self.registered_voter.read((address));
            let can_vote: bool = self.can_vote.read((address));

            if (!can_vote) {
                self.emit(UnauthorizedAttempt { unauthorized_address: address });
            }

            assert!(is_voter, "USER_NOT_REGISTERED");
            assert!(can_vote, "USER_ALREADY_VOTED");
        }
    }

    #[generate_trait]
    impl VoteResultFunctionsImpl of VoteResultFunctionsTrait {
        fn _get_voting_result(self: @ContractState) -&gt; (u8, u8) {
            let n_yes: u8 = self.yes_votes.read();
            let n_no: u8 = self.no_votes.read();

            (n_yes, n_no)
        }

        fn _get_voting_result_in_percentage(self: @ContractState) -&gt; (u8, u8) {
            let n_yes: u8 = self.yes_votes.read();
            let n_no: u8 = self.no_votes.read();

            let total_votes: u8 = n_yes + n_no;

            if (total_votes == 0_u8) {
                return (0, 0);
            }
            let yes_percentage: u8 = (n_yes * 100_u8) / (total_votes);
            let no_percentage: u8 = (n_no * 100_u8) / (total_votes);

            (yes_percentage, no_percentage)
        }
    }
}
</code></pre>
<p>{{#label voting_contract}} <span class="caption">清单 {{#ref voting_contract}}: 一个投票智能合约</span></p>
<h2 id="部署调用和-invoke-投票合约"><a class="header" href="#部署调用和-invoke-投票合约">部署、调用和 Invoke 投票合约</a></h2>
<p>Starknet 体验的一部分是部署智能合约并与之交互。</p>
<p>一旦合约部署完毕，我们可以通过调用 (calling) 和 Invoke (invoking) 其函数与之交互：</p>
<ul>
<li>调用合约：与仅从状态读取的外部函数交互。这些函数不会改变网络的状态，所以它们不需要费用或签名。</li>
<li>Invoke 合约：与可以写入状态的外部函数交互。这些函数确实会改变网络的状态，并需要费用和签名。</li>
</ul>
<p>我们将使用 <code>katana</code> 设置本地开发节点来部署投票合约。然后，我们将通过调用和 Invoke 其函数与合约进行交互。你也可以使用 Goerli 测试网代替 <code>katana</code>。但是，我们建议使用 <code>katana</code> 进行本地开发和测试。你可以在 Starknet 文档的 <a href="https://docs.starknet.io/quick-start/using_devnet/">“使用开发网络”</a> 一章中找到 <code>katana</code> 的完整教程。</p>
<h3 id="katana-本地-starknet-节点"><a class="header" href="#katana-本地-starknet-节点"><code>katana</code> 本地 Starknet 节点</a></h3>
<p><code>katana</code> 由 <a href="https://book.dojoengine.org/toolchain/katana">Dojo 团队</a> 设计，旨在支持本地开发。它将允许你做所有你需要用 Starknet 做的事情，但是在本地。这是一个用于开发和测试的很棒的工具。</p>
<p>要从源代码安装 <code>katana</code>，请参阅 Dojo 引擎的 <a href="https://book.dojoengine.org/toolchain/katana#getting-started">“使用 Katana”</a> 一章。</p>
<blockquote>
<p>注意：请验证 <code>katana</code> 的版本是否与下面提供的指定版本匹配。</p>
<pre><code class="language-bash">$ katana --version
katana 1.0.9-dev (38b3c2a6)
</code></pre>
<p>要升级 <code>katana</code> 版本，请参阅 Dojo 引擎的 <a href="https://book.dojoengine.org/toolchain/katana#getting-started">“使用 Katana”</a> 一章。</p>
</blockquote>
<p>一旦安装了 <code>katana</code>，你可以使用以下命令启动本地 Starknet 节点：</p>
<pre><code class="language-bash">katana
</code></pre>
<p>此命令将启动一个带有预部署账户的本地 Starknet 节点。我们将使用这些账户来部署投票合约并与之交互：</p>
<pre><code class="language-bash">...
PREFUNDED ACCOUNTS
==================

| Account address |  0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0
| Private key     |  0x0300001800000000300000180000000000030000000000003006001800006600
| Public key      |  0x01b7b37a580d91bc3ad4f9933ed61f3a395e0e51c9dd5553323b8ca3942bb44e

| Account address |  0x033c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c
| Private key     |  0x0333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b
| Public key      |  0x04486e2308ef3513531042acb8ead377b887af16bd4cdd8149812dfef1ba924d

| Account address |  0x01d98d835e43b032254ffbef0f150c5606fa9c5c9310b1fae370ab956a7919f5
| Private key     |  0x07ca856005bee0329def368d34a6711b2d95b09ef9740ebf2c7c7e3b16c1ca9c
| Public key      |  0x07006c42b1cfc8bd45710646a0bb3534b182e83c313c7bc88ecf33b53ba4bcbc
...
</code></pre>
<p>在我们与投票合约交互之前，我们需要在 Starknet 上准备好选民和管理员账户。每个选民账户必须注册并为投票提供足够的资金。要更详细地了解账户如何通过账户抽象进行操作，请参阅 Starknet 文档的 <a href="https://docs.starknet.io/architecture-and-concepts/accounts/introduction/#account_abstraction">“账户抽象”</a> 一章。</p>
<h3 id="用于投票的智能钱包"><a class="header" href="#用于投票的智能钱包">用于投票的智能钱包</a></h3>
<p>除了 Scarb 之外，你还需要安装 Starkli。Starkli 是一个命令行工具，允许你与 Starknet 交互。你可以在 Starknet 文档的 <a href="https://docs.starknet.io/quick-start/environment-setup/">“设置 Starkli”</a> 一章中找到安装说明。</p>
<blockquote>
<p>注意：请验证 <code>starkli</code> 的版本是否与下面提供的指定版本匹配。</p>
<pre><code class="language-bash">$ starkli --version
0.3.6 (8d6db8c)
</code></pre>
<p>要升级 <code>starkli</code> 到 <code>0.3.6</code>，请使用 <code>starkliup -v 0.3.6</code> 命令，或者简单地使用 <code>starkliup</code> 安装最新的稳定版本。</p>
</blockquote>
<p>你可以使用以下命令检索智能钱包类哈希（对于你所有的智能钱包都是一样的）。注意使用 <code>--rpc</code> 标志和 <code>katana</code> 提供的 RPC 端点：</p>
<pre><code>starkli class-hash-at &lt;SMART_WALLET_ADDRESS&gt; --rpc http://0.0.0.0:5050
</code></pre>
<h3 id="合约部署"><a class="header" href="#合约部署">合约部署</a></h3>
<p>在部署之前，我们需要声明合约。我们可以使用 <code>starkli declare</code> 命令来完成：</p>
<pre><code class="language-bash">starkli declare target/dev/listing_99_12_vote_contract_Vote.contract_class.json --rpc http://0.0.0.0:5050 --account katana-0
</code></pre>
<p>如果你使用的编译器版本早于 Starkli 使用的版本，并且在使用上述命令时遇到 <code>compiler-version</code> 错误，你可以通过添加 <code>--compiler-version x.y.z</code> 标志在命令中指定要使用的编译器版本。</p>
<p>如果你仍然遇到编译器版本问题，请尝试使用命令 <code>starkliup</code> 升级 Starkli，以确保你使用的是最新版本的 starkli。</p>
<p>合约的类哈希是：
<code>0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52</code>。你可以在 Sepolia 测试网上声明此合约，并查看类哈希是否对应。</p>
<p><code>--rpc</code> 标志指定要使用的 RPC 端点（<code>katana</code> 提供的那个）。<code>--account</code> 标志指定用于签署交易的账户。</p>
<p>由于我们使用的是本地节点，交易将立即实现最终性。如果你使用的是 Goerli 测试网，你需要等待交易最终确认，这通常需要几秒钟。</p>
<p>以下命令部署投票合约并将 voter_0、voter_1 和 voter_2 注册为合格选民。这些是构造函数参数，所以添加一个你以后可以用来投票的选民账户。</p>
<pre><code class="language-bash">starkli deploy &lt;class_hash_of_the_contract_to_be_deployed&gt; &lt;voter_0_address&gt; &lt;voter_1_address&gt; &lt;voter_2_address&gt; --rpc http://0.0.0.0:5050 --account katana-0
</code></pre>
<p>一个示例命令：</p>
<pre><code class="language-bash">starkli deploy 0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52 0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0 0x033c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c 0x01d98d835e43b032254ffbef0f150c5606fa9c5c9310b1fae370ab956a7919f5 --rpc http://0.0.0.0:5050 --account katana-0
</code></pre>
<p>在这种情况下，合约已部署在特定地址：
<code>0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349</code>。对你来说，这个地址会有所不同。我们将使用此地址与合约进行交互。</p>
<h3 id="选民资格验证"><a class="header" href="#选民资格验证">选民资格验证</a></h3>
<p>在我们的投票合约中，我们有两个函数来验证选民资格，<code>voter_can_vote</code> 和 <code>is_voter_registered</code>。这些是外部读取函数，这意味着它们不会改变合约的状态，而只是读取当前状态。</p>
<p><code>is_voter_registered</code> 函数检查特定地址是否在合约中注册为合格选民。另一方面，<code>voter_can_vote</code> 函数检查特定地址的选民当前是否有资格投票，即他们已注册且尚未投票。</p>
<p>你可以使用 <code>starkli call</code> 命令调用这些函数。注意，<code>call</code> 命令用于读取函数，而 <code>invoke</code> 命令用于也可以写入存储的函数。<code>call</code> 命令不需要签名，而 <code>invoke</code> 命令需要。</p>
<pre><code class="language-bash+">starkli call 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 voter_can_vote 0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0 --rpc http://0.0.0.0:5050
</code></pre>
<p>首先我们添加了合约的地址，然后是我们想要调用的函数，最后是函数的输入。在这种情况下，我们正在检查地址为
<code>0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0</code> 的选民是否可以投票。</p>
<p>由于我们提供了一个已注册的选民地址作为输入，结果为 1（布尔值真），表明选民有资格投票。</p>
<p>接下来，让我们使用未注册的帐户地址调用 <code>is_voter_registered</code> 函数以观察输出：</p>
<pre><code class="language-bash">starkli call 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 is_voter_registered 0x44444444444444444 --rpc http://0.0.0.0:5050
</code></pre>
<p>使用未注册的帐户地址，终端输出为 0（即 false），确该帐户没有资格投票。</p>
<h3 id="投票-1"><a class="header" href="#投票-1">投票</a></h3>
<p>既然我们已经确定了如何验证选民资格，我们就可以投票了！要投票，我们与 <code>vote</code> 函数交互，该函数被标记为 external，必须使用 <code>starknet invoke</code> 命令。</p>
<p><code>invoke</code> 命令语法类似于 <code>call</code> 命令，但对于投票，我们提交 <code>1</code>（赞成）或 <code>0</code>（反对）作为我们的输入。当我们调用 <code>vote</code> 函数时，我们将被收取费用，并且交易必须由选民签署；我们正在写入合约的存储。</p>
<pre><code class="language-bash">//投赞成票
starkli invoke 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 vote 1 --rpc http://0.0.0.0:5050 --account katana-0

//投反对票
starkli invoke 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 vote 0 --rpc http://0.0.0.0:5050 --account katana-0
</code></pre>
<p>系统将提示你输入签名者的密码。输入密码后，交易将被签名并提交到 Starknet 网络。你将收到交易哈希作为输出。使用 starkli 交易命令，你可以获得有关交易的更多详细信息：</p>
<pre><code class="language-bash">starkli transaction &lt;TRANSACTION_HASH&gt; --rpc http://0.0.0.0:5050
</code></pre>
<p>这返回：</p>
<pre><code class="language-bash">{
  "transaction_hash": "0x5604a97922b6811060e70ed0b40959ea9e20c726220b526ec690de8923907fd",
  "max_fee": "0x430e81",
  "version": "0x1",
  "signature": [
    "0x75e5e4880d7a8301b35ff4a1ed1e3d72fffefa64bb6c306c314496e6e402d57",
    "0xbb6c459b395a535dcd00d8ab13d7ed71273da4a8e9c1f4afe9b9f4254a6f51"
  ],
  "nonce": "0x3",
  "type": "INVOKE",
  "sender_address": "0x3ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0",
  "calldata": [
    "0x1",
    "0x5ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349",
    "0x132bdf85fc8aa10ac3c22f02317f8f53d4b4f52235ed1eabb3a4cbbe08b5c41",
    "0x0",
    "0x1",
    "0x1",
    "0x1"
  ]
}
</code></pre>
<p>如果你尝试使用同一个签名者投票两次，你会得到一个错误：</p>
<pre><code class="language-bash">Error: code=ContractError, message="Contract error"
</code></pre>
<p>这个错误信息不是很有用，但是你可以查看你启动 <code>katana</code>（我们的本地 Starknet 节点）的终端中的输出以获取更多详细信息：</p>
<pre><code class="language-bash">...
Transaction execution error: "Error in the called contract (0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0):
    Error at pc=0:81:
    Got an exception while executing a hint: Custom Hint Error: Execution failed. Failure reason: \"USER_ALREADY_VOTED\".
    ...
</code></pre>
<p>错误的键是 <code>USER_ALREADY_VOTED</code>。</p>
<pre><code class="language-bash">assert!(can_vote, "USER_ALREADY_VOTED");
</code></pre>
<p>我们可以重复此过程，为我们想要用来投票的帐户创建签名者和帐户描述符。请记住，每个签名者必须从私钥创建，每个帐户描述符必须从公钥、智能钱包地址和智能钱包类哈希（对于每个选民都是相同的）创建。</p>
<pre><code class="language-bash">starkli invoke 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 vote 0 --rpc http://0.0.0.0:5050 --account katana-0

starkli invoke 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 vote 1 --rpc http://0.0.0.0:5050 --account katana-0
</code></pre>
<h3 id="可视化投票结果"><a class="header" href="#可视化投票结果">可视化投票结果</a></h3>
<p>要检查投票结果，我们通过 <code>starknet call</code> 命令调用 <code>get_vote_status</code> 函数，这是另一个视图函数。</p>
<pre><code class="language-bash">starkli call 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 get_vote_status --rpc http://0.0.0.0:5050
</code></pre>
<p>输出显示了“赞成”和“反对”票的统计以及它们的相对百分比。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="使用-erc20-代币"><a class="header" href="#使用-erc20-代币">使用 ERC20 代币</a></h1>
<p>Starknet 上的 ERC20 标准为同质化代币提供了统一的接口。这确保了任何同质化代币都可以在整个生态系统中以可预测的方式使用。本节探讨如何使用 OpenZeppelin Contracts for Cairo 创建 ERC20 代币，这是该标准的经过审计的实现。</p>
<blockquote>
<p>注意：虽然 Openzeppelin 组件经过了审计，通过你应该始终测试并确保你的代码不会被利用。本节提供的示例仅用于教育目的，不能用于生产。</p>
</blockquote>
<p>首先，我们将构建一个具有固定供应量的基本 ERC20 代币。该合约演示了使用 OpenZeppelin 组件创建代币的核心结构。</p>
<h2 id="基本-erc20-合约"><a class="header" href="#基本-erc20-合约">基本 ERC20 合约</a></h2>
<pre><code class="language-cairo noplayground">#[starknet::contract]
pub mod BasicERC20 {
    use openzeppelin::token::erc20::{DefaultConfig, ERC20Component, ERC20HooksEmptyImpl};
    use starknet::ContractAddress;

    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    // ERC20 Mixin
    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl&lt;ContractState&gt;;
    impl ERC20InternalImpl = ERC20Component::InternalImpl&lt;ContractState&gt;;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc20: ERC20Component::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC20Event: ERC20Component::Event,
    }

    #[constructor]
    fn constructor(ref self: ContractState, initial_supply: u256, recipient: ContractAddress) {
        let name = "MyToken";
        let symbol = "MTK";

        self.erc20.initializer(name, symbol);
        self.erc20.mint(recipient, initial_supply);
    }
}
</code></pre>
<p>{{#label basic-erc20}} <span class="caption">清单 {{#ref basic-erc20}}: 使用 OpenZeppelin 的基本 ERC20 代币实现</span></p>
<h3 id="理解实现"><a class="header" href="#理解实现">理解实现</a></h3>
<p>此合约是用 OpenZeppelin 的组件系统构建的。它嵌入了 <code>ERC20Component</code>，其中包含 ERC20 代币的所有核心逻辑，包括转账、批准和余额跟踪功能。为了使这些功能直接在合约上可用，我们实现了 <code>ERC20MixinImpl</code> trait。这种模式避免了为 ERC20 接口中的每个函数编写样板代码的需要。</p>
<p>当合约部署时，其构造函数被调用。构造函数首先通过调用 ERC20 组件上的 <code>initializer</code> 函数来初始化代币的元数据 —— 它的名称和符号。然后它铸造整个初始供应量并将其分配给部署合约的地址。由于没有其他函数可以创建新代币，因此总供应量从部署那一刻起是固定的。</p>
<p>合约的存储很少，只包含 <code>ERC20Component</code> 的状态。这包括跟踪代币余额和津贴的映射，以及代币的名称、符号和总供应量，但从合约的角度来看是抽象的。</p>
<p>我们刚刚实现的合约相当简单：它是一个固定供应量的代币，没有额外的功能。但我们也可以使用 OpenZeppelin 组件库来构建更复杂的代币！</p>
<p>以下示例展示了如何在保持符合 ERC20 标准的同时添加新功能。</p>
<h3 id="可铸造和可销毁的代币"><a class="header" href="#可铸造和可销毁的代币">可铸造和可销毁的代币</a></h3>
<p>此扩展添加了铸造新代币和销毁现有代币的功能，允许代币供应量在部署后发生变化。这对于供应量需要根据协议活动或治理进行调整的代币很有用。</p>
<pre><code class="language-cairo noplayground">#[starknet::contract]
pub mod MintableBurnableERC20 {
    use openzeppelin::access::ownable::OwnableComponent;
    use openzeppelin::token::erc20::{DefaultConfig, ERC20Component, ERC20HooksEmptyImpl};
    use starknet::ContractAddress;

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);
    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    // Ownable Mixin
    #[abi(embed_v0)]
    impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl&lt;ContractState&gt;;
    impl OwnableInternalImpl = OwnableComponent::InternalImpl&lt;ContractState&gt;;

    // ERC20 Mixin
    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl&lt;ContractState&gt;;
    impl ERC20InternalImpl = ERC20Component::InternalImpl&lt;ContractState&gt;;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        ownable: OwnableComponent::Storage,
        #[substorage(v0)]
        erc20: ERC20Component::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        OwnableEvent: OwnableComponent::Event,
        #[flat]
        ERC20Event: ERC20Component::Event,
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: ContractAddress) {
        let name = "MintableBurnableToken";
        let symbol = "MBT";

        self.erc20.initializer(name, symbol);
        self.ownable.initializer(owner);
    }

    #[external(v0)]
    fn mint(ref self: ContractState, recipient: ContractAddress, amount: u256) {
        // Only owner can mint new tokens
        self.ownable.assert_only_owner();
        self.erc20.mint(recipient, amount);
    }

    #[external(v0)]
    fn burn(ref self: ContractState, amount: u256) {
        // Any token holder can burn their own tokens
        let caller = starknet::get_caller_address();
        self.erc20.burn(caller, amount);
    }
}
</code></pre>
<p>{{#label mintable-burnable-erc20}} <span class="caption">清单 {{#ref mintable-burnable-erc20}}: 具有铸造和销毁功能的 ERC20</span></p>
<p>此合约引入了 <code>OwnableComponent</code> 来管理访问控制。部署合约的地址成为其所有者。<code>mint</code> 函数仅限于所有者，所有者可以创建新代币并将其分配给任何地址，从而增加总供应量。</p>
<p><code>burn</code> 函数允许任何代币持有者销毁他们自己的代币。此操作将代币从流通中永久移除并减少总供应量。</p>
<p>为了使这些函数向公众公开，我们只需在合约中将它们标记为 <code>#[external]</code>。它们成为合约入口点的一部分，任何人都可以调用它们。</p>
<h3 id="带有访问控制的可暂停代币"><a class="header" href="#带有访问控制的可暂停代币">带有访问控制的可暂停代币</a></h3>
<p>第二个扩展引入了一个更复杂的安全模型，具有基于角色的权限和紧急暂停功能。这种模式对于需要对操作进行细粒度控制以及在危机期间（例如安全事件）停止活动的方法的协议非常有用。</p>
<pre><code class="language-cairo noplayground">#[starknet::contract]
pub mod PausableERC20 {
    use openzeppelin::access::accesscontrol::AccessControlComponent;
    use openzeppelin::introspection::src5::SRC5Component;
    use openzeppelin::security::pausable::PausableComponent;
    use openzeppelin::token::erc20::{DefaultConfig, ERC20Component};
    use starknet::ContractAddress;

    const PAUSER_ROLE: felt252 = selector!("PAUSER_ROLE");
    const MINTER_ROLE: felt252 = selector!("MINTER_ROLE");

    component!(path: AccessControlComponent, storage: accesscontrol, event: AccessControlEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);
    component!(path: PausableComponent, storage: pausable, event: PausableEvent);
    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    // AccessControl
    #[abi(embed_v0)]
    impl AccessControlImpl =
        AccessControlComponent::AccessControlImpl&lt;ContractState&gt;;
    impl AccessControlInternalImpl = AccessControlComponent::InternalImpl&lt;ContractState&gt;;

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl&lt;ContractState&gt;;

    // Pausable
    #[abi(embed_v0)]
    impl PausableImpl = PausableComponent::PausableImpl&lt;ContractState&gt;;
    impl PausableInternalImpl = PausableComponent::InternalImpl&lt;ContractState&gt;;

    // ERC20
    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl&lt;ContractState&gt;;
    impl ERC20InternalImpl = ERC20Component::InternalImpl&lt;ContractState&gt;;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        accesscontrol: AccessControlComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage,
        #[substorage(v0)]
        pausable: PausableComponent::Storage,
        #[substorage(v0)]
        erc20: ERC20Component::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        AccessControlEvent: AccessControlComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event,
        #[flat]
        PausableEvent: PausableComponent::Event,
        #[flat]
        ERC20Event: ERC20Component::Event,
    }

    // ERC20 Hooks implementation
    impl ERC20HooksImpl of ERC20Component::ERC20HooksTrait&lt;ContractState&gt; {
        fn before_update(
            ref self: ERC20Component::ComponentState&lt;ContractState&gt;,
            from: ContractAddress,
            recipient: ContractAddress,
            amount: u256,
        ) {
            let contract_state = self.get_contract();
            // Check that the contract is not paused
            contract_state.pausable.assert_not_paused();
        }
    }

    #[constructor]
    fn constructor(ref self: ContractState, admin: ContractAddress) {
        let name = "PausableToken";
        let symbol = "PST";

        self.erc20.initializer(name, symbol);

        // Grant admin role
        self.accesscontrol.initializer();
        self.accesscontrol._grant_role(AccessControlComponent::DEFAULT_ADMIN_ROLE, admin);

        // Grant specific roles to admin
        self.accesscontrol._grant_role(PAUSER_ROLE, admin);
        self.accesscontrol._grant_role(MINTER_ROLE, admin);
    }

    #[external(v0)]
    fn pause(ref self: ContractState) {
        self.accesscontrol.assert_only_role(PAUSER_ROLE);
        self.pausable.pause();
    }

    #[external(v0)]
    fn unpause(ref self: ContractState) {
        self.accesscontrol.assert_only_role(PAUSER_ROLE);
        self.pausable.unpause();
    }

    #[external(v0)]
    fn mint(ref self: ContractState, recipient: ContractAddress, amount: u256) {
        self.accesscontrol.assert_only_role(MINTER_ROLE);
        self.erc20.mint(recipient, amount);
    }
}
</code></pre>
<p>{{#label pausable-erc20}} <span class="caption">清单 {{#ref pausable-erc20}}: 具有可暂停转账和基于角色的访问控制的 ERC20</span></p>
<p>此实现结合了四个组件：用于代币功能的 <code>ERC20Component</code>、用于管理角色的 <code>AccessControlComponent</code>、用于紧急停止机制的 <code>PausableComponent</code> 和用于接口检测的 <code>SRC5Component</code>。合约定义了两个角色：<code>PAUSER_ROLE</code>，可以暂停和取消暂停合约，以及 <code>MINTER_ROLE</code>，可以创建新代币。</p>
<p>与单一所有者不同，这种基于角色的系统允许分离管理职责。主管理员可以将 <code>PAUSER_ROLE</code> 授予安全团队，将 <code>MINTER_ROLE</code> 授予财务经理。</p>
<p>暂停功能使用钩子 (hook) 系统集成到代币的转账逻辑中。合约实现了 <code>ERC20HooksTrait</code>，其 <code>before_update</code> 函数会在任何代币转账或批准之前自动调用。此函数检查合约是否已暂停。如果具有 <code>PAUSER_ROLE</code> 的地址已暂停合约，则所有转账都将被阻止，直到取消暂停。这个钩子系统是扩展 ERC20 标准函数的基本功能的一种优雅方式，而无需重新定义它们。</p>
<p>在部署时，构造函数将所有角色授予部署者，部署者然后可以根据需要将这些角色委托给其他地址。</p>
<p>这些扩展实现展示了如何组合 OpenZeppelin 的组件来构建复杂且安全的合约。通过从标准的、经过审计的组件开始，开发人员可以添加自定义功能，而不会在安全性或标准合规性上妥协。</p>
<p>有关更高级的功能和详细文档，请参阅 <a href="https://docs.openzeppelin.com/contracts-cairo/">OpenZeppelin Contracts for Cairo 文档</a>。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="starknet-智能合约安全"><a class="header" href="#starknet-智能合约安全">Starknet 智能合约安全</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="一般建议"><a class="header" href="#一般建议">一般建议</a></h1>
<p>到目前为止，我们一直专注于学习如何编写 Cairo 代码，这是让你的程序焕发生机的最低要求；但编写 <em>安全</em> 的代码同样重要。本章提炼自大量真实的 Cairo/Starknet 审计资料，编译成具体的说明，你可以在编码、测试和审查合约时使用。</p>
<p>我们将重点关注：</p>
<ul>
<li>访问控制和升级</li>
<li>安全的 ERC20 代币集成</li>
<li>可能导致漏洞的 Cairo 特定陷阱</li>
<li>跨域/桥接安全</li>
<li>Starknet 上的经济/DoS 必备知识</li>
</ul>
<h2 id="访问控制升级和初始化器"><a class="header" href="#访问控制升级和初始化器">访问控制、升级和初始化器</a></h2>
<p>Starknet 审计中最常见的关键问题仍然是“谁可以调用此函数？”和“此函数可以（重新）初始化吗？”。Cairo 拥有很棒的简单构建块，你应该重用它们的逻辑来专注于程序的核心安全方面。</p>
<h3 id="控制你的特权路径"><a class="header" href="#控制你的特权路径">控制你的特权路径</a></h3>
<p>始终确保升级只能由授权角色完成。如果未经授权的用户可以升级你的合约，它可以将类替换为任何东西，并获得对合约的完全控制权。这同样适用于暂停/恢复函数、桥接处理程序（谁可以从 L1 调用此合约）和元执行 (meta-execution)。所有这些关键函数都应使用 OpenZeppelin 的 OwnableComponent 进行保护。</p>
<pre><code class="language-cairo noplayground">// components
component!(path: OwnableComponent, storage: ownable);
component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);

#[abi(embed_v0)]
impl OwnableImpl = OwnableComponent::OwnableImpl&lt;ContractState&gt;;
impl InternalUpgradeableImpl = UpgradeableComponent::InternalImpl&lt;ContractState&gt;;

#[event]
fn Upgraded(new_class_hash: felt252) {}

fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {
    self.ownable.assert_only_owner();
    self.upgradeable._upgrade(new_class_hash);
    Upgraded(new_class_hash); // emit explicit upgrade event
}
</code></pre>
<p><strong>为什么要发出事件？</strong> 事故响应和索引器依赖于它们。为升级、配置更改、暂停、清算和任何特权操作发出事件；包括地址（例如，代币）以消除歧义。</p>
<h3 id="初始化器应该只被调用一次"><a class="header" href="#初始化器应该只被调用一次">初始化器应该只被调用一次</a></h3>
<p>一个常见的漏洞向量是公开暴露的初始化器，可以在部署后调用。初始化器的目的是解耦部署和合约的初始化。但是，如果初始化器可以被多次调用，它可能会产生意想不到的后果。确保行为是幂等的。</p>
<pre><code class="language-cairo noplayground">#[storage]
struct Storage {
    _initialized: u8,
    // ...
}

fn initializer(ref self: ContractState, owner: ContractAddress) {
    assert!(self._initialized.read() == 0, "ALREADY_INIT");
    self._initialized.write(1);
    self.ownable.initialize(owner);
    // init the rest…
}
</code></pre>
<blockquote>
<p>规则：如果在部署期间它 <em>必须</em> 是外部的，请确保它只能被调用一次；如果它不需要是外部的，请将其保留为内部。</p>
</blockquote>
<h2 id="代币集成"><a class="header" href="#代币集成">代币集成</a></h2>
<h3 id="始终检查布尔返回值"><a class="header" href="#始终检查布尔返回值">始终检查布尔返回值</a></h3>
<p>虽然 OpenZeppelin ERC20 实现会在失败时 revert，但这并非所有 ERC-20 实现都会这样做。有些可能会返回 <code>false</code> 而不 panic。<code>transfer</code> 和 <code>transfer_from</code> 返回布尔标志；验证它们以确保转账成功。</p>
<h3 id="camelcase--snake_case-双接口"><a class="header" href="#camelcase--snake_case-双接口">CamelCase / snake_case 双接口</a></h3>
<p>Starknet 上的大多数 ERC20 代币应该使用 <code>snake_case</code> 命名风格。然而，由于遗留原因，一些旧的 ERC20 代币具有 <code>camelCase</code> 入口点，如果你合约调用它们期望找到 <code>snake_case</code>，这可能会导致问题。处理这两种命名风格很麻烦；但你应该至少确保你将与之交互的大多数代币使用 <code>snake_case</code> 命名风格，或者调整你的合约。</p>
<h2 id="cairo-特定陷阱"><a class="header" href="#cairo-特定陷阱">Cairo 特定陷阱</a></h2>
<p>Cairo 语言本身并没有非常复杂的语义可能引入漏洞，但有一些常规的编程模式可能导致不需要的行为。</p>
<h3 id="表达式中的运算符优先级"><a class="header" href="#表达式中的运算符优先级">表达式中的运算符优先级</a></h3>
<p>在 Cairo 中，<code>&amp;&amp;</code> 的优先级高于 <code>||</code>。确保组合表达式被正确地用括号括起来，以强制运算符之间的优先级。</p>
<pre><code class="language-cairo noplayground">// ❌ buggy: ctx.coll_ok and ctx.debt_ok are only required in Recovery
assert!(
    mode == Mode::None || mode == Mode::Recovery &amp;&amp; ctx.coll_ok &amp;&amp; ctx.debt_ok,
    "EMERGENCY_MODE"
);

// ✅ fixed
assert!(
    (mode == Mode::None || mode == Mode::Recovery) &amp;&amp; (ctx.coll_ok &amp;&amp; ctx.debt_ok),
    "EMERGENCY_MODE"
);
</code></pre>
<h3 id="无符号循环下溢"><a class="header" href="#无符号循环下溢">无符号循环下溢</a></h3>
<p>使用 <code>u32</code> 作为循环计数器可能会导致下溢 panic，如果该计数器减至 0 以下。如果计数器应该处理负值，请改用 <code>i32</code>。</p>
<pre><code class="language-cairo noplayground">// ✅ prefer signed counters or explicit break
let mut i: i32 = (n.try_into().unwrap()) - 1;
while i &gt;= 0 { // This would never trigger if `i` was a u32.
    // ...
    i -= 1;
}
</code></pre>
<h3 id="位打包到-felt252"><a class="header" href="#位打包到-felt252">位打包到 <code>felt252</code></a></h3>
<p>将多个字段打包到一个 <code>felt252</code> 中非常适合优化，但如果没有严格的边界，这也常见且危险。在将字段打包到 <code>felt252</code> 之前，请确检查字段的范围。值得注意的是，打包值的大小的总和不应超过 251 位。</p>
<pre><code class="language-cairo noplayground">fn pack_order(book_id: u256, tick_u24: u256, index_u40: u256) -&gt; felt252 {
    // width checks
    assert!(book_id &lt; (1_u256 * POW_2_187), "BOOK_OVER");
    assert!(tick_u24 &lt; (1_u256 * POW_2_24),  "TICK_OVER");
    assert!(index_u40 &lt; (1_u256 * POW_2_40), "INDEX_OVER");

    let packed: u256 =
        (book_id * POW_2_64) + (tick_u24 * POW_2_40) + index_u40;
    packed.try_into().expect("PACK_OVERFLOW")
}
</code></pre>
<p><span class="caption"> 如果值太大，位打包可能会失败。</span></p>
<h3 id="deploy_syscalldeploy_from_zerotrue-冲突"><a class="header" href="#deploy_syscalldeploy_from_zerotrue-冲突"><code>deploy_syscall(deploy_from_zero=true)</code> 冲突</a></h3>
<p>从零开始的确定性部署可能会导致冲突，如果尝试使用相同的 calldata 部署两个合约。确保将 <code>deploy_from_zero</code> 设置为 <code>false</code>，除非你确定要从零开始部署。</p>
<h3 id="不要检查-get_caller_addressis_zero"><a class="header" href="#不要检查-get_caller_addressis_zero">不要检查 <code>get_caller_address().is_zero()</code></a></h3>
<p>从 Solidity 继承而来的是零地址检查。在 Starknet 上，<code>get_caller_address()</code> 永远不零地址。因此，这些检查是无用的。</p>
<h2 id="跨域--桥接安全"><a class="header" href="#跨域--桥接安全">跨域 / 桥接安全</a></h2>
<p>L1-L2 交互是 Starknet 工作方式所特有的，并且可能是错误的来源。</p>
<h3 id="l1-处理程序必须验证调用者地址"><a class="header" href="#l1-处理程序必须验证调用者地址">L1 处理程序必须验证调用者地址</a></h3>
<p><code>#[l1_handler]</code> 属性将入口点标记为可从 L1 上的合约调用。在大多数情况下，你会希望确保该调用的来源是受信任的 L1 合约 —— 因此，你应该验证调用者地址。</p>
<pre><code class="language-cairo noplayground">#[l1_handler]
fn handle_deposit(
    ref self: ContractState,
    from_address: ContractAddress,
    account: ContractAddress,
    amount: u256
) {
    let l1_bridge = self._l1_bridge.read();
    assert!(!l1_bridge.is_zero(), 'UNINIT_BRIDGE');
    assert!(from_address == l1_bridge, 'ONLY_L1_BRIDGE');
    // credit account…
}
</code></pre>
<h2 id="经济dos-和恶意破坏-griefing"><a class="header" href="#经济dos-和恶意破坏-griefing">经济/DoS 和恶意破坏 (Griefing)</a></h2>
<h3 id="无界循环"><a class="header" href="#无界循环">无界循环</a></h3>
<p>用户控制的迭代（领取、批量提款、订单扫描）可能会超过 Starknet 步骤限制。确保限制迭代次数和/或使用分页模式将工作拆分多个交易。</p>
<p>值得注意的是，想象你正在实现一个系统，该系统被调用时，函数将遍历存储中的项目列表并处理它们。如果列表没有边界，攻击者可以增加该列表中的项目数量，导致函数永远不会终止，因为它将达到 Starknet 的执行步骤限制。</p>
<p>在这种情况下，合约就会变砖：<em>任何人</em> 都无法再与之交互，因为任何交互都会触发步骤限制。</p>
<p>为了绕过这个问题，例如你可以使用分页模式，其中函数一次处理最大数量的项目，并将下一个游标返回给调用者。然后调用者可以使用下一个游标再次调用该函数以处理下一批项目。</p>
<pre><code class="language-cairo noplayground">fn claim_withdrawals(ref self: ContractState, start: u64, max: u64) -&gt; u64 {
    let mut i = start;
    let end = core::cmp::min(self.pending_count.read(), start + max);
    while i &lt; end {
        self._process(i);
        i += 1;
    }
    end // next cursor
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="测试智能合约"><a class="header" href="#测试智能合约">测试智能合约</a></h1>
<p>测试智能合约是开发过程中至关重要的一部分。确保智能合约按预期运行并且安全非常重要。</p>
<p>在 Cairo Book 的前一部分中，我们学习了如何为 Cairo 程序编写和构建测试。我们演示了如何使用 <code>scarb</code> 命令行工具运行这些测试。虽然这种方法对于测试独立的 Cairo 程序和函数很有用，但它缺乏测试需要控制合约状态和执行上下文的智能合约的功能。因此，在本节中，我们将介绍如何使用 Starknet Foundry（Starknet 的智能合约开发工具链）来测试你的 Cairo 合约。</p>
<p>在本章中，我们将使用清单 {{#ref pizza-factory}} 中的 <code>PizzaFactory</code> 合约为作为示例，演示如何使用 Starknet Foundry 编写测试。</p>
<pre><code class="language-cairo noplayground">use starknet::ContractAddress;

#[starknet::interface]
pub trait IPizzaFactory&lt;TContractState&gt; {
    fn increase_pepperoni(ref self: TContractState, amount: u32);
    fn increase_pineapple(ref self: TContractState, amount: u32);
    fn get_owner(self: @TContractState) -&gt; ContractAddress;
    fn change_owner(ref self: TContractState, new_owner: ContractAddress);
    fn make_pizza(ref self: TContractState);
    fn count_pizza(self: @TContractState) -&gt; u32;
}

#[starknet::contract]
pub mod PizzaFactory {
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
    use starknet::{ContractAddress, get_caller_address};
    use super::IPizzaFactory;

    #[storage]
    pub struct Storage {
        pepperoni: u32,
        pineapple: u32,
        pub owner: ContractAddress,
        pizzas: u32,
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: ContractAddress) {
        self.pepperoni.write(10);
        self.pineapple.write(10);
        self.owner.write(owner);
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    pub enum Event {
        PizzaEmission: PizzaEmission,
    }

    #[derive(Drop, starknet::Event)]
    pub struct PizzaEmission {
        pub counter: u32,
    }

    #[abi(embed_v0)]
    impl PizzaFactoryimpl of super::IPizzaFactory&lt;ContractState&gt; {
        fn increase_pepperoni(ref self: ContractState, amount: u32) {
            assert!(amount != 0, "Amount cannot be 0");
            self.pepperoni.write(self.pepperoni.read() + amount);
        }

        fn increase_pineapple(ref self: ContractState, amount: u32) {
            assert!(amount != 0, "Amount cannot be 0");
            self.pineapple.write(self.pineapple.read() + amount);
        }

        fn make_pizza(ref self: ContractState) {
            assert!(self.pepperoni.read() &gt; 0, "Not enough pepperoni");
            assert!(self.pineapple.read() &gt; 0, "Not enough pineapple");

            let caller: ContractAddress = get_caller_address();
            let owner: ContractAddress = self.get_owner();

            assert!(caller == owner, "Only the owner can make pizza");

            self.pepperoni.write(self.pepperoni.read() - 1);
            self.pineapple.write(self.pineapple.read() - 1);
            self.pizzas.write(self.pizzas.read() + 1);

            self.emit(PizzaEmission { counter: self.pizzas.read() });
        }

        fn get_owner(self: @ContractState) -&gt; ContractAddress {
            self.owner.read()
        }

        fn change_owner(ref self: ContractState, new_owner: ContractAddress) {
            self.set_owner(new_owner);
        }

        fn count_pizza(self: @ContractState) -&gt; u32 {
            self.pizzas.read()
        }
    }

    #[generate_trait]
    pub impl InternalImpl of InternalTrait {
        fn set_owner(ref self: ContractState, new_owner: ContractAddress) {
            let caller: ContractAddress = get_caller_address();
            assert!(caller == self.get_owner(), "Only the owner can set ownership");

            self.owner.write(new_owner);
        }
    }
}
</code></pre>
<p>{{#label pizza-factory}} <span class="caption">清单 {{#ref pizza-factory}}: 一个需要测试的披萨工厂</span></p>
<h2 id="使用-starknet-foundry-配置你的-scarb-项目"><a class="header" href="#使用-starknet-foundry-配置你的-scarb-项目">使用 Starknet Foundry 配置你的 Scarb 项目</a></h2>
<p>你的 Scarb 项目的设置可以在 <code>Scarb.toml</code> 文件中配置。要使用 Starknet Foundry 作为你的测试工具，你需要将其添加为 <code>Scarb.toml</code> 文件中的开发依赖项。在撰写本文时，Starknet Foundry 的最新版本是 <code>v0.39.0</code> —— 但你应该使用最新版本。</p>
<pre><code class="language-toml noplayground">[dev-dependencies]
snforge_std = "0.51.1"

[scripts]
test = "snforge test"

[tool.scarb]
allow-prebuilt-plugins = ["snforge_std"]
</code></pre>
<p>默认情况下，<code>scarb test</code> 命令配置为执行 <code>scarb cairo-test</code>。在我们的设置中，我们将其配置为执行 <code>snforge test</code>。这将允许我们在运行 <code>scarb test</code> 命令时使用 Starknet Foundry 运行我们的测试。</p>
<p>一旦你的项目配置完成，你需要按照 <a href="https://foundry-rs.github.io/starknet-foundry/getting-started/installation.html">Starknet Foundry 文档</a> 中的安装指南安装 Starknet Foundry。像往常一样，我们建议使用 <code>asdf</code> 来管理你的开发工具版本。</p>
<h2 id="使用-starknet-foundry-测试智能合约"><a class="header" href="#使用-starknet-foundry-测试智能合约">使用 Starknet Foundry 测试智能合约</a></h2>
<p>使用 Starknet Foundry 运行测试的常用命令是 <code>snforge test</code>。但是，当我们配置项目时，我们定义了 <code>scarb test</code> 命令将运行 <code>snforge test</code> 命令。因此，在本章的其余部分，请认为 <code>scarb test</code> 命令在底层使用的是 <code>snforge test</code>。</p>
<p>合约的通常测试流程如下：</p>
<ol>
<li>声明要测试的合约类，由其名称标识</li>
<li>将构造函数 calldata 序列化为数组</li>
<li>部署合约并检索其地址</li>
<li>与合约的入口点交互以测试各种场景</li>
</ol>
<h3 id="部署要测试的合约"><a class="header" href="#部署要测试的合约">部署要测试的合约</a></h3>
<p>在清单 {{#ref contract-deployment}} 中，我们编写了一个函数来部署 <code>PizzaFactory</code> 合约并设置分发器以进行交互。</p>
<pre><code class="language-cairo noplayground">fn deploy_pizza_factory() -&gt; (IPizzaFactoryDispatcher, ContractAddress) {
    let contract = declare("PizzaFactory").unwrap().contract_class();

    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
    let constructor_calldata = array![owner.into()];

    let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();

    let dispatcher = IPizzaFactoryDispatcher { contract_address };

    (dispatcher, contract_address)
}
</code></pre>
<p>{{#label contract-deployment}} <span class="caption">清单 {{#ref contract-deployment}} 部署要测试的合约</span></p>
<h3 id="测试我们的合约"><a class="header" href="#测试我们的合约">测试我们的合约</a></h3>
<p>确定你的合约应遵守的行为是编写测试的第一步。在 <code>PizzaFactory</code> 合约中，我们确定合约应具有以下行为：</p>
<ul>
<li>部署后，合约所有者应设置为构造函数中提供的地址，工厂应拥有 10 个单位的 pepperoni 和 pineapple，并且没有创建披萨。</li>
<li>如果有人试图制作披萨并且他们不是所有者，则操作应失败。否则，披萨计数应增加，并且应发出事件。</li>
<li>如果有人试图获取合约的所有权并且他们不是所有者，则操作应失败。否则，所有者应更新。</li>
</ul>
<h4 id="使用-load-访问存储变量"><a class="header" href="#使用-load-访问存储变量">使用 <code>load</code> 访问存储变量</a></h4>
<pre><code class="language-cairo noplayground">#[test]
fn test_constructor() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();

    let pepperoni_count = load(pizza_factory_address, selector!("pepperoni"), 1);
    let pineapple_count = load(pizza_factory_address, selector!("pineapple"), 1);
    assert_eq!(pepperoni_count, array![10]);
    assert_eq!(pineapple_count, array![10]);
    assert_eq!(pizza_factory.get_owner(), owner());
}
</code></pre>
<p>{{#label test-constructor}} <span class="caption">清单 {{#ref test-constructor}}: 通过加载存储变量测试初始状态 </span></p>
<p>一旦我们的合约部署完毕，我们想断言初始值已按预期设置。如果我们的合约有一个返回存储变量值的入口点，我们可以调用此入口点。否则，我们可以使用 <code>snforge</code> 中的 <code>load</code> 函数在我们的合约内加载存储变量的值，即使它未通过入口点公开。</p>
<h4 id="使用-start_cheat_caller_address-模拟调用者地址"><a class="header" href="#使用-start_cheat_caller_address-模拟调用者地址">使用 <code>start_cheat_caller_address</code> 模拟调用者地址</a></h4>
<p>我们要工厂的安全性依赖于所有者是唯一能够制作披萨和转移所有权的人。为了测试这一点，我们可以使用 <code>start_cheat_caller_address</code> 函数来模拟调用者地址并断言合约按预期行事。</p>
<pre><code class="language-cairo noplayground">#[test]
fn test_change_owner_should_change_owner() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();

    let new_owner: ContractAddress = contract_address_const::&lt;'new_owner'&gt;();
    assert_eq!(pizza_factory.get_owner(), owner());

    start_cheat_caller_address(pizza_factory_address, owner());

    pizza_factory.change_owner(new_owner);

    assert_eq!(pizza_factory.get_owner(), new_owner);
}

#[test]
#[should_panic(expected: "Only the owner can set ownership")]
fn test_change_owner_should_panic_when_not_owner() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
    start_cheat_caller_address(pizza_factory_address, not_owner);
    pizza_factory.change_owner(not_owner);
    stop_cheat_caller_address(pizza_factory_address);
}
</code></pre>
<p>{{#label test-owner}} <span class="caption">清单 {{#ref test-owner}}: 通过模拟调用者地址测试合约的所有权 </span></p>
<p>使用 <code>start_cheat_caller_address</code>，我们首先作为所有者调用 <code>change_owner</code> 函数，然后作为不同的地址调用。我们断言当调用者不是所有者时操作失败，并且当调用者是所有者时所有者更新。</p>
<h4 id="使用-spy_events-捕获事件"><a class="header" href="#使用-spy_events-捕获事件">使用 <code>spy_events</code> 捕获事件</a></h4>
<p>创建披萨时，合约会发出事件。为了测试这一点，我们可以使用 <code>spy_events</code> 函数来捕获发出的事件，并断言事件是使用预期的参数发出的。自然，我们也可以断言披萨计数已增加，并且只有所有者可以制作披萨。</p>
<pre><code class="language-cairo noplayground">#[test]
#[should_panic(expected: "Only the owner can make pizza")]
fn test_make_pizza_should_panic_when_not_owner() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
    start_cheat_caller_address(pizza_factory_address, not_owner);

    pizza_factory.make_pizza();
}

#[test]
fn test_make_pizza_should_increment_pizza_counter() {
    // Setup
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
    start_cheat_caller_address(pizza_factory_address, owner());
    let mut spy = spy_events();

    // When
    pizza_factory.make_pizza();

    // Then
    let expected_event = PizzaEvents::PizzaEmission(PizzaEmission { counter: 1 });
    assert_eq!(pizza_factory.count_pizza(), 1);
    spy.assert_emitted(@array![(pizza_factory_address, expected_event)]);
}
</code></pre>
<p>{{#label capture-pizza-emission-event}} <span class="caption">清单 {{#ref capture-pizza-emission-event}}: 测试创建披萨时发出的事件</span></p>
<h4 id="使用-contract_state_for_testing-访问内部函数"><a class="header" href="#使用-contract_state_for_testing-访问内部函数">使用 <code>contract_state_for_testing</code> 访问内部函数</a></h4>
<p>到目前为止我们看到的所有测试都使用了涉及部署合约并与合约入口点交互的工作流。但是，有时我们可能希望直接测试合约的内部，而不部署合约。如果我们纯粹用 Cairo 术语进行推理，这该如何完成呢？</p>
<p>回想一下 <code>ContractState</code> 结构体，它用作合约所有入口点的参数。简而言之，此结构体包含零大小的字段，对应于合约的存储变量。这些字段的唯一目的是允许 Cairo 编译器生成用于访问存储变量的正确代码。如果我们可以创建此结构体的实例，我们就可以直接访问这些存储变量，而无需部署合约……</p>
<p>……这正是 <code>contract_state_for_testing</code> 函数所做的！它创建一个 <code>ContractState</code> 结构体的实例，允许我们调用任何以 <code>ContractState</code> 结构体为参数的函数，而无需部署合约。为了正确地与存储变量交互，我们需要手动导入定义对存储变量访问的 trait。</p>
<pre><code class="language-cairo noplayground">use crate::pizza::PizzaFactory::{InternalTrait};
use crate::pizza::{IPizzaFactoryDispatcher, IPizzaFactoryDispatcherTrait, PizzaFactory};

fn owner() -&gt; ContractAddress {
    contract_address_const::&lt;'owner'&gt;()
}

//ANCHOR: deployment
fn deploy_pizza_factory() -&gt; (IPizzaFactoryDispatcher, ContractAddress) {
    let contract = declare("PizzaFactory").unwrap().contract_class();

    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
    let constructor_calldata = array![owner.into()];

    let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();

    let dispatcher = IPizzaFactoryDispatcher { contract_address };

    (dispatcher, contract_address)
}
//ANCHOR_END: deployment

//ANCHOR: test_constructor
#[test]
fn test_constructor() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();

    let pepperoni_count = load(pizza_factory_address, selector!("pepperoni"), 1);
    let pineapple_count = load(pizza_factory_address, selector!("pineapple"), 1);
    assert_eq!(pepperoni_count, array![10]);
    assert_eq!(pineapple_count, array![10]);
    assert_eq!(pizza_factory.get_owner(), owner());
}
//ANCHOR_END: test_constructor

//ANCHOR: test_owner
#[test]
fn test_change_owner_should_change_owner() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();

    let new_owner: ContractAddress = contract_address_const::&lt;'new_owner'&gt;();
    assert_eq!(pizza_factory.get_owner(), owner());

    start_cheat_caller_address(pizza_factory_address, owner());

    pizza_factory.change_owner(new_owner);

    assert_eq!(pizza_factory.get_owner(), new_owner);
}

#[test]
#[should_panic(expected: "Only the owner can set ownership")]
fn test_change_owner_should_panic_when_not_owner() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
    start_cheat_caller_address(pizza_factory_address, not_owner);
    pizza_factory.change_owner(not_owner);
    stop_cheat_caller_address(pizza_factory_address);
}
//ANCHOR_END: test_owner

//ANCHOR: test_make_pizza
#[test]
#[should_panic(expected: "Only the owner can make pizza")]
fn test_make_pizza_should_panic_when_not_owner() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
    let not_owner = contract_address_const::&lt;'not_owner'&gt;();
    start_cheat_caller_address(pizza_factory_address, not_owner);

    pizza_factory.make_pizza();
}

#[test]
fn test_make_pizza_should_increment_pizza_counter() {
    // Setup
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
    start_cheat_caller_address(pizza_factory_address, owner());
    let mut spy = spy_events();

    // When
    pizza_factory.make_pizza();

    // Then
    let expected_event = PizzaEvents::PizzaEmission(PizzaEmission { counter: 1 });
    assert_eq!(pizza_factory.count_pizza(), 1);
    spy.assert_emitted(@array![(pizza_factory_address, expected_event)]);
}
//ANCHOR_END: test_make_pizza

//ANCHOR: test_internals
#[test]
fn test_set_as_new_owner_direct() {
    let mut state = PizzaFactory::contract_state_for_testing();
    let owner: ContractAddress = contract_address_const::&lt;'owner'&gt;();
    state.set_owner(owner);
    assert_eq!(state.owner.read(), owner);
}
//ANCHOR_END: test_internals


</code></pre>
<p>{{#label test-internal}} <span class="caption">清单 {{#ref test-internal}}: 对我们的合约进行单元测试而无需部署</span></p>
<p>这些导入使我们可以访问我们的内部函数（特别是 <code>set_owner</code>），以及对 <code>owner</code> 存储变量的读/写访问权限。一旦我们有了这些，我们就可以直接与合约交互，通过调用可以通过 <code>InternalTrait</code> 访问的 <code>set_owner</code> 方法来更改所有者的地址，并读取 <code>owner</code> 存储变量。</p>
<blockquote>
<p>注意：两种方法不能同时使用。如果你决定部署合约，你需要使用分发器与它交互。如果你决定测试内部函数，你需要直接与 <code>ContractState</code> 对象交互。</p>
</blockquote>
<pre><code class="language-bash noplayground">$ scarb test 
     Running test listing_02_pizza_factory_snfoundry (snforge test)
    Blocking waiting for file lock on registry db cache
    Blocking waiting for file lock on registry db cache
   Compiling test(listing_02_pizza_factory_snfoundry_unittest) listing_02_pizza_factory_snfoundry v0.1.0 (listings/ch104-starknet-smart-contracts-security/listing_02_pizza_factory_snfoundry/Scarb.toml)
warn: Usage of deprecated feature `"deprecated-starknet-consts"` with no `#[feature("deprecated-starknet-consts")]` attribute. Note: "Use `TryInto::try_into` in const context instead."
 --&gt; listings/ch104-starknet-smart-contracts-security/listing_02_pizza_factory_snfoundry/src/tests/foundry_test.cairo:8:33
use starknet::{ContractAddress, contract_address_const};
                                ^^^^^^^^^^^^^^^^^^^^^^

    Finished `dev` profile target(s) in 1 second


Collected 6 test(s) from listing_02_pizza_factory_snfoundry package
Running 6 test(s) from src/
[PASS] listing_02_pizza_factory_snfoundry::tests::foundry_test::test_set_as_new_owner_direct (l1_gas: ~0, l1_data_gas: ~160, l2_gas: ~80000)
[PASS] listing_02_pizza_factory_snfoundry::tests::foundry_test::test_constructor (l1_gas: ~0, l1_data_gas: ~384, l2_gas: ~360000)
[PASS] listing_02_pizza_factory_snfoundry::tests::foundry_test::test_change_owner_should_panic_when_not_owner (l1_gas: ~0, l1_data_gas: ~384, l2_gas: ~360000)
[PASS] listing_02_pizza_factory_snfoundry::tests::foundry_test::test_make_pizza_should_increment_pizza_counter (l1_gas: ~0, l1_data_gas: ~480, l2_gas: ~655360)
[PASS] listing_02_pizza_factory_snfoundry::tests::foundry_test::test_make_pizza_should_panic_when_not_owner (l1_gas: ~0, l1_data_gas: ~384, l2_gas: ~360000)
[PASS] listing_02_pizza_factory_snfoundry::tests::foundry_test::test_change_owner_should_change_owner (l1_gas: ~0, l1_data_gas: ~384, l2_gas: ~640000)
Tests: 6 passed, 0 failed, 0 ignored, 0 filtered out


</code></pre>
<p>测试的输出显示所有测试都成功通过，以及每个测试消耗的 gas 估算值。</p>
<h2 id="总结-14"><a class="header" href="#总结-14">总结</a></h2>
<p>在本章中，我们学习了如何使用 Starknet Foundry 测试智能合约。我们演示了如何部署合约并使用分发器与之交互。我们还展示了如何通过模拟调用者地址和捕获事件来测试合约的行为。最后，我们演示了如何直接测试合约的内部函数，而无需部署合约。</p>
<p>要了解有关 Starknet Foundry 的更多信息，请参阅 <a href="https://foundry-rs.github.io/starknet-foundry/index.html">Starknet Foundry 文档</a>。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="静态分析工具"><a class="header" href="#静态分析工具">静态分析工具</a></h1>
<p>静态分析是指在不执行代码的情况下检查代码的过程，重点关注其结构、语法和属性。它涉及分析源代码以识别潜在问题、漏洞或违反指定规则的情况。</p>
<p>通过定义规则（例如编码约定或安全指南），开发人员可以利用静态分析工具根据这些标准自动检查代码。</p>
<p>参考：</p>
<ul>
<li><a href="https://semgrep.dev/blog/2023/semgrep-now-supports-cairo-1-0">Semgrep Cairo 1.0 支持</a></li>
<li><a href="https://github.com/crytic/caracal">Caracal，一个 Starknet 静态分析器</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="附录"><a class="header" href="#附录">附录</a></h1>
<p>以下部分包含可能会在你的 Starknet 之旅中发现有用的参考资料。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="附录-a---系统调用"><a class="header" href="#附录-a---系统调用">附录 A - 系统调用</a></h1>
<p>本章基于 Starknet 文档，可在此处获取：
<a href="https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/system-calls-cairo1/">Starknet Docs</a>。</p>
<p>编写智能合约需要各种相关操作，例如调用另一个合约或访问合约的存储，而独立程序不需要这些操作。</p>
<p>Starknet 合约语言通过使用系统调用来支持这些操作。系统调用使合约能够请求 Starknet OS 的服务。你可以在函数中使用系统调用来获取依赖于 Starknet 更广泛状态的信息（否则无法访问），而不是函数作用域中出现的局部变量。</p>
<p>以下是 Cairo 1.0 中可用的系统调用列表：</p>
<ul>
<li><a href="#get_block_hash">get_block_hash</a></li>
<li><a href="#get_execution_info">get_execution_info</a></li>
<li><a href="#call_contract">call_contract</a></li>
<li><a href="#deploy">deploy</a></li>
<li><a href="#emit_event">emit_event</a></li>
<li><a href="#library_call">library_call</a></li>
<li><a href="#send_message_to_l1">send_message_to_L1</a></li>
<li><a href="#get_class_hash_at">get_class_hash_at</a></li>
<li><a href="#replace_class">replace_class</a></li>
<li><a href="#storage_read">storage_read</a></li>
<li><a href="#storage_write">storage_write</a></li>
<li><a href="#keccak">keccak</a></li>
<li><a href="#sha256_process_block">sha256_process_block</a></li>
</ul>
<h2 id="get_block_hash"><a class="header" href="#get_block_hash"><code>get_block_hash</code></a></h2>
<h4 id="语法"><a class="header" href="#语法">语法</a></h4>
<pre><code class="language-cairo noplayground">pub extern fn get_block_hash_syscall(
    block_number: u64,
) -&gt; SyscallResult&lt;felt252&gt; implicits(GasBuiltin, System) nopanic;
</code></pre>
<h4 id="描述"><a class="header" href="#描述">描述</a></h4>
<p>获取特定 Starknet 区块的哈希值，范围在 <code>[first_v0_12_0_block, current_block - 10]</code> 之间。</p>
<h4 id="返回值"><a class="header" href="#返回值">返回值</a></h4>
<p>返回给定区块的哈希值。</p>
<h4 id="错误信息"><a class="header" href="#错误信息">错误信息</a></h4>
<ul>
<li><code>Block number out of range</code>: <code>block_number</code> 大于 <em><code>current_block</code></em><code>- 10</code>。</li>
<li><code>0</code>: <code>block_number</code> 小于 v0.12.0 的第一个区块号。</li>
</ul>
<h4 id="公共库"><a class="header" href="#公共库">公共库</a></h4>
<ul>
<li><a href="https://github.com/starkware-libs/cairo/blob/0c882679fdb24a818cad19f2c18decbf6ef66153/corelib/src/starknet/syscalls.cairo#L37">syscalls.cairo</a></li>
</ul>
<h2 id="get_execution_info"><a class="header" href="#get_execution_info"><code>get_execution_info</code></a></h2>
<h4 id="语法-1"><a class="header" href="#语法-1">语法</a></h4>
<pre><code class="language-cairo noplayground">pub extern fn get_execution_info_syscall() -&gt; SyscallResult&lt;
    Box&lt;starknet::info::ExecutionInfo&gt;,
&gt; implicits(GasBuiltin, System) nopanic;
</code></pre>
<h4 id="描述-1"><a class="header" href="#描述-1">描述</a></h4>
<p>获取有关原始交易的信息。</p>
<p>在 Cairo 1.0 中，所有区块/交易/执行上下文的 getter 都被批处理到这一个系统调用中。</p>
<h4 id="参数"><a class="header" href="#参数">参数</a></h4>
<p>无。</p>
<h4 id="返回值-1"><a class="header" href="#返回值-1">返回值</a></h4>
<p>返回一个包含执行信息的 <a href="https://github.com/starkware-libs/cairo/blob/efbf69d4e93a60faa6e1363fd0152b8fcedbb00a/corelib/src/starknet/info.cairo#L8">结构体</a>。</p>
<h4 id="公共库-1"><a class="header" href="#公共库-1">公共库</a></h4>
<ul>
<li><a href="https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L35">syscalls.cairo</a></li>
</ul>
<h2 id="call_contract"><a class="header" href="#call_contract"><code>call_contract</code></a></h2>
<h4 id="语法-2"><a class="header" href="#语法-2">语法</a></h4>
<pre><code class="language-cairo noplayground">pub extern fn call_contract_syscall(
    address: ContractAddress, entry_point_selector: felt252, calldata: Span&lt;felt252&gt;,
) -&gt; SyscallResult&lt;Span&lt;felt252&gt;&gt; implicits(GasBuiltin, System) nopanic;
</code></pre>
<h4 id="描述-2"><a class="header" href="#描述-2">描述</a></h4>
<p>调用给定的合约。此系统调用需要被调用合约的地址、该合约内函数的选择器以及调用参数。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>内部调用不能返回 Err(_)，因为排序器和 Starknet OS 不处理这种情况。</p>
<p>如果 call_contract_syscall 失败，这无法被捕获，因此将导致整个交易被回滚。</p>
</blockquote>
<h4 id="参数-1"><a class="header" href="#参数-1">参数</a></h4>
<ul>
<li><em><code>address</code></em>: 你想要调用的合约地址。</li>
<li><em><code>entry_point_selector</code></em>: 该合约内函数的选择器，可以使用 <code>selector!</code> 宏计算。</li>
<li><em><code>calldata</code></em>: calldata 数组。</li>
</ul>
<h4 id="返回值-2"><a class="header" href="#返回值-2">返回值</a></h4>
<p>调用响应，类型为 <code>SyscallResult&lt;Span&lt;felt252&gt;&gt;</code>。</p>
<h4 id="公共库-2"><a class="header" href="#公共库-2">公共库</a></h4>
<ul>
<li><a href="https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L10">syscalls.cairo</a></li>
</ul>
<blockquote>
<p><strong>注意：</strong> 这被认为是调用合约的较低级语法。如果被调用合约的接口可用，那么你可以使用更直接的语法。</p>
</blockquote>
<h2 id="deploy"><a class="header" href="#deploy"><code>deploy</code></a></h2>
<h4 id="语法-3"><a class="header" href="#语法-3">语法</a></h4>
<pre><code class="language-cairo noplayground">pub extern fn deploy_syscall(
    class_hash: ClassHash,
    contract_address_salt: felt252,
    calldata: Span&lt;felt252&gt;,
    deploy_from_zero: bool,
) -&gt; SyscallResult&lt;(ContractAddress, Span&lt;felt252&gt;)&gt; implicits(GasBuiltin, System) nopanic;
</code></pre>
<h4 id="描述-3"><a class="header" href="#描述-3">描述</a></h4>
<p>部署先前声明的类的新实例。</p>
<h4 id="参数-2"><a class="header" href="#参数-2">参数</a></h4>
<ul>
<li><em><code>class_hash</code></em>: 要部署的合约的类哈希。</li>
<li><em><code>contract_address_salt</code></em>: 盐，发送者提供的任意值。它用于计算合约地址。</li>
<li><em><code>calldata</code></em>: 构造函数的 calldata。一个 field 数组。</li>
<li><em><code>deploy_from_zero</code></em>: 用于合约地址计算的标志。如果未设置，则调用者地址将用作新合约的部署者地址，否则使用 0。</li>
</ul>
<h4 id="返回值-3"><a class="header" href="#返回值-3">返回值</a></h4>
<p>一个包含在 SyscallResult 中的元组，其中：</p>
<ul>
<li>
<p>第一个元素是已部署合约的地址，类型为 <code>ContractAddress</code>。</p>
</li>
<li>
<p>第二个元素是合约构造函数的响应数组，类型为 <code>Span::&lt;felt252&gt;</code>。</p>
</li>
</ul>
<h4 id="公共库-3"><a class="header" href="#公共库-3">公共库</a></h4>
<ul>
<li><a href="https://github.com/starkware-libs/cairo/blob/4821865770ac9e57442aef6f0ce82edc7020a4d6/corelib/src/starknet/syscalls.cairo#L22">syscalls.cairo</a></li>
</ul>
<h2 id="emit_event"><a class="header" href="#emit_event"><code>emit_event</code></a></h2>
<h4 id="语法-4"><a class="header" href="#语法-4">语法</a></h4>
<pre><code class="language-cairo noplayground">pub extern fn emit_event_syscall(
    keys: Span&lt;felt252&gt;, data: Span&lt;felt252&gt;,
) -&gt; SyscallResult&lt;()&gt; implicits(GasBuiltin, System) nopanic;
</code></pre>
<h4 id="描述-4"><a class="header" href="#描述-4">描述</a></h4>
<p>发出具有给定键和数据的事件。</p>
<p>有关发出事件的更多信息和更高级的语法，请参阅 <a href="https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/starknet-events/">Starknet 事件</a>。</p>
<h4 id="参数-3"><a class="header" href="#参数-3">参数</a></h4>
<ul>
<li>
<p><em><code>keys</code></em>: 事件的键。这些类似于以太坊的事件 topics，你可以使用 starknet_getEvents 方法通过这些键进行过滤。</p>
</li>
<li>
<p><em><code>data</code></em>: 事件的数据。</p>
</li>
</ul>
<h4 id="返回值-4"><a class="header" href="#返回值-4">返回值</a></h4>
<p>无。</p>
<h4 id="示例"><a class="header" href="#示例">示例</a></h4>
<p>以下示发出一个具有两个键（字符串 <code>status</code> 和 <code>deposit</code>）和三个数据元素（<code>1</code>、<code>2</code> 和 <code>3</code>）的事件。</p>
<pre><code class="language-cairo noplayground">let keys = ArrayTrait::new();
keys.append('key');
keys.append('deposit');
let values = ArrayTrait::new();
values.append(1);
values.append(2);
values.append(3);
emit_event_syscall(keys, values).unwrap_syscall();
</code></pre>
<h4 id="公共库-4"><a class="header" href="#公共库-4">公共库</a></h4>
<ul>
<li><a href="https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L30">syscalls.cairo</a></li>
</ul>
<h2 id="library_call"><a class="header" href="#library_call"><code>library_call</code></a></h2>
<h4 id="语法-5"><a class="header" href="#语法-5">语法</a></h4>
<pre><code class="language-cairo noplayground">pub extern fn library_call_syscall(
    class_hash: ClassHash, function_selector: felt252, calldata: Span&lt;felt252&gt;,
) -&gt; SyscallResult&lt;Span&lt;felt252&gt;&gt; implicits(GasBuiltin, System) nopanic;
</code></pre>
<h4 id="描述-5"><a class="header" href="#描述-5">描述</a></h4>
<p>调用任何先前声明的类中请求的函数。该类仅用于其逻辑。</p>
<p>此系统调用取代了以太坊中已知的 delegate call 功能，重要的区别在于只涉及一个合约。</p>
<h4 id="参数-4"><a class="header" href="#参数-4">参数</a></h4>
<ul>
<li>
<p><em><code>class_hash</code></em>: 你想要使用的类的哈希。</p>
</li>
<li>
<p><em><code>function_selector</code></em>: 该类中函数的选择器，可以使用 <code>selector!</code> 宏计算。</p>
</li>
<li>
<p><em><code>calldata</code></em>: calldata。</p>
</li>
</ul>
<h4 id="返回值-5"><a class="header" href="#返回值-5">返回值</a></h4>
<p>调用响应，类型为 <code>SyscallResult&lt;Span&lt;felt252&gt;&gt;</code>。</p>
<h4 id="公共库-5"><a class="header" href="#公共库-5">公共库</a></h4>
<ul>
<li><a href="https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L43">syscalls.cairo</a></li>
</ul>
<h2 id="send_message_to_l1"><a class="header" href="#send_message_to_l1"><code>send_message_to_L1</code></a></h2>
<h4 id="语法-6"><a class="header" href="#语法-6">语法</a></h4>
<pre><code class="language-cairo noplayground">pub extern fn send_message_to_l1_syscall(
    to_address: felt252, payload: Span&lt;felt252&gt;,
) -&gt; SyscallResult&lt;()&gt; implicits(GasBuiltin, System) nopanic;
</code></pre>
<h4 id="描述-6"><a class="header" href="#描述-6">描述</a></h4>
<p>向 L1 发送消息。</p>
<p>此系统调用将消息参数包含为证明输出的一部分，并在收到状态更新（包括交易）后将这些参数公开给 L1 上的 <code>StarknetCore</code> 合约。</p>
<p>有关更多信息，请参阅 Starknet 的 <a href="https://docs.starknet.io/documentation/architecture_and_concepts/Network_Architecture/messaging-mechanism/">消息传递机制</a>。</p>
<h4 id="参数-5"><a class="header" href="#参数-5">参数</a></h4>
<ul>
<li>
<p><em><code>to_address</code></em>: 接收者的 L1 地址。</p>
</li>
<li>
<p><em><code>payload</code></em>: 包含消息有效负载的数组。</p>
</li>
</ul>
<h4 id="返回值-6"><a class="header" href="#返回值-6">返回值</a></h4>
<p>无。</p>
<h4 id="示例-1"><a class="header" href="#示例-1">示例</a></h4>
<p>以下示例向地址为 <code>3423542542364363</code> 的 L1 合约发送内容为 <code>(1,2)</code> 的消息。</p>
<pre><code class="language-cairo noplayground">let payload = ArrayTrait::new();
payload.append(1);
payload.append(2);
send_message_to_l1_syscall(payload).unwrap_syscall();
</code></pre>
<h4 id="公共库-6"><a class="header" href="#公共库-6">公共库</a></h4>
<ul>
<li><a href="https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L51">syscalls.cairo</a></li>
</ul>
<h2 id="get_class_hash_at"><a class="header" href="#get_class_hash_at"><code>get_class_hash_at</code></a></h2>
<h4 id="语法-7"><a class="header" href="#语法-7">语法</a></h4>
<pre><code class="language-cairo noplayground">pub extern fn get_class_hash_at_syscall(
    contract_address: ContractAddress,
) -&gt; SyscallResult&lt;ClassHash&gt; implicits(GasBuiltin, System) nopanic;
</code></pre>
<h4 id="描述-7"><a class="header" href="#描述-7">描述</a></h4>
<p>获取给定地址的合约的类哈希。</p>
<h4 id="参数-6"><a class="header" href="#参数-6">参数</a></h4>
<ul>
<li><em><code>contract_address</code></em>: 已部署合约的地址。</li>
</ul>
<h4 id="返回值-7"><a class="header" href="#返回值-7">返回值</a></h4>
<p>合约源代码的类哈希。</p>
<h4 id="公共库-7"><a class="header" href="#公共库-7">公共库</a></h4>
<ul>
<li><a href="https://github.com/starkware-libs/cairo/blob/67c6eff9c276d11bd1cc903d7a3981d8d0eb2fa2/corelib/src/starknet/syscalls.cairo#L99">syscalls.cairo</a></li>
</ul>
<h2 id="replace_class"><a class="header" href="#replace_class"><code>replace_class</code></a></h2>
<h4 id="语法-8"><a class="header" href="#语法-8">语法</a></h4>
<pre><code class="language-cairo noplayground">pub extern fn replace_class_syscall(
    class_hash: ClassHash,
) -&gt; SyscallResult&lt;()&gt; implicits(GasBuiltin, System) nopanic;
</code></pre>
<h4 id="描述-8"><a class="header" href="#描述-8">描述</a></h4>
<p>一旦调用 <code>replace_class</code>，调用合约（即调用系统调用时 <code>get_contract_address</code> 返回其地址的合约）的类将被 class_hash 参数给出的类替换。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>调用 <code>replace_class</code> 后，当前从旧类执行的代码将完成运行。</p>
<p>新类将从下一个交易开始使用，或者如果在同一交易中（替换后）通过 <code>call_contract</code> 系统调用调用该合约。</p>
</blockquote>
<h4 id="参数-7"><a class="header" href="#参数-7">参数</a></h4>
<ul>
<li><em><code>class_hash</code></em>: 你想要用作替换的类的哈希。</li>
</ul>
<h4 id="返回值-8"><a class="header" href="#返回值-8">返回值</a></h4>
<p>无。</p>
<h4 id="公共库-8"><a class="header" href="#公共库-8">公共库</a></h4>
<ul>
<li><a href="https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L77">syscalls.cairo</a></li>
</ul>
<h2 id="storage_read"><a class="header" href="#storage_read"><code>storage_read</code></a></h2>
<h4 id="语法-9"><a class="header" href="#语法-9">语法</a></h4>
<pre><code class="language-cairo noplayground">pub extern fn storage_read_syscall(
    address_domain: u32, address: StorageAddress,
) -&gt; SyscallResult&lt;felt252&gt; implicits(GasBuiltin, System) nopanic;
</code></pre>
<h4 id="描述-9"><a class="header" href="#描述-9">描述</a></h4>
<p>获取调用合约存储中键的值。</p>
<p>与能够读取显式定义在合约中的存储变量的 <code>var.read()</code> 相比，此系统调用提供了对应存储中任何可能键的直接访问。</p>
<p>有关使用存储变量访问存储的信息，请参阅 <a href="https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-storage/#storage_variables">存储变量</a>。</p>
<h4 id="参数-8"><a class="header" href="#参数-8">参数</a></h4>
<ul>
<li>
<p><em><code>address_domain</code></em>: 键的域，用于区分不同的数据可用性模式。此分离用于在 Starknet 中提供不同的数据可用性模式。目前，仅支持由域 <code>0</code> 指示的链上模式（所有更新都转到 L1）。将来引入的其他地址域在发布方面将有不同的行为（特别是，它们不会发布在 L1 上，从而在成本和安全性之间进行权衡）。</p>
</li>
<li>
<p><em><code>address</code></em>: 请求的存储地址。</p>
</li>
</ul>
<h4 id="返回值-9"><a class="header" href="#返回值-9">返回值</a></h4>
<p>键的值，类型为 <code>SyscallResult&lt;felt252&gt;</code>。</p>
<h4 id="示例-2"><a class="header" href="#示例-2">示例</a></h4>
<pre><code class="language-cairo noplayground">use starknet::storage_access::storage_base_address_from_felt252;

...

let storage_address = storage_base_address_from_felt252(3534535754756246375475423547453)
storage_read_syscall(0, storage_address).unwrap_syscall()
</code></pre>
<h4 id="公共库-9"><a class="header" href="#公共库-9">公共库</a></h4>
<ul>
<li><a href="https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L60">syscalls.cairo</a></li>
</ul>
<h2 id="storage_write"><a class="header" href="#storage_write"><code>storage_write</code></a></h2>
<h4 id="语法-10"><a class="header" href="#语法-10">语法</a></h4>
<pre><code class="language-cairo noplayground">pub extern fn storage_write_syscall(
    address_domain: u32, address: StorageAddress, value: felt252,
) -&gt; SyscallResult&lt;()&gt; implicits(GasBuiltin, System) nopanic;
</code></pre>
<h4 id="描述-10"><a class="header" href="#描述-10">描述</a></h4>
<p>设置调用合约存储中键的值。</p>
<p>与能够写入显式定义在合约中的存储变量的 <code>var.write()</code> 相比，此系统调用提供了对应存储中任何可能键的直接访问。</p>
<p>有关使用存储变量访问存储的信息，请参阅 <a href="https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-storage/#storage_variables">存储变量</a>。</p>
<h4 id="参数-9"><a class="header" href="#参数-9">参数</a></h4>
<ul>
<li>
<p><em><code>address_domain</code></em>: 键的域，用于区分不同的数据可用性模式。此分离用于在 Starknet 中提供不同的数据可用性模式。目前，仅支持由域 <code>0</code> 指示的链上模式（所有更新都转到 L1）。将来引入的其他地址域在发布方面将有不同的行为（特别是，它们不会发布在 L1 上，从而在成本和安全性之间进行权衡）。</p>
</li>
<li>
<p><em><code>address</code></em>: 请求的存储地址。</p>
</li>
<li>
<p><em><code>value</code></em>: 要写入键的值。</p>
</li>
</ul>
<h4 id="返回值-10"><a class="header" href="#返回值-10">返回值</a></h4>
<p>无。</p>
<h4 id="公共库-10"><a class="header" href="#公共库-10">公共库</a></h4>
<ul>
<li><a href="https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L70">syscalls.cairo</a></li>
</ul>
<h2 id="keccak"><a class="header" href="#keccak"><code>keccak</code></a></h2>
<h4 id="语法-11"><a class="header" href="#语法-11">语法</a></h4>
<pre><code class="language-cairo noplayground">pub extern fn keccak_syscall(
    input: Span&lt;u64&gt;,
) -&gt; SyscallResult&lt;u256&gt; implicits(GasBuiltin, System) nopanic;
</code></pre>
<h4 id="描述-11"><a class="header" href="#描述-11">描述</a></h4>
<p>计算给定输入的 Keccak-256 哈希。</p>
<h4 id="参数-10"><a class="header" href="#参数-10">参数</a></h4>
<ul>
<li><em><code>input</code></em>: 一个 <code>Span&lt;u64&gt;</code> Keccak-256 输入。</li>
</ul>
<h4 id="返回值-11"><a class="header" href="#返回值-11">返回值</a></h4>
<p>返回哈希结果，类型为 <code>u256</code>。</p>
<h4 id="公共库-11"><a class="header" href="#公共库-11">公共库</a></h4>
<ul>
<li><a href="https://github.com/starkware-libs/cairo/blob/67c6eff9c276d11bd1cc903d7a3981d8d0eb2fa2/corelib/src/starknet/syscalls.cairo#L107">syscalls.cairo</a></li>
</ul>
<h2 id="sha256_process_block"><a class="header" href="#sha256_process_block"><code>sha256_process_block</code></a></h2>
<h4 id="语法-12"><a class="header" href="#语法-12">语法</a></h4>
<pre><code class="language-cairo noplayground">pub extern fn sha256_process_block_syscall(
    state: core::sha256::Sha256StateHandle, input: Box&lt;[u32; 16]&gt;
) -&gt; SyscallResult&lt;core::sha256::Sha256StateHandle&gt; implicits(GasBuiltin, System) nopanic;
</code></pre>
<h4 id="描述-12"><a class="header" href="#描述-12">描述</a></h4>
<p>使用给定状态计算输入的下一个 SHA-256 状态。</p>
<p>此系统调用通过将当前 <code>state</code> 与 512 位 <code>input</code> 数据块组合来计算下一个 SHA-256 状态。</p>
<h4 id="参数-11"><a class="header" href="#参数-11">参数</a></h4>
<ul>
<li><em><code>state</code></em>: 当前 SHA-256 状态。</li>
<li><em><code>input</code></em>: 要处理成 SHA-256 的值。</li>
</ul>
<h4 id="返回值-12"><a class="header" href="#返回值-12">返回值</a></h4>
<p>返回 <code>input</code> 数据的新 SHA-256 状态。</p>
<h4 id="公共库-12"><a class="header" href="#公共库-12">公共库</a></h4>
<ul>
<li><a href="https://github.com/starkware-libs/cairo/blob/3540731e5b0e78f2f5b1a51d3611418121c19e54/corelib/src/starknet/syscalls.cairo#L106">syscalls.cairo</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="sierra"><a class="header" href="#sierra">Sierra</a></h1>
<p>从 Starknet Alpha v0.11.0 开始，编译 Cairo 产生的合约类包含称为 Safe Intermediate Representation（简称 <em>Sierra</em>）的中间表示指令。然后，排序器通过 Sierra → Casm 编译器编译这个新合约类，以生成与此类关联的 Cairo 汇编。然后，Casm 代码由 Starknet OS 执行。</p>
<h2 id="为什么我们需要-casm"><a class="header" href="#为什么我们需要-casm">为什么我们需要 Casm？</a></h2>
<p>Starknet 是一个有效性 rollup (validity rollup)，这意味着每个区块内的执行都需要被证明，这就是 STARK 派上用场的地方。然而，STARK 证明只能处理用多项式约束语言表述的陈述，并且不了解智能合约的执行。为了克服这个差距，我们开发了 Cairo。</p>
<p>Cairo 指令（以前称为 Casm）被翻译成多项式约束，根据 <a href="https://github.com/starknet-io/starknet-stack-resources/blob/main/Cairo/Cairo%20%E2%80%93%20a%20Turing-complete%20STARK-friendly%20CPU%20architecture.pdf"><em>Cairo：图灵完备的 STARK 友好 CPU 架构</em></a> 中定义的 Cairo 语义强制执行程序的正确执行。</p>
<p>多亏了 Cairo，我们可以用一种我们可以证明的方式来表述“这个 Starknet 区块是有效的”这一陈述。请注意，我们只能证明关于 Casm 的事情。也就是说，无论用户向 Starknet 排序器发送什么，被证明的都是正确的 Casm 执行。</p>
<p>这意味着我们需要一种将 Sierra 翻译成 Casm 的方法，这通过 Sierra -&gt; Casm 编译器来实现。</p>
<h2 id="为什么我们需要-sierra"><a class="header" href="#为什么我们需要-sierra">为什么我们需要 Sierra？</a></h2>
<p>为了理解为什么我们选择在用户编写的代码和被证明的代码 (Casm) 之间添加一个额外的层，我们需要考虑系统中的更多组件，以及 Cairo 的局限性。</p>
<h3 id="撤销的交易不可满足的-air-和-dos-攻击"><a class="header" href="#撤销的交易不可满足的-air-和-dos-攻击">撤销的交易、不可满足的 AIR 和 DoS 攻击</a></h3>
<p>每个去中心化 L2 的一个关键属性是，排序器保证会因其所做的工作而获得报酬。撤销的交易 (reverted transactions) 是一个很好的例子：即使用户的交易在执行中途失败，排序器也应该能够将其包含在区块中，并收取直到失败点的执行费用。</p>
<p>如果排序器无法对此类交易收费，那么发送最终会失败（经过大量计算步骤后）的交易是对排序器的明显 DoS 攻击。排序器无法在不实际执行工作的情况下查看交易并断定它会失败（这等同于解决停机问题）。</p>
<p>上述困境的明显解决方案是将此类交易包含在区块中，类似于以太坊。然而，在有效性 rollup 中这可能并不容易做到。使用 Cairo Zero，在用户代码和被证明的内容之间没有分离层。</p>
<p>这意味着用户可以编写在某些情况下无法证明的代码。实际上，此类代码很容易编写，例如 <code>assert 0=1</code> 是一个有效的 Cairo 指令，无法被证明，因为它转换为不可满足的多项式约束。包含此指令的任何 Casm 执行都无法被证明。Sierra 是用户代码和可证明陈述之间的层，它使我们能够确保所有交易最终都是可证明的。</p>
<h3 id="安全-casm"><a class="header" href="#安全-casm">安全 Casm</a></h3>
<p>Sierra 保证用户代码始终可证明的方法是将 Sierra 指令编译为 Casm 的子集，我们称之为“安全 Casm”。我们对安全 Casm 的重要要求是它对所有输入都是可证明的。安全 Casm 的一个典型示例是使用 <code>if/else</code> 指令而不是 <code>assert</code>，即确保所有失败都是优雅的。</p>
<p>为了更好地理解设计 Sierra → Casm 编译器时的考虑因素，请考虑 Cairo Zero 公共库中的 <code>find_element</code> 函数：</p>
<pre><code>func find_element{range_check_ptr}(array_ptr: felt*, elm_size, n_elms, key) -&gt; (elm_ptr: felt*) {
    alloc_locals;
    local index;
    %{
        ...
    %}
    assert_nn_le(a=index, b=n_elms - 1);
    tempvar elm_ptr = array_ptr + elm_size * index;
    assert [elm_ptr] = key;
    return (elm_ptr=elm_ptr);
}
</code></pre>
<blockquote>
<p>下面我们滥用“Casm”符号，不区分 Cairo Zero 和 Casm，并将上述内容称为 Casm（虽然我们实际上指的是上述内容的编译结果）。</p>
</blockquote>
<p>为简洁起见，我们在上面的代码片段中省略了 hint，但很明显，只有在数组中存在请求的元素时，此函数才能正确执行（否则它将对每个可能的 hint 失败——我们无法用任何东西替换 <code>index</code>，使后续行成功运行）。</p>
<p>Sierra-&gt;Casm 编译器无法生成此类 Casm。此外，简单地将断言替换为 if/else 语句也不行，因为这会导致非确定性执行。也就是说，对于相同的输入，不同的 hint 值可能会产生不同的结果。恶意的证明者可以利用这种自由来伤害用户——在这个例子中，他们能够让它看起来好像一个元素不是数组的一部分，即使它实际上是。</p>
<p>用于在数组中查找元素的安全 Casm 在快乐流程（元素存在）中的行与上面的代码片段类似：hint 中给出一个索引，我们验证 hint 索引处的数组包含请求的元素。但是，在不快乐流程（元素不存在）中，我们 <em>必须</em> 遍历整个数组来验证这一点。</p>
<p>在 Cairo 0 中情况并非如此，因为我们可以接受某些路径不可证明（在上面的代码片段中，元素不在数组中的不快乐流程永远不可证明）。</p>
<blockquote>
<p>Sierra 的 gas 计量给上面的例子增加了更多的复杂性。即使遍历数组以验证元素不存在，也可能给证明者留下一些灵活性。</p>
</blockquote>
<p>如果我们考虑 gas 限制，用户可能有足够的 gas 用于快乐流程，但不足以用于不快乐流程，这使得执行在搜索中途停止，并允许证明者通过谎称元素不存在而逃脱惩罚。</p>
<p>我们计划处理此问题的方法是要求用户在实际调用 <code>find_element</code> 之前拥有足够的 gas 用于不快乐流程。</p>
<h3 id="cairo-中的-hints"><a class="header" href="#cairo-中的-hints">Cairo 中的 Hints</a></h3>
<p>使用 Cairo 编写的智能合约不能包含用户定义的 hints。这在 Cairo Zero 合约中已经是这样（只接受列入白名单的 hints），但在 Cairo 中，使用的 hints 由 Sierra → Casm 编译器确定的。由于此编译旨在确保仅生成“安全”的 Casm，因此没有空间容纳非编译器生成的 hints。</p>
<p>将来，原生 Cairo 可能包含类似于 Cairo 0 的 hint 语法，但它在 Starknet 智能合约中将不可用（Starknet 之上的 <a href="https://medium.com/starkware/fractal-scaling-from-l2-to-l3-7fe238ecfb4f">L3</a> 可能会使用此类功能）。请注意，目前这才不是 Starknet 路线图的一部分。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="简介-1"><a class="header" href="#简介-1">简介</a></h1>
<p>有没有想过你的 Cairo 程序是如何执行的？</p>
<p>首先，它们由 Cairo 编译器编译，然后由 Cairo 虚拟机 (Cairo Virtual Machine)，简称 <em>Cairo VM</em> 执行，生成执行跟踪 (trace)，证明者 (Prover) 使用该跟踪生成该执行的 STARK 证明。此证明稍后可由验证者 (Verifier) 验证。</p>
<p>接下来的章节将深入探讨 Cairo VM 的内部工作原理。我们将介绍其架构、内存模型和执行模型。接下来，我们将探讨内置函数 (builtins) 和提示 (hints)，它们的目的以及它们是如何工作的。最后，我们将看看运行器 (runner)，它负责协调 Cairo 程序的执行。</p>
<p>但首先，我们所说的“虚拟机”是什么意思？</p>
<h2 id="虚拟机"><a class="header" href="#虚拟机">虚拟机</a></h2>
<p>虚拟机 (VM) 是物理计算机的软件仿真。它们通过 API 提供完整的编程环境，其中包括正确执行其上程序所需的一切。</p>
<p>每个虚拟机 API 都包含一个指令集架构 (ISA) 来表达程序。它可以是与某些物理机器相同的指令集（例如 RISC-V），也可以是在 VM 中实现的专用指令集（例如 Cairo 汇编，CASM）。</p>
<p>那些模拟操作系统的被称为 <em>系统虚拟机</em>，例如 Xen 和 VMWare。我们这里对它们不感兴趣。</p>
<p>我们感兴趣的另一类是 <em>进程虚拟机</em>。它们提供单个用户级进程所需的环境。</p>
<p>最著名的进程 VM 可能是 Java 虚拟机 (JVM)。</p>
<ul>
<li>给定一个 Java 程序 <code>prgm.java</code>，它被编译成包含 <em>Java 字节码</em>（JVM 指令和元数据）的类 <code>prgm.class</code>。</li>
<li>JVM 验证字节码是否可以安全运行。</li>
<li>字节码要么被解释执行（慢），要么即时编译（JIT，快）为机器码。</li>
<li>如果使用 JIT，字节码在执行程序时被翻译成机器码。</li>
<li>Java 程序也可以通过称为 <em>提前编译</em> (AOT) 的过程直接编译为特定 CPU 架构（即机器码）。</li>
</ul>
<p>Cairo VM 也是一个进程 VM，类似于 JVM，但有一个显著的区别：Java 及其 JVM 专为（平台无关的）通用计算而设计，而 Cairo 及其 Cairo VM 专为（平台无关的）<em>可证明</em> 通用计算而设计。</p>
<ul>
<li>Cairo 程序 <code>prgm.cairo</code> 被编译成编译工件 <code>prgm.json</code>，其中包含 <em>Cairo 字节码</em>（编码的 CASM，Cairo 指令集和额外数据）。</li>
<li>如 <a href="#简介">简介</a> 中所见，Cairo Zero 直接编译为 CASM，而 Cairo 首先编译为 <em>Sierra</em>，然后再编译为 CASM 的安全子集。</li>
<li>Cairo VM <em>解释</em> 提供的 CASM 并生成程序执行的跟踪。</li>
<li>获得的跟踪数据可以提供给 Cairo Prover 以生成 STARK 证明，从而允许证明程序的正确执行。创建此 <em>有效性证明</em> 是 Cairo 的主要目的。</li>
</ul>
<p>这是一个高级流程图，显示了 Java 程序和 Cairo 程序如何使用各自的编译器和 VM 执行。其中包括 Cairo 程序的证明生成。</p>
<div align="center">
  <img src="java-cairo-execution-flow.png" alt="Java and Cairo execution flow" width="800px" />
</div>

<div align="center">
  <span class="caption">Java 和 Cairo 程序高级执行流程图</span>
</div>

<p>一个正在进行的项目，<a href="https://github.com/lambdaclass/cairo_native">Cairo Native</a> 致力于提供 Sierra 到机器码的编译，包括 JIT 和 AOT，用于执行 Cairo 程序。</p>
<p>尽管两个 VM 的高级流程相似，但它们的实际架构却截然不同：指令集、内存模型、Cairo 的非确定性和输出。</p>
<h2 id="参考资料-1"><a class="header" href="#参考资料-1">参考资料</a></h2>
<p>Michael L. Scott, in Programming Language Pragmatics, 2015</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="架构"><a class="header" href="#架构">架构</a></h1>
<p>Cairo 是一种对 STARK 友好的冯·诺依曼架构，能够为任意计算生成有效性证明。对 STARK 友好意味着 Cairo 的设计针对 STARK 证明系统进行了优化，同时保持与其他证明系统后端的兼容性。它实现了一个图灵完备的进程虚拟机。</p>
<p>Cairo 由三个主要组件组成：</p>
<ol>
<li>Cairo 编译器</li>
<li>Cairo 虚拟机 (CairoVM)</li>
<li>Cairo 证明者和验证者</li>
</ol>
<p>Cairo 编译器将 Cairo 源代码转换为 Cairo 字节码（编码指令和元数据）。编译器的输出通常被称为 <em>编译工件</em>。</p>
<p>CairoVM 实现理论上的 <em>Cairo 机器</em>，处理编译工件并执行指令以产生证明生成和验证所需的两个关键输出：<em>AIR (算术中间表示) 私有输入</em> (witness) 和 <em>AIR 公共输入</em>：</p>
<ul>
<li>AIR 私有输入包括 <em>执行跟踪</em>（或简称“跟踪”）和 <em>内存</em>。</li>
<li>AIR 公共输入包括 <em>初始和最终状态</em>（跟踪的第一项和最后一项）、<em>公共内存</em>（内存的一个子集）和执行的配置数据（例如布局）。</li>
</ul>
<p>证明者获取 AIR 的私有和公共输入以生成相应程序执行的证明。验证者随后可以根据证明和 AIR 公共输入异步验证证明的正确性。</p>
<p>不过，什么是 AIR？</p>
<h2 id="算术中间表示---air"><a class="header" href="#算术中间表示---air">算术中间表示 - AIR</a></h2>
<p>AIR 代表 <em>算术中间表示 (Arithmetic Intermediate Representation)</em>，这是一种算术化技术。算术化是每个证明系统的基础：STARK 使用 AIR，而其他证明系统可能依赖不同的技术（例如 R1CS、PLONKish 算术化）。它允许将计算陈述转换为一组多项式方程。这些多项式方程代表系统的约束：如果在遵循证明系统协议的同时它们都成立，则证明有效；否则无效。</p>
<p>在其核心，Cairo 是一组 AIR，代表 Cairo ISA 的图灵完备机器：<em>Cairo 机器</em>。这使得通过 Cairo 机器证明任何陈述（即任意代码）成为可能。</p>
<p>Cairo 机器抽象了为你想要证明的程序编写 AIR 的需要，并且 Cairo 作为一种语言，提供了使用 Cairo 机器的人类可读界面。</p>
<p>Cairo 机器的每个组件都有其对应的 AIR：CPU、内存、内置函数 (Builtins)…</p>
<p>好的 AIR 对证明生成和验证的性能至关重要。虽然有很多方法可以将计算陈述表达为多项式，但并非所有方法都同样有效。编写最佳 AIR 是性能的一个重要因素。</p>
<p>我们不会在这里进一步讨论 AIR，但很高兴知道 CairoVM 的目的是向 Cairo 证明者提供所需的输入，以便为给定的 Cairo 程序生成证明。简而言之，Cairo 证明者和验证者的工作是验证 Cairo AIR 定义的约束对于 CairoVM 输出是否成立。</p>
<h2 id="cairo-机器"><a class="header" href="#cairo-机器">Cairo 机器</a></h2>
<p>Cairo 机器是定义冯·诺依曼架构以证明任意计算的理论模型。</p>
<p>机器由两个核心模型定义：</p>
<ul>
<li>CPU，或执行模型 - 指令集架构 (ISA)</li>
<li>内存模型 - 非确定性只读内存</li>
</ul>
<p>执行模型通过三个关键组件指定 ISA：</p>
<ul>
<li>指令集</li>
<li>寄存器 (<code>pc</code>, <code>ap</code>, <code>fp</code>)</li>
<li>状态转换算法</li>
</ul>
<p>与 RISC-V 等通用 ISA 不同，Cairo 实现了其自己的专门针对证明生成和验证进行优化的 ISA——自定义零知识 ISA (ZK-ISA)。内存模型定义了 CPU 如何与内存交互。遵循冯·诺依曼架构原则，单个内存存储程序和指令数据。</p>
<p>Cairo 机器有两个版本：</p>
<ol>
<li><em>确定性机器</em>（由证明者使用）</li>
<li><em>非确定性机器</em>（由验证者使用）</li>
</ol>
<p>为什么有两个版本的 Cairo 机器，一个用于证明者，一个用于验证者？</p>
<h3 id="确定性和非确定性-cairo-机器"><a class="header" href="#确定性和非确定性-cairo-机器">确定性和非确定性 Cairo 机器</a></h3>
<p>确定性机器获取跟踪（状态序列）和整个内存（内存函数），并验证两个连续状态之间的转换是否有效。如果所有状态转换都有效，则返回 <code>accept</code>，否则返回 <code>reject</code>。这台机器不执行任何计算，它只断言跟踪及其内存的有效性。</p>
<p>非确定性机器依赖于确定性机器：它只获取初始状态、最终状态和部分内存函数（即公共内存），如果存在具有相同初始状态和最终状态的状态序列（跟踪）以及扩展部分内存（包括公共内存的整个内存）的内存函数被确定性机器接受，则返回 <code>accept</code>。</p>
<p>确定性机器允许证明者生成证明，而非确定性机器允许验证者以零知识的方式简洁地验证证明（某些数据可以对验证者保密）。</p>
<p>CairoVM 是该理论机器的实现，包括一些从其设计中受益的功能（<em>内置函数</em> 和 <em>提示</em>）。在 CairoVM 的各种实现中，我们称为 <em>Cairo Runner</em> 的是运行 Cairo 程序并生成证明所需的 AIR 输入的入口点。</p>
<p>当 Cairo 程序由 CairoVM 执行时，我们可以将内存模型视为一次写入 (Write-Once) 模型。</p>
<h4 id="回顾---两个-cairo-机器之间的区别"><a class="header" href="#回顾---两个-cairo-机器之间的区别">回顾 - 两个 Cairo 机器之间的区别</a></h4>
<p>我们可以在表格中回顾确定性 Cairo 机器和非确定性 Cairo 机器之间的主要区别。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th></th><th>确定性 Cairo 机器</th><th>非确定性 Cairo 机器</th></tr>
</thead>
<tbody>
<tr><td>用途</td><td>证明者</td><td>验证者</td></tr>
<tr><td>提示</td><td>执行</td><td>不知道它们</td></tr>
<tr><td>内存</td><td>完整内存</td><td>仅公共内存</td></tr>
<tr><td>跟踪</td><td>完整执行跟踪</td><td>仅初始和最终状态</td></tr>
</tbody>
</table>
</div>
<h2 id="cairo-虚拟机架构图"><a class="header" href="#cairo-虚拟机架构图">Cairo 虚拟机架构图</a></h2>
<p>下图表示 CairoVM 的架构，用于为证明系统生成 AIR 输入。</p>
<div align="center">
  <img src="cairo-vm-architecture.png" alt="CairoVM architecture" width="800px" />
</div>

<div style="break-before: page; page-break-before: always;"></div>
<h1 id="内存"><a class="header" href="#内存">内存</a></h1>
<p>在大多数计算系统中，内存主要用于在程序执行期间存储临时值。然而，在 CairoVM 中，内存模型通过定义如何在跟踪单元中记录内存访问，在证明生成中也发挥着至关重要的作用。为了优化证明生成，Cairo 的内存模型旨在有效地表示内存值，从而简化 STARK 证明过程。</p>
<p>在本章中，我们将探讨 Cairo 独特的内存模型，并研究其结构如何增强证明生成过程。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="非确定性只读内存"><a class="header" href="#非确定性只读内存">非确定性只读内存</a></h1>
<p>Cairo 白皮书指出，Cairo 使用非确定性只读内存模型。</p>
<p>让我们分解一下这两个核心属性：</p>
<ol>
<li><strong>非确定性 (Non-determinism)</strong></li>
</ol>
<ul>
<li>在 Cairo 中，非确定性指的是内存地址及其值不是由典型的内存管理系统确定的。相反，证明者断言存储在这些地址中的位置和值。例如，与其像传统的读写内存模型那样手动在特定地址写入和读取值，证明者断言在内存地址 x 处存储了值 7。这样，我们不需要显式检查值 7 是否存在于地址 x。</li>
</ul>
<ol start="2">
<li><strong>只读 (Read-only)</strong></li>
</ol>
<ul>
<li>这意味着当 Cairo 程序运行时，内存中的值不会改变。</li>
</ul>
<p>这两个属性有效地使内存模型成为一次写入 (write-once) 内存模型。一旦将值分配给内存地址，就不能覆盖它。后续操作仅限于读取或验证该地址处的值。此外，内存地址空间是连续的，这意味着如果程序访问内存地址 x 和 y，它不能跳过中间的地址。</p>
<p>这种方法与以太坊虚拟机 (EVM) 等其他虚拟机有很大不同，后者使用读写内存模型。相比之下，Cairo 的内存模型优先考虑证明生成的效率。结果是，每次内存访问只需要 5 个跟踪单元。</p>
<p>另一种思考方式是，使用 Cairo 内存的有效成本来自内存访问的次数，而不是使用的内存地址的数量。因此，重写到现有的内存单元会产生与写入新单元类似的成本。</p>
<p>这种内存模型对于证明程序的正确性特别有用。当内存值只能设置一次时，描述对内存值的约束更容易，而不是在读写内存模型上表达相同的约束，因为在读写内存模型中，内存单元的值取决于“执行时间”。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="段-segments-介绍"><a class="header" href="#段-segments-介绍">段 (Segments) 介绍</a></h1>
<p>Cairo 确保分配的内存在写入后保持不可变，同时允许在运行时动态扩展内存段。所有这些都是通过将内存地址组织成 <strong>段 (segments)</strong> 来实现的。</p>
<p>将内存地址组织成段的过程如下：</p>
<ol>
<li>
<p>在运行时，它将分配的内存地址分组为具有唯一段标识符和偏移量的段，以指示属于每个段的内存地址的延续，即 <code>&lt;segment_id&gt;:&lt;offset&gt;</code>。我们标记给每个内存地址的这个临时值称为 <strong>可重定位值 (relocatable value)</strong>。</p>
</li>
<li>
<p>在执行结束时，可重定位值被转换为单个连续的内存地址空间，并创建一个单独的 <strong>重定位表 (relocation table)</strong> 来为线性内存地址空间提供上下文。</p>
</li>
</ol>
<h2 id="段值"><a class="header" href="#段值">段值</a></h2>
<p>Cairo 的内存模型包含以下段：</p>
<ul>
<li><strong>程序段 (Program Segment)</strong> = 存储 Cairo 程序的字节码。另一种说法是它存储 Cairo 程序的指令。程序计数器 <code>pc</code> 从此段的开头开始。</li>
<li><strong>执行段 (Execution Segment)</strong> = 存储执行 Cairo 程序时的任何数据（临时变量、函数调用帧和指针）。分配指针 <code>ap</code> 和帧指针 <code>fp</code> 从此段开始。</li>
<li><strong>内置函数段 (Builtin Segment)</strong> = 存储 Cairo 程序正在使用的内置函数。每个 Cairo 内置函数都有自己专用的段，根据程序中使用的内置函数动态分配。查看 <a href="#内置函数-builtins">内置函数部分</a> 以了解有关各个内置函数的更多信息。</li>
<li><strong>用户段 (User Segment)</strong> = 存储程序输出、数组和动态分配的数据结构。</li>
</ul>
<p><em>除了程序段之外，每个段都有一个动态地址空间，这意味着分配的内存地址空间的长度在程序完成执行之前是未知的。程序段是一个例外，因为它用于存储 Cairo 程序的字节码，该字节码在执行期间具有固定大小。</em></p>
<h2 id="段布局"><a class="header" href="#段布局">段布局</a></h2>
<p>Cairo 内存的布局按以下顺序按段排序：</p>
<ol>
<li><strong>Segment 0</strong> = 程序段</li>
<li><strong>Segment 1</strong> = 执行段</li>
<li><strong>Segment 2 到 x</strong> = 内置函数段</li>
<li><strong>Segment x + 1 到 y</strong> = 用户段</li>
</ol>
<p><em>内置函数段和用户段的数量是动态的，取决于程序的类型。</em></p>
<h1 id="重定位"><a class="header" href="#重定位">重定位</a></h1>
<p>为了理解如何在 Cairo 程序的整个执行过程中处理内存的整体过程，我们将看一个 Cairo Zero 程序的示例，以及它的段如何在运行时使用可重定位值定义，以及内存地址如何在执行结束时重定位到一个连续的内存地址空间。</p>
<p><strong>Cairo Zero 程序：</strong></p>
<pre><code class="language-cairo">%builtins output

func main(output_ptr: felt*) -&gt; (output_ptr: felt*) {

    // We are allocating three different values to segment 1.
    [ap] = 10, ap++;
    [ap] = 100, ap++;
    [ap] = [ap - 2] + [ap - 1], ap++;

    // We set value of output_ptr to the address of where the output will be stored.
    // This is part of the output builtin requirement.
    [ap] = output_ptr, ap++;

    // Asserts that output_ptr equals to 110.
    assert [output_ptr] = 110;

    // Returns the output_ptr + 1 as the next unused memory address.
    return (output_ptr=output_ptr + 1);
}
</code></pre>
<p><em>输出内置函数允许将最终输出存储在新段中。</em></p>
<p>Cairo Zero 程序存储三个值，即 <code>10</code>、<code>100</code> 和 <code>110</code>（<code>10</code> 和 <code>100</code> 相加），这些值存储在段 1 下的三个不同内存地址中。</p>
<p>使用输出内置函数，最终输出存储在段 2 中的一个新段中。</p>
<p><strong>可重定位值如下：</strong></p>
<pre><code>Addr  Value
-----------

// Segment 0

0:0   5189976364521848832
0:1   10
0:2   5189976364521848832
0:3   100
0:4   5201798304953696256
0:5   5191102247248822272
0:6   5189976364521848832
0:7   110
0:8   4612389708016484351
0:9   5198983563776458752
0:10  1
0:11  2345108766317314046
⋮
// Segment 1

1:0   2:0
1:1   3:0
1:2   4:0
1:3   10
1:4   100
1:5   110
1:6   2:0
1:7   110
1:8   2:1
⋮
// Segment 2

2:0   110

</code></pre>
<p>一旦程序完成执行，在重定位表的帮助下，可重定位值将变成一个连续的内存地址空间，以便为线性内存地址空间提供上下文。</p>
<p><strong>从重定位值到一个连续的内存地址空间：</strong></p>
<pre><code>Addr  Value
-----------
1     5189976364521848832
2     10
3     5189976364521848832
4     100
5     5201798304953696256
6     5191102247248822272
7     5189976364521848832
8     110
9     4612389708016484351
10    5198983563776458752
11    1
12    2345108766317314046
13    22
14    23
15    23
16    10
17    100
18    110
19    22
20    110
21    23
22    110
</code></pre>
<p><strong>重定位表：</strong></p>
<pre><code>segment_id  starting_index
----------------------------
0            1
1            13
2            22
3            23
4            23
</code></pre>
<p>重定位表通过用自己的起始索引标记段标识符，为证明者提供新段从哪个索引开始的上下文。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="执行模型"><a class="header" href="#执行模型">执行模型</a></h1>
<p>Cairo VM 的 CPU 架构定义了 VM 如何处理指令并更改其状态。它直接类比于物理计算机中的中央处理器 (CPU)。在 Cairo VM 中，CPU 遵循冯·诺依曼架构的原则，即程序指令和数据都驻留在同一内存空间中。VM 的执行模型实现为一个重复循环，称为 <strong>获取-解码-执行循环 (fetch-decode-execute cycle)</strong>，它规定了机器如何从一个状态前进到下一个状态。</p>
<p>执行模型由其寄存器、唯一的指令集架构和 VM 的状态转换函数定义。</p>
<h2 id="寄存器"><a class="header" href="#寄存器">寄存器</a></h2>
<p>在任何 CPU 架构中，寄存器都是小型的、高速的存储位置，用于保存处理时最急需的数据。Cairo VM 有三个专用寄存器，用于管理程序的流程和内存上下文。VM 在任何给定时刻的状态完全由这三个寄存器的值定义，这些值是经过证明的执行跟踪的一部分。</p>
<ul>
<li><strong><code>pc</code> (程序计数器)</strong> 保存要获取和执行的下一条指令的内存地址。在大多数指令之后，它会递增以指向下一条指令，但跳转和调用指令可以直接修改它以从不同的指令继续。</li>
<li><strong><code>ap</code> (分配指针)</strong> 用作堆栈指针，通常指向下一个空闲（未写入）的内存单元。许多指令将 <code>ap</code> 增加 1，但这通常不是强制的。</li>
<li><strong><code>fp</code> (帧指针)</strong> 为当前函数的执行上下文或“堆栈帧”提供稳定的参考点。当调用函数时，<code>fp</code> 设置为 <code>ap</code> 的当前值。这允许函数可靠地访问其参数及其返回地址，这些参数和返回地址位于相对于 <code>fp</code> 的固定负偏移量处，而不管使用 <code>ap</code> 在堆栈上分配了多少局部变量。</li>
</ul>
<h2 id="指令和操作码"><a class="header" href="#指令和操作码">指令和操作码</a></h2>
<p>Cairo <strong>指令</strong> 是单个步骤的完整计算单元，编码为 64 位 field 元素。这个单词包含三个 16 位有符号偏移量 (<code>off_dst</code>, <code>off_op0</code>, <code>off_op1</code>) 和 15 个不同的布尔标志，用于了解使用哪些寄存器进行寻址、执行什么算术运算以及如何为下一个状态更新 <code>pc</code>、<code>ap</code> 和 <code>fp</code> 寄存器。</p>
<p>这三个偏移量确定指令相对于寄存器读取/写入哪些内存单元。15 个标志编码要执行的操作以及如何更新寄存器。例如，标志组包括 <code>dst_reg</code>（是将结果写入 <code>fp</code>、<code>ap</code> 还是 <code>pc</code>）、<code>op0_reg</code>/<code>op1_reg</code>（操作数是来自 <code>fp</code>、<code>ap</code> 还是立即数）、算术/逻辑运算以及跳转控制。</p>
<p>虽然 Cairo VM 中有许多不同的指令，但 VM 本身仅支持三个操作码：</p>
<ol>
<li><strong><code>CALL</code></strong>: 启动函数调用，将当前上下文（<code>fp</code> 和返回 <code>pc</code>）保存到堆栈。</li>
<li><strong><code>RET</code></strong>: 执行函数返回，从堆栈恢复调用者的上下文。</li>
<li><strong><code>ASSERT_EQ</code></strong>: 强制执行相等约束。</li>
</ol>
<h2 id="cairo-汇编-casm"><a class="header" href="#cairo-汇编-casm">Cairo 汇编 (CASM)</a></h2>
<p>CASM 是 Cairo 的人类可读汇编语言。它是机器指令的直接文本表示。开发人员使用高级 Cairo 语言编写逻辑，编译器的最后一步是将此逻辑转换为 CASM 指令序列。但是，也可以手写 CASM 指令。每一行有效的 CASM，例如 <code>[fp + 1] = [ap - 2] + 5</code> 或 <code>jmp rel 17 if [ap] != 0</code>，都对应于特定的指令。</p>
<h2 id="状态转换"><a class="header" href="#状态转换">状态转换</a></h2>
<p>Cairo VM 在任何步骤 (i) 的状态完全由元组 ((pc_i, ap_i, fp_i)) 捕获。<strong>状态转换函数</strong> 是一组确定性的规则，它根据当前状态和从内存中获取的指令计算下一个状态 ((pc_{i+1}, ap_{i+1}, fp_{i+1}))。此过程完美地反映了物理 CPU 的经典获取-解码-执行循环。</p>
<p>整个循环，从获取指令到断言其正确性并更新寄存器，是 Cairo VM 中的单个原子步骤。此过程是编码到 Cairo AIR 的多项式约束中的一部分，保证程序执行的每一步都遵守 VM 的规则并且可以被证明。</p>
<p>从概念上讲，每个步骤检查一条指令并将其语义强制为代数约束。例如，典型指令将从地址 <code>pc + off_op0</code> 和 <code>pc + off_op1</code>（相对于寄存器）处的内存加载值，计算结果（加、乘、减），然后将其写入地址 <code>pc + off_dst</code> 处的内存。它还将设置下一个 <code>pc</code>，可能会增加 <code>ap</code>，并保持 <code>fp</code> 不变或在函数调用返回时恢复它。</p>
<p>这些规则是完全确定性的：给定当前状态和内存，Cairo VM 恰好有一个有效的下一个状态。关键点在于，对于每条指令，AIR 中都存在一组必须满足的代数约束。如果在任何步骤无法满足约束（例如，VM 执行非法状态转换），则无法证明执行。</p>
<p>相反，如果所有步骤都通过，那么就有可能从该执行中生成证明。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="内置函数-builtins"><a class="header" href="#内置函数-builtins">内置函数 (Builtins)</a></h1>
<p>Cairo 白皮书将内置函数定义为“预定义的优化低级执行单元”。</p>
<p>换句话说，内置函数是嵌入在 Cairo 架构中的逻辑块，与使用 Cairo 指令集定义相同的逻辑相比，它可以显著增强性能。</p>
<p>内置函数可以比作以太坊预编译 (precompiles)，即用客户端的实现语言实现的原始操作，而不是使用 EVM 操作码。</p>
<p>Cairo 架构没有指定一组特定的内置函数，它们可以根据我们的需要添加或删除，这就是存在不同布局的原因。内置函数向 CPU AIR 添加约束，这将增加验证时间。</p>
<p>在本章中，我们将了解内置函数如何工作、存在的内置函数及其用途。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="内置函数如何工作"><a class="header" href="#内置函数如何工作">内置函数如何工作</a></h1>
<p>内置函数对 Cairo 内存强制执行某些约束以执行特定任务，例如计算哈希。</p>
<p>每个内置函数都在专用的内存段上工作，该内存段最终代表固定的地址范围。这种通信方法称为 <em>内存映射 I/O</em>：专用于内置函数的特定内存地址范围。</p>
<p>为了让 Cairo 程序与内置函数交互，它只需要读取或写入相应的内存单元。</p>
<p>我们称之为 <em>验证属性</em> 和 <em>推导属性</em> 的内置函数约束主要有两种类型。具有推导属性的内置函数通常被分成通过验证属性约束某些单元的单元块。</p>
<p>如果定义的属性不成立，则 Cairo VM 将 panic。</p>
<h2 id="验证属性"><a class="header" href="#验证属性">验证属性</a></h2>
<p>验证属性定义了值必须满足的约束，才能将其写入内置函数内存单元。</p>
<p>例如，<em>范围检查 (Range Check)</em> 内置函数仅接受 felt，并验证该 felt 是否在 <code>[0, 2**128)</code> 范围内。只有当这两个约束成立时，程序才能将值写入范围检查内置函数。这两个约束代表范围检查内置函数的验证属性。</p>
<div align="center">
  <img src="range-check-validation-property.png" alt="Diagram snapshot Cairo memory using the Range Check builtin" width="800px" />
</div>

<div align="center">
  <span class="caption">使用范围检查内置函数的 Cairo VM 内存图</span>
</div>

<h2 id="推导属性"><a class="header" href="#推导属性">推导属性</a></h2>
<p>推导属性在读取或写入单元时定义对单元块的约束。</p>
<p>一个单元块有两类单元：</p>
<ul>
<li><em>输入单元</em> - 程序可以写入的单元，它们的约束类似于验证属性。</li>
<li><em>输出单元</em> - 程序必须读取的单元，其值是基于推导属性和输入单元值计算的。</li>
</ul>
<p>仅写入输入单元而从未读取输出单元的程序，只要这些单元上的约束成立，就是有效的。虽然，它是无用的。</p>
<p>例如，<em>Pedersen</em> 内置函数使用三元组单元：</p>
<ul>
<li>两个输入单元存储两个 felt，<code>a</code> 和 <code>b</code>。</li>
<li>一个输出单元将存储 <code>Pedersen(a, b)</code>。</li>
</ul>
<p>要计算 <code>a</code> 和 <code>b</code> 的 Pedersen 哈希，程序必须：</p>
<ul>
<li>将 <code>a</code> 写入第一个单元</li>
<li>将 <code>b</code> 写入第二个单元</li>
<li>读取第三个单元，它将计算并将 <code>Pedersen(a, b)</code> 写入其中。</li>
</ul>
<p>在下图中，使用了 Pedersen 内置函数，突出了其推导属性：在将其值写入单元 <code>1:5</code> 时读取输出单元 <code>2:2</code>。</p>
<div align="center">
  <img src="pedersen-deduction-property.png" alt="Diagram of Cairo VM memory Pedersen builtins" width="800px" />
</div>

<div align="center">
  <span class="caption">使用 Pedersen 内置函数的 Cairo VM 内存图</span>
</div>

<div style="break-before: page; page-break-before: always;"></div>
<h1 id="内置函数列表"><a class="header" href="#内置函数列表">内置函数列表</a></h1>
<p>下表列出了 Cairo VM 中实现的不同内置函数，并简要说明了它们的用途。对于每个内置函数，都有一个特定部分详细介绍其工作原理、单元格组织（如果有）以及它们在 Cairo VM 的不同实现中的实际实现的参考。</p>
<p>如果相关，还提供了与内置函数执行的操作相关的其他资源。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>内置函数</th><th>描述</th></tr>
</thead>
<tbody>
<tr><td><a href="#输出内置函数-output-builtin">Output</a></td><td>存储生成 STARK 证明所需的所有公共内存（输入和输出值、内置指针…）</td></tr>
<tr><td><a href="#pedersen-内置函数">Pedersen</a></td><td>计算两个 felt <code>a</code> 和 <code>b</code> 的 Pedersen 哈希 <code>h</code>。<code>h = Pedersen(a, b)</code></td></tr>
<tr><td><a href="#范围检查内置函数-range-check-builtin">Range Check</a></td><td>验证 felt <code>x</code> 是否在边界 <code>[0, 2**128)</code> 内。</td></tr>
<tr><td><a href="#ecdsa-内置函数">ECDSA</a></td><td>验证给定公钥 <code>pub</code> 对消息 <code>m</code> 的 ECDSA 签名是否等于之前存储的 <code>sig</code>。仅由 Cairo Zero 使用。</td></tr>
<tr><td><a href="#按位运算内置函数-bitwise-builtin">Bitwise</a></td><td>计算两个 felt <code>a</code> 和 <code>b</code> 的按位与、异或和或。<code>a &amp; b</code>、<code>a ^ b</code> 和 <code>a | b</code>。</td></tr>
<tr><td><a href="#ec-op-内置函数">EC OP</a></td><td>执行椭圆曲线操作 - 对于 STARK 曲线上的两个点 <code>P</code>、<code>Q</code> 和一个标量 <code>m</code>，计算 <code>R = P + mQ</code>。</td></tr>
<tr><td><a href="#keccak-内置函数">Keccak</a></td><td>在给定状态 <code>s</code> 上应用 24 轮 keccak-f1600 块排列后计算新状态 <code>s'</code>。</td></tr>
<tr><td><a href="#poseidon-内置函数">Poseidon</a></td><td>在给定状态 <code>s</code> 上应用 91 轮 hades 块排列后计算新状态 <code>s'</code>。</td></tr>
<tr><td><a href="ch204-02-08-range-check-96.html">Range Check96</a></td><td>验证 felt <code>x</code> 是否在边界 <code>[0, 2**96)</code> 内。</td></tr>
<tr><td><a href="ch204-02-09-add-mod.html">AddMod</a></td><td>算术电路支持 - 分批计算两个 felt <code>a</code>、<code>b</code> 的模加法 <code>c</code>。<code>c ≡ a + b mod(p)</code></td></tr>
<tr><td><a href="ch204-02-10-mul-mod.html">MulMod</a></td><td>算术电路支持 - 分批计算两个 felt <code>a</code>、<code>b</code> 的模乘法 <code>c</code>。<code>c ≡ a * b mod(p)</code></td></tr>
<tr><td><a href="#segment-arena-内置函数">Segment Arena</a></td><td>管理 Cairo 字典。在 Cairo Zero 中不使用。</td></tr>
<tr><td><a href="ch204-02-12-gas.html">Gas</a></td><td>管理运行期间的可用 gas。Starknet 用它来处理其 gas 使用并避免 DoS。</td></tr>
<tr><td><a href="ch204-02-13-system.html">System</a></td><td>管理 Starknet 系统调用和作弊码 (cheatcodes)。</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="输出内置函数-output-builtin"><a class="header" href="#输出内置函数-output-builtin">输出内置函数 (Output Builtin)</a></h1>
<p>在 Cairo 虚拟机 (VM) 中，<strong>输出内置函数</strong> 是一个内置组件，它通过 <code>output_ptr</code> 管理内存的输出段。它被用作 Cairo 程序执行与外部世界之间的桥梁，使用 <strong>公共内存</strong> 来产生可验证的输出。</p>
<p>以 <code>output_ptr</code> 表示，输出内置函数处理程序写入其输出的专用内存区域。它的主要作用是存储任何必须在证明系统中可用于验证的值，我们称之为 <strong>公共内存</strong>。随着程序写入值，该段会增长。</p>
<h2 id="内存组织"><a class="header" href="#内存组织">内存组织</a></h2>
<p>输出段是从基地址开始的连续单元块。输出段中的所有单元本质上都是公开的，验证者可以访问。它的交互非常简单：它可以被写入和读取，没有任何特定要求。</p>
<h2 id="在-stark-证明中的作用"><a class="header" href="#在-stark-证明中的作用">在 STARK 证明中的作用</a></h2>
<p>输出内置函数与公共内存的集成对于 STARK 证明的构造和验证是必需的：</p>
<ol>
<li><strong>公共承诺 (Public Commitment)</strong>：写入 <code>output_ptr</code> 的值成为公共内存的一部分，在证明中承诺程序输出这些值。</li>
<li><strong>证明结构</strong>：输出段包含在跟踪的公共输入中，其边界被跟踪（例如，<code>begin_addr</code> 和 <code>stop_ptr</code>）以进行验证。</li>
<li><strong>验证过程</strong>：验证者提取并哈希输出段。通常，输出段中的所有单元被一起哈希，创建一个承诺，允许在不重新执行的情况下进行有效验证。</li>
</ol>
<h2 id="实现参考"><a class="header" href="#实现参考">实现参考</a></h2>
<p>以下是各种 Cairo VM 实现中输出内置函数的实现参考：</p>
<ul>
<li><a href="https://github.com/kkrt-labs/cairo-vm-ts/blob/main/src/builtins/output.ts#L4">TypeScript Output Builtin</a></li>
<li><a href="https://github.com/starkware-libs/cairo-lang/blob/0e4dab8a6065d80d1c726394f5d9d23cb451706a/src/starkware/cairo/lang/vm/output_builtin_runner.py">Python Output Builtin</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="pedersen-内置函数"><a class="header" href="#pedersen-内置函数">Pedersen 内置函数</a></h1>
<p><em>Pedersen</em> 内置函数专门用于计算两个 field 元素 (felts) 的 Pedersen 哈希。它在 Cairo VM 中提供了此加密哈希函数的高效原生实现。有关在 Cairo 程序中使用哈希的指南，请参阅第 11.4 节 <a href="#哈希-hashes">使用哈希</a>。</p>
<h2 id="单元格组织"><a class="header" href="#单元格组织">单元格组织</a></h2>
<p>在 Cairo VM 运行期间，Pedersen 内置函数拥有自己专用的段。它遵循推导属性模式，并以 <em>单元格三元组</em> 的形式组织——两个输入单元格和一个输出单元格：</p>
<ul>
<li><strong>输入单元格</strong>：必须存储 field 元素 (felts)；禁止使用可重定位值（指针）。此限制是有道理的，因为在这种情况下，计算内存地址的哈希没有明确定义。</li>
<li><strong>输出单元格</strong>：该值是从输入单元格推导出来的。当指令尝试读取此单元格时，VM 会计算两个输入单元格的 Pedersen 哈希，并将结果写入输出单元格。</li>
</ul>
<p>让我们检查 Cairo VM 执行程序期间 Pedersen 段的两个快照：</p>
<p>在第一个快照中，我们看到两个处于不同状态的三元组：</p>
<div align="center">
  <img src="pedersen-builtin-valid.png" alt="valid pedersen builtin segment" width="300px" />
</div>

<div align="center">
  <span class="caption">快照 1 - 具有有效输入的 Pedersen 内置函数段</span>
</div>

<ul>
<li><strong>第一个三元组</strong> (单元格 3:0, 3:1, 3:2)：所有三个单元格都包含 felt。单元格 3:2 (输出) 中的值已被计算，因为在程序执行期间读取了该单元格，这触发了输入 15 和 35 的 Pedersen 哈希计算。</li>
<li><strong>第二个三元组</strong> (单元格 3:3, 3:4, 3:5)：只有输入单元格被值 93 和 5 填充。输出单元格 3:5 仍然为空，因为它尚未被读取，因此尚未计算 93 和 5 的 Pedersen 哈希。</li>
</ul>
<p>在第二个快照中，我们看到两种在尝试读取输出单元格时会导致错误的情况：</p>
<div align="center">
  <img src="pedersen-builtin-error.png" alt="Invalid pedersen builtin segment" width="300px" />
</div>

<div align="center">
  <span class="caption">快照 2 - 具有无效输入的 Pedersen 内置函数段</span>
</div>

<ol>
<li>
<p><strong>第一个三元组</strong>：读取单元格 3:2 会抛出错误，因为其中一个输入单元格 (3:0) 为空。VM 无法在缺少输入数据的情况下计算哈希。</p>
</li>
<li>
<p><strong>第二个三元组</strong>：读取单元格 3:5 会抛出错误，因为其中一个输入单元格 (3:4) 包含指向单元格 1:7 的可重定位值。Pedersen 内置函数只能对 field 元素进行哈希，而不能对内存地址进行哈希。</p>
</li>
</ol>
<p>由于这些错误仅在读取输出单元格时才会显现。对于第二种情况，更健壮的实现可以在写入输入单元格时对其进行验证，立即拒绝可重定位值，而不是等到尝试计算哈希时。</p>
<h2 id="实现参考-1"><a class="header" href="#实现参考-1">实现参考</a></h2>
<p>以下是各种 Cairo VM 实现中 Pedersen 内置函数的实现参考：</p>
<ul>
<li><a href="https://github.com/kkrt-labs/cairo-vm-ts/blob/main/src/builtins/pedersen.ts#L4">TypeScript Pedersen Builtin</a></li>
<li><a href="https://github.com/starkware-libs/cairo-lang/blob/0e4dab8a6065d80d1c726394f5d9d23cb451706a/src/starkware/cairo/lang/builtins/hash/hash_builtin_runner.py">Python Pedersen Builtin</a></li>
<li><a href="https://github.com/lambdaclass/cairo-vm/blob/41476335884bf600b62995f0c005be7d384eaec5/vm/src/vm/runners/builtin_runner/hash.rs">Rust Pedersen Builtin</a></li>
<li><a href="https://github.com/keep-starknet-strange/ziggy-starkdust/blob/55d83e61968336f6be93486d7acf8530ba868d7e/src/vm/builtins/builtin_runner/hash.zig">Zig Pedersen Builtin</a></li>
</ul>
<h2 id="关于-pedersen-哈希的资源"><a class="header" href="#关于-pedersen-哈希的资源">关于 Pedersen 哈希的资源</a></h2>
<p>如果你对 Pedersen 哈希函数及其在密码学中的应用感兴趣：</p>
<ul>
<li>StarkNet,
<a href="https://docs.starknet.io/architecture-and-concepts/cryptography/hash-functions/#pedersen-hash">Hash Functions - Pedersen Hash</a></li>
<li>nccgroup,
<a href="https://research.nccgroup.com/2023/03/22/breaking-pedersen-hashes-in-practice/">Breaking Pedersen Hashes in Practice</a>,
2023, March 22</li>
<li>Ryan S.,
<a href="https://rya-sge.github.io/access-denied/2024/05/07/pedersen-hash-function/">Pedersen Hash Function Overview</a>,
2024, May 07</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="范围检查内置函数-range-check-builtin"><a class="header" href="#范围检查内置函数-range-check-builtin">范围检查内置函数 (Range Check Builtin)</a></h1>
<p><em>范围检查</em> 内置函数验证 field 元素是否落在特定范围内。此内置函数是 Cairo 整数类型和比较的基础，确保存值满足有界约束。</p>
<p>此内置函数存在两种变体：</p>
<ul>
<li>标准范围检查：验证范围 \([0, 2^{128}-1]\) 内的值</li>
<li>范围检查 96：验证范围 \([0, 2^{96}-1]\) 内的值</li>
</ul>
<p>本节重点介绍标准变体，但相同的原则适用于两者。</p>
<h2 id="目的和重要性"><a class="header" href="#目的和重要性">目的和重要性</a></h2>
<p>虽然可以使用纯 Cairo 代码实现范围检查（例如，通过将数字分解为其二进制表示并验证每个位），但使用内置函数的效率要高得多。纯 Cairo 实现至少需要 384 条指令来验证单个范围检查，而内置函数通过相当于约 1.5 条指令的计算成本即可实现相同的结果。这种效率使得范围检查内置函数对于实现有界整数算术和其他需要值范围验证的操作至关重要。</p>
<h2 id="单元格组织-1"><a class="header" href="#单元格组织-1">单元格组织</a></h2>
<p>范围检查内置函数在具有验证属性模式的专用内存段上运行：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>特征</th><th>描述</th></tr>
</thead>
<tbody>
<tr><td>有效值</td><td>范围 \([0, 2^{128}-1]\) 内的 field 元素</td></tr>
<tr><td>错误条件</td><td>值 ≥ 2^128 或可重定位地址</td></tr>
<tr><td>验证时机</td><td>立即（在单元格写入时）</td></tr>
</tbody>
</table>
</div>
<p>与具有推导属性的内置函数不同，范围检查内置函数在写入时而不是读取时验证值。这种立即验证为超出范围的值提供了早期错误检测。</p>
<h3 id="有效操作示例"><a class="header" href="#有效操作示例">有效操作示例</a></h3>
<div align="center">
  <img src="range-check-builtin-valid.png" alt="valid range_check builtin segment" width="300px" />
</div>

<div align="center">
  <span class="caption">具有有效值的范围检查内置函数段</span>
</div>

<p>在此示例中，程序成功向范围检查段写入三个值：</p>
<ul>
<li><code>0</code>：允许的最小值</li>
<li><code>256</code>：典型的小整数值</li>
<li><code>2^128-1</code>：允许的最大值</li>
</ul>
<p>这三个值都在允许的范围 \([0, 2^{128}-1]\) 内，因此操作成功。</p>
<h3 id="超出范围错误示例"><a class="header" href="#超出范围错误示例">超出范围错误示例</a></h3>
<div align="center">
  <img src="range-check-builtin-error1.png" alt="invalid range_check builtin segment" width="300px" />
</div>

<div align="center">
  <span class="caption">范围检查错误：值超出最大范围</span>
</div>

<p>在此示例中，程序尝试将 <code>2^128</code> 写入单元格 <code>2:2</code>，这超出了允许的最大值。VM 立即抛出超出范围错误并中止执行。</p>
<h3 id="无效类型错误示例"><a class="header" href="#无效类型错误示例">无效类型错误示例</a></h3>
<div align="center">
  <img src="range-check-builtin-error2.png" alt="invalid range_check builtin segment" width="300px" />
</div>

<div align="center">
  <span class="caption">范围检查错误：值是可重定位地址</span>
</div>

<p>在此示例中，程序尝试将可重定位地址（指向单元格 <code>1:7</code> 的指针）写入范围检查段。由于内置函数仅接受 field 元素，VM 抛出错误并中止执行。</p>
<h2 id="实现参考-2"><a class="header" href="#实现参考-2">实现参考</a></h2>
<p>以下是各种 Cairo VM 实现中范围检查内置函数的实现参考：</p>
<ul>
<li><a href="https://github.com/kkrt-labs/cairo-vm-ts/blob/main/src/builtins/rangeCheck.ts">TypeScript Range Check Builtin</a></li>
<li><a href="https://github.com/starkware-libs/cairo-lang/blob/0e4dab8a6065d80d1c726394f5d9d23cb451706a/src/starkware/cairo/lang/builtins/range_check/range_check_builtin_runner.py">Python Range Check Builtin</a></li>
<li><a href="https://github.com/lambdaclass/cairo-vm/blob/41476335884bf600b62995f0c005be7d384eaec5/vm/src/vm/runners/builtin_runner/range_check.rs">Rust Range Check Builtin</a></li>
<li><a href="https://github.com/keep-starknet-strange/ziggy-starkdust/blob/55d83e61968336f6be93486d7acf8530ba868d7e/src/vm/builtins/builtin_runner/range_check.zig">Zig Range Check Builtin</a></li>
</ul>
<h2 id="关于范围检查的资源"><a class="header" href="#关于范围检查的资源">关于范围检查的资源</a></h2>
<p>如果你对范围检查内置函数的工作原理及其在 Cairo VM 中的使用感兴趣：</p>
<ul>
<li>Starknet,
<a href="https://docs.cairo-lang.org/how_cairo_works/builtins.html#range-checks">CairoZero documentation, Range Checks section of Builtins and implicit arguments</a></li>
<li>Lior G., Shahar P., Michael R.,
<a href="https://eprint.iacr.org/2021/1063.pdf">Cairo Whitepaper, Sections 2.8 and 8</a></li>
<li><a href="https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/cairo/common/math.cairo">StarkWare Range Check implementation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ecdsa-内置函数"><a class="header" href="#ecdsa-内置函数">ECDSA 内置函数</a></h1>
<p><em>ECDSA</em>（椭圆曲线数字签名算法）内置函数验证 STARK 曲线上的加密签名。此内置函数主要用于验证消息哈希是否由特定私钥的持有者签名。</p>
<h2 id="内存组织-1"><a class="header" href="#内存组织-1">内存组织</a></h2>
<p>ECDSA 内置函数具有独特的内存结构，包含两个相互连接的组件：</p>
<ol>
<li><strong>内存段</strong>：一个专用段，将公钥和消息哈希存储为 field 元素</li>
<li><strong>签名字典</strong>：一个映射，将公钥偏移量与其对应的签名相关联</li>
</ol>
<h3 id="内存段中的单元格布局"><a class="header" href="#内存段中的单元格布局">内存段中的单元格布局</a></h3>
<p>ECDSA 段成对排列单元格：</p>
<ul>
<li><strong>偶数偏移量</strong> (0, 2, 4, …) 存储公钥</li>
<li><strong>奇数偏移量</strong> (1, 3, 5, …) 存储消息哈希</li>
</ul>
<p>偏移量 <code>2n</code> 处的每个公钥都与偏移量 <code>2n+1</code> 处的消息哈希相关联。例如，偏移量 0 处的公钥与偏移量 1 处的哈希配对。</p>
<h3 id="签名验证过程"><a class="header" href="#签名验证过程">签名验证过程</a></h3>
<p>在使用 ECDSA 内置函数之前，必须在该名字典中显式注册签名。当程序将值写入 ECDSA 段时，VM 执行签名验证：</p>
<ol>
<li>当公钥写入偏移量 <code>2n</code> 时，VM 检查它是否与用于创建在该偏移量注册的签名的密钥匹配</li>
<li>当消息哈希写入偏移量 <code>2n+1</code> 时，VM 验证它是否与被签名的哈希匹配</li>
</ol>
<p>如果任何一个检查失败，VM 会立即抛出错误 - 这与其一些他将验证推迟到输出访问的内置函数不同。</p>
<h3 id="有效用法示例"><a class="header" href="#有效用法示例">有效用法示例</a></h3>
<div align="center">
  <img src="ecdsa-full.png" alt="Valid ECDSA builtin segment with signatures" />
</div>

<div align="center">
  <span class="caption">有效 ECDSA 段使用示例</span>
</div>

<p>在此示例中：</p>
<ul>
<li>偏移量 0 处的公钥_0 和偏移量 1 处的哈希_0 根据存储在字典键 0 处的签名进行验证</li>
<li>偏移量 2 处的公钥_1 和偏移量 3 处的哈希_1 根据存储在字典键 2 处的签名进行验证</li>
<li>所有验证都通过，因为公钥和哈希与最初签名的内容匹配</li>
</ul>
<h3 id="错误条件"><a class="header" href="#错误条件">错误条件</a></h3>
<h4 id="无效哈希错误"><a class="header" href="#无效哈希错误">无效哈希错误</a></h4>
<div align="center">
  <img src="ecdsa-invalid-hash.png" alt="ECDSA error due to invalid hash" />
</div>

<div align="center">
  <span class="caption">错误：哈希与签名消息不匹配</span>
</div>

<p>当程序在偏移量 5 处写入哈希“1324”，但字典键 4 处的签名是为哈希“2025”创建的时，VM 会抛出错误，因为哈希与最初使用该公钥签名的内容不匹配。</p>
<h4 id="无效公钥错误"><a class="header" href="#无效公钥错误">无效公钥错误</a></h4>
<div align="center">
  <img src="ecdsa-invalid-key.png" alt="ECDSA error due to invalid public key" />
</div>

<div align="center">
  <span class="caption">错误：公钥与签名密钥不匹配</span>
</div>

<p>当程序在偏移量 4 处写入公钥“0000”，但字典键 4 处的签名是使用公钥“1515”创建的时，VM 会抛出错误，因为公钥与用于创建签名的公钥不匹配。</p>
<h2 id="实现参考-3"><a class="header" href="#实现参考-3">实现参考</a></h2>
<p>这些 ecdsa 内置函数的实现参考可能并不详尽。</p>
<ul>
<li><a href="https://github.com/kkrt-labs/cairo-vm-ts/blob/main/src/builtins/ecdsa.ts">TypeScript Signature Builtin</a></li>
<li><a href="https://github.com/starkware-libs/cairo-lang/blob/0e4dab8a6065d80d1c726394f5d9d23cb451706a/src/starkware/cairo/lang/builtins/signature/signature_builtin_runner.py">Python Signature Builtin</a></li>
<li><a href="https://github.com/lambdaclass/cairo-vm/blob/41476335884bf600b62995f0c005be7d384eaec5/vm/src/vm/runners/builtin_runner/signature.rs">Rust Signature Builtin</a></li>
<li><a href="https://github.com/keep-starknet-strange/ziggy-starkdust/blob/55d83e61968336f6be93486d7acf8530ba868d7e/src/vm/builtins/builtin_runner/signature.zig">Zig Signature Builtin</a></li>
</ul>
<h2 id="关于-ecdsa-签名的资源"><a class="header" href="#关于-ecdsa-签名的资源">关于 ECDSA 签名的资源</a></h2>
<p>如果你对 ecdsa 签名及其使用感兴趣，请查看这些参考资料：</p>
<ul>
<li>StarkNet,
<a href="https://docs.starknet.io/architecture-and-concepts/cryptography/stark-curve/">STARK curve</a></li>
<li>Svetlin Nakov,
<a href="https://cryptobook.nakov.com/digital-signatures/ecdsa-sign-verify-messages">ECDSA: Elliptic Curve Signatures</a>,
2020</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="按位运算内置函数-bitwise-builtin"><a class="header" href="#按位运算内置函数-bitwise-builtin">按位运算内置函数 (Bitwise Builtin)</a></h1>
<p>在 Cairo VM 中，<em>按位运算内置函数</em> 可以在 field 元素上进行按位运算——具体来说是 AND (<code>&amp;</code>)、XOR (<code>^</code>) 和 OR (<code>|</code>)。作为内置函数，它是 VM 架构的组成部分，旨在支持需要位级操作的特定任务。在 Cairo 中，这些按位运算通过更轻松地执行诸如位掩码或在特定用例中组合值之类的任务来补充 VM 的基本指令集。</p>
<h2 id="它是如何工作的"><a class="header" href="#它是如何工作的">它是如何工作的</a></h2>
<p>按位运算内置函数在专用内存段上运行。每个操作使用 5 个单元格的块：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>偏移量</th><th>描述</th><th>角色</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>x 值</td><td>输入</td></tr>
<tr><td>1</td><td>y 值</td><td>输入</td></tr>
<tr><td>2</td><td>x &amp; y 结果</td><td>输出</td></tr>
<tr><td>3</td><td>x ^ y 结果</td><td>输出</td></tr>
<tr><td>4</td><td>x | y 结果</td><td>输出</td></tr>
</tbody>
</table>
</div>
<p>例如，如果 <code>x = 5</code> (二进制 <code>101</code>) 且 <code>y = 3</code> (二进制 <code>011</code>)，则输出为：</p>
<ul>
<li><code>5 &amp; 3 = 1</code> (二进制 <code>001</code>)</li>
<li><code>5 ^ 3 = 6</code> (二进制 <code>110</code>)</li>
<li><code>5 | 3 = 7</code> (二进制 <code>111</code>)</li>
</ul>
<p>这种结构确在需要时高效、原生计算按位运算，并进行严格验证以防止错误（例如，输入超过位限制）。</p>
<h2 id="使用示例"><a class="header" href="#使用示例">使用示例</a></h2>
<p>这是一个使用按位运算内置函数的简单 Cairo 函数。我们使用 Cairo Zero 演示它，它更接近机器代码，并允许低级操作的可视化表示。</p>
<pre><code class="language-cairo">from starkware.cairo.common.cairo_builtins import BitwiseBuiltin

func bitwise_ops{bitwise_ptr: BitwiseBuiltin*}(x: felt, y: felt) -&gt; (and: felt, xor: felt, or: felt) {
    assert [bitwise_ptr] = x;        // Input x
    assert [bitwise_ptr + 1] = y;    // Input y
    let and = [bitwise_ptr + 2];     // x &amp; y
    let xor = [bitwise_ptr + 3];     // x ^ y
    let or = [bitwise_ptr + 4];      // x | y
    let bitwise_ptr = bitwise_ptr + 5;
    return (and, xor, or);
}
</code></pre>
<h2 id="实现参考-4"><a class="header" href="#实现参考-4">实现参考</a></h2>
<p>以下是各种 Cairo VM 实现中按位运算内置函数的实现参考：</p>
<ul>
<li><a href="https://github.com/starkware-libs/cairo-lang/blob/0e4dab8a6065d80d1c726394f5d9d23cb451706a/src/starkware/cairo/lang/builtins/bitwise/bitwise_builtin_runner.py">Python Bitwise Builtin</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ec-op-内置函数"><a class="header" href="#ec-op-内置函数">EC OP 内置函数</a></h1>
<p><em>EC OP</em>（椭圆曲线操作）内置函数在 STARK 曲线上执行椭圆曲线操作。具体来说，它计算 R = P + mQ，其中 P 和 Q 是曲线上的点，m 是标量乘数。每个点（P、Q 和 R）由一对表示其 x 和 y 坐标的 field 元素表示。</p>
<p>该内置函数能够高效地实现需要椭圆曲线算术的加密算法，与直接在 Cairo 代码中实现这些操作相比，具有显着的性能优势。</p>
<h2 id="单元格组织-2"><a class="header" href="#单元格组织-2">单元格组织</a></h2>
<p>EC OP 内置函数在 Cairo VM 运行期间拥有自己专用的段。每个操作由一个 7 个单元格的块表示：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>偏移量</th><th>描述</th><th>角色</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>P.x 坐标</td><td>输入</td></tr>
<tr><td>1</td><td>P.y 坐标</td><td>输入</td></tr>
<tr><td>2</td><td>Q.x 坐标</td><td>输入</td></tr>
<tr><td>3</td><td>Q.y 坐标</td><td>输入</td></tr>
<tr><td>4</td><td>m 标量值</td><td>输入</td></tr>
<tr><td>5</td><td>R.x 坐标</td><td>输出</td></tr>
<tr><td>6</td><td>R.y 坐标</td><td>输出</td></tr>
</tbody>
</table>
</div>
<p>前五个单元格是必须由程序写入的输入，而后两个单元格是在读取时将由 VM 计算的输出。</p>
<h3 id="有效操作示例-1"><a class="header" href="#有效操作示例-1">有效操作示例</a></h3>
<p>在此示例中，我们可以看到正确配置的 EC OP 内置函数操作：</p>
<div align="center">
  <img src="ecop-segment.png" alt="EC OP builtin segment" width="450px" />
</div>

<div align="center">
  <span class="caption">快照 1 - 具有完整输入值的有效 EC OP 段</span>
</div>

<p>程序已正确设置：</p>
<ul>
<li>点 P 坐标</li>
<li>点 Q 坐标</li>
<li>标量 m 值</li>
</ul>
<p>当程序读取偏移量 5 和 6 处的单元格时，VM 计算 R = P + mQ 并返回结果坐标。</p>
<h3 id="错误条件示例"><a class="header" href="#错误条件示例">错误条件示例</a></h3>
<p>在此示例中，我们看到尝试使用不完整的输入读取结果时的错误条件：</p>
<div align="center">
  <img src="ecop-invalid-inputs.png" alt="Incomplete input values in EC OP builtin segment" width="450px" />
</div>

<div align="center">
  <span class="caption">快照 2 - 由于输入值不完整导致的错误</span>
</div>

<p>程序尝试读取偏移量 5 和 6 处的输出单元格，但 VM 无法计算 R = P + mQ，因为：</p>
<ul>
<li>点 P 坐标已正确设置</li>
<li>点 Q 坐标缺失（两个单元格都为空）</li>
<li>标量 m 值已设置</li>
</ul>
<p>由于点 Q 的坐标缺失，VM 无法执行计算，并且在尝试读取输出单元格时将抛出错误。</p>
<p>如果任何输入值无效（不是 field 元素）或缺失，EC OP 内置函数在访问其输出时将失败。在读取输出之前，所有五个输入单元格必须包含有效的 field 元素。</p>
<h2 id="实现参考-5"><a class="header" href="#实现参考-5">实现参考</a></h2>
<p>这些 EC OP 内置函数的实现参考可能不详尽：</p>
<ul>
<li><a href="https://github.com/kkrt-labs/cairo-vm-ts/blob/main/src/builtins/ecop.ts">TypeScript EC OP Builtin</a></li>
<li><a href="https://github.com/starkware-libs/cairo-lang/blob/0e4dab8a6065d80d1c726394f5d9d23cb451706a/src/starkware/cairo/lang/builtins/ec/ec_op_builtin_runner.py">Python EC OP Builtin</a></li>
<li><a href="https://github.com/lambdaclass/cairo-vm/blob/41476335884bf600b62995f0c005be7d384eaec5/vm/src/vm/runners/builtin_runner/ec_op.rs">Rust EC OP Builtin</a></li>
<li><a href="https://github.com/keep-starknet-strange/ziggy-starkdust/blob/55d83e61968336f6be93486d7acf8530ba868d7e/src/vm/builtins/builtin_runner/ec_op.zig">Zig EC OP Builtin</a></li>
</ul>
<h2 id="关于椭圆曲线操作的资源"><a class="header" href="#关于椭圆曲线操作的资源">关于椭圆曲线操作的资源</a></h2>
<p>如果你对椭圆曲线操作及其加密应感兴趣：</p>
<ul>
<li>StarkNet,
<a href="https://docs.starknet.io/architecture-and-concepts/cryptography/stark-curve/">STARK Curve</a></li>
<li>Andrea Corbellini,
<a href="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">Elliptic Curve Cryptography: a gentle introduction</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="keccak-内置函数"><a class="header" href="#keccak-内置函数">Keccak 内置函数</a></h1>
<p><em>Keccak</em> 内置函数实现了 SHA-3 加利福尼亚哈希函数系列的核心功能。它通过对输入状态 <code>s</code> 应用 24 轮 keccak-f1600 排列来计算新状态 <code>s'</code>。此内置函数对于以太坊兼容性特别重要，因为以太坊使用 Keccak-256 进行各种加密操作。</p>
<h2 id="单元格组织-3"><a class="header" href="#单元格组织-3">单元格组织</a></h2>
<p>Keccak 内置函数使用一个专用内存段，按 16 个连续单元格的块进行组织：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>单元格范围</th><th>用途</th><th>描述</th></tr>
</thead>
<tbody>
<tr><td>前 8 个单元格</td><td>输入状态 <code>s</code></td><td>每个单元格存储 1600 位输入状态中的 200 位</td></tr>
<tr><td>后 8 个单元格</td><td>输出状态 <code>s'</code></td><td>每个单元格存储 1600 位输出状态中的 200 位</td></tr>
</tbody>
</table>
</div>
<p>内置函数独立处理每个块，应用以下规则：</p>
<ol>
<li><strong>输入验证</strong>：每个输入单元格必须包含不超过 200 位 (0 ≤ value &lt; 2^200) 的有效 field 元素</li>
<li><strong>惰性计算</strong>：仅当访问任何输出单元格时才计算输出状态</li>
<li><strong>缓存</strong>：一旦计算，结果将被缓存，以避免在访问同一块中的其他输出单元格时进行冗余计算</li>
</ol>
<h3 id="操作示例"><a class="header" href="#操作示例">操作示例</a></h3>
<div align="center">
  <img src="keccak-segment.png" alt="keccak builtin segment" />
</div>

<div align="center">
  <span class="caption">具有完整操作的 Keccak 内置函数段</span>
</div>

<p>在此示例中：</p>
<ul>
<li>程序已将输入值 [0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8] 写入前 8 个单元格</li>
<li>读取任何输出单元格后，VM 将对整个状态计算 keccak-f1600 排列</li>
<li>结果输出状态存储在接下来的 8 个单元格中</li>
<li>每个块仅计算一次并缓存</li>
</ul>
<h3 id="错误条件-1"><a class="header" href="#错误条件-1">错误条件</a></h3>
<p>在以下情况下，Keccak 内置函数将抛出错误：</p>
<ul>
<li>如果任何输入单元格包含超过 200 位 (≥ 2^200) 的值</li>
<li>如果任何输入单元格包含可重定位值（指针）而不是 field 元素</li>
<li>如果在初始化所有八个输入单元格之前读取输出单元格</li>
</ul>
<h2 id="实现参考-6"><a class="header" href="#实现参考-6">实现参考</a></h2>
<p>以下是各种 Cairo VM 实现中 Keccak 内置函数的实现参考：</p>
<ul>
<li><a href="https://github.com/kkrt-labs/cairo-vm-ts/blob/main/src/builtins/keccak.ts">TypeScript Keccak Builtin</a></li>
<li><a href="https://github.com/starkware-libs/cairo-lang/blob/0e4dab8a6065d80d1c726394f5d9d23cb451706a/src/starkware/cairo/lang/builtins/keccak/keccak_builtin_runner.py">Python Keccak Builtin</a></li>
<li><a href="https://github.com/lambdaclass/cairo-vm/blob/41476335884bf600b62995f0c005be7d384eaec5/vm/src/vm/runners/builtin_runner/keccak.rs">Rust Keccak Builtin</a></li>
<li><a href="https://github.com/keep-starknet-strange/ziggy-starkdust/blob/55d83e61968336f6be93486d7acf8530ba868d7e/src/vm/builtins/builtin_runner/keccak.zig">Zig Keccak Builtin</a></li>
</ul>
<h2 id="关于-keccak-哈希的资源"><a class="header" href="#关于-keccak-哈希的资源">关于 Keccak 哈希的资源</a></h2>
<p>如果你对 Keccak 哈希函数及其应用感兴趣：</p>
<ul>
<li>StarkNet,
<a href="https://docs.starknet.io/architecture-and-concepts/cryptography/hash-functions/#starknet_keccak">Hash Functions - Starknet Keccak</a></li>
<li>NIST,
<a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf">SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions</a></li>
<li>Wikipedia,
<a href="https://en.wikipedia.org/wiki/SHA-3">SHA-3 (Secure Hash Algorithm 3)</a></li>
<li>Keccak Team, <a href="https://keccak.team/keccak_specs_summary.html">Keccak Reference</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="poseidon-内置函数"><a class="header" href="#poseidon-内置函数">Poseidon 内置函数</a></h1>
<p><em>Poseidon</em> 内置函数使用 Poseidon 哈希函数计算加密哈希，该函数专门为零知识证明和代数电路中的高效计算而优化。作为 Cairo 加密操作的核心组件，它使用 Hades 排列策略，结合全轮和部分轮以在 STARK 证明中实现安全性和性能。</p>
<p>Poseidon 对 Cairo 应用程序特别重要，因为它提供：</p>
<ul>
<li>比 Pedersen 处理多个输入更好的性能</li>
<li>ZK 友好的设计（针对 ZK 证明系统中的约束进行了优化）</li>
<li>强大的加密安全属性</li>
</ul>
<h2 id="单元格组织-4"><a class="header" href="#单元格组织-4">单元格组织</a></h2>
<p>Poseidon 内置函数使用专用内存段运行，并遵循推导属性模式：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>单元格</th><th>用途</th></tr>
</thead>
<tbody>
<tr><td>输入单元格 [0-2]</td><td>存储 Hades 排列的输入状态</td></tr>
<tr><td>输出单元格 [3-5]</td><td>存储计算出的排列结果</td></tr>
</tbody>
</table>
</div>
<p>每个操作处理 6 个连续的单元格——一个包含 3 个输入的块，后跟 3 个输出。当程序读取任何输出单元格时，VM 将 Hades 排列应用于输入单元格，并用结果填充所有三个输出单元格。</p>
<h3 id="单值哈希示例"><a class="header" href="#单值哈希示例">单值哈希示例</a></h3>
<div align="center">
  <img src="poseidon-builtin-valid.png" alt="valid poseidon builtin segment" width="600px" />
</div>

<div align="center">
  <span class="caption">具有有效输入的 Poseidon 内置函数段</span>
</div>

<p>对于在第一个实例中哈希单个值 (42)：</p>
<ol>
<li>程序将值写入第一个输入单元格（位置 3:0）</li>
<li>其他输入单元格保持默认值 (0)</li>
<li>读取输出单元格 (3:3) 时，VM：
<ul>
<li>获取初始状态 (42, 0, 0)</li>
<li>应用填充：(42+1, 0, 0) = (43, 0, 0)</li>
<li>计算 Hades 排列</li>
<li>将结果存储在输出单元格 3:3 中</li>
</ul>
</li>
</ol>
<p>当哈希单个值时，排列结果的第一个分量成为哈希输出。</p>
<h3 id="序列哈希示例"><a class="header" href="#序列哈希示例">序列哈希示例</a></h3>
<p>对于在第二个实例中哈希值序列 (73, 91)：</p>
<ol>
<li>程序将值写入前两个输入单元格（位置 3:6 和 3:7）</li>
<li>读取任何输出单元格时，VM：
<ul>
<li>获取状态 (73, 91, 0)</li>
<li>应用适当的填充：(73, 91+1, 0)</li>
<li>计算 Hades 排列</li>
<li>将所有三个结果存储在输出单元格 (3:9, 3:10, 3:11) 中</li>
</ul>
</li>
</ol>
<p>当哈希序列时，所有三个输出状态分量均可用于进一步计算或多轮哈希中的链接。</p>
<h3 id="错误条件-2"><a class="header" href="#错误条件-2">错误条件</a></h3>
<div align="center">
  <img src="poseidon-builtin-error.png" alt="invalid poseidon builtin segment" width="300px" />
</div>

<div align="center">
  <span class="caption">具有无效输入的 Poseidon 内置函数段</span>
</div>

<p>在此错误示例中：</p>
<ul>
<li>程序尝试将可重定位值（指向单元格 7:1 的指针）写入输入单元格 3:0</li>
<li>尝试读取输出单元格 3:3 时，VM 抛出错误</li>
<li>发生错误是因为 Poseidon 内置函数只能对 field 元素进行操作，而不能对内存地址进行操作</li>
</ul>
<p>输入验证发生在读取输出时，而不是写入输入时，这与推导属性模式一致。</p>
<h2 id="实现参考-7"><a class="header" href="#实现参考-7">实现参考</a></h2>
<p>以下是各种 Cairo VM 实现中 Poseidon 内置函数的实现参考：</p>
<ul>
<li><a href="https://github.com/kkrt-labs/cairo-vm-ts/blob/main/src/builtins/poseidon.ts">TypeScript Poseidon Builtin</a></li>
<li><a href="https://github.com/starkware-libs/cairo-lang/blob/0e4dab8a6065d80d1c726394f5d9d23cb451706a/src/starkware/cairo/lang/builtins/poseidon/poseidon_builtin_runner.py">Python Poseidon Builtin</a></li>
<li><a href="https://github.com/lambdaclass/cairo-vm/blob/052e7cef977b336305c869fccbf24e1794b116ff/vm/src/vm/runners/builtin_runner/poseidon.rs">Rust Poseidon Builtin</a></li>
<li><a href="https://github.com/keep-starknet-strange/ziggy-starkdust/blob/55d83e61968336f6be93486d7acf8530ba868d7e/src/vm/builtins/builtin_runner/poseidon.zig">Zig Poseidon Builtin</a></li>
</ul>
<h2 id="关于-poseidon-哈希的资源"><a class="header" href="#关于-poseidon-哈希的资源">关于 Poseidon 哈希的资源</a></h2>
<p>如果你对 Poseidon 哈希函数及其应用感兴趣：</p>
<ul>
<li><a href="https://docs.starknet.io/architecture-and-concepts/cryptography/hash-functions/#poseidon-hash">StarkNet - Hash Functions: Poseidon Hash</a></li>
<li><a href="https://github.com/starkware-industries/poseidon/tree/main">StarkWare - Poseidon Implementation</a></li>
<li><a href="https://eprint.iacr.org/2019/458.pdf">Poseidon: A New Hash Function for Zero-Knowledge Proof Systems</a>
(original paper)</li>
<li><a href="https://www.poseidon-hash.info/">Poseidon: ZK-friendly Hashing</a></li>
<li><a href="https://autoparallel.github.io/overview/index.html">Poseidon Journal</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="mod-内置函数"><a class="header" href="#mod-内置函数">Mod 内置函数</a></h1>
<p>在 Cairo 虚拟机 (VM) 中，<em>Mod 内置函数</em> 是一个专门的内置函数，用于处理给定模数内 field 元素（或 felts）的模运算操作——具体来说是加法和乘法。它旨在高效计算像 <code>a + b (mod p)</code> 和 <code>a * b (mod p)</code> 这样的表达式。</p>
<p>为此，它有两个派生：用于加法的 <code>AddModBuiltin</code> 和用于乘法的 <code>MulModBuiltin</code>。</p>
<p>此内置函数是加密应用程序或大量使用模运算的计算（尤其是在处理像 <code>UInt384</code> 这样的大整数时）的必需品。</p>
<h2 id="为什么我们需要它"><a class="header" href="#为什么我们需要它">为什么我们需要它</a></h2>
<p>模运算是许多加密协议和零知识证明系统的核心。如果你尝试用纯 Cairo 代码实现这些操作，你很快就会遇到计算开销的阻碍——重复的除法和余数检查会大大增加步骤数。Mod 内置函数提供了一种优化的解决方案来高效处理这些操作。实际上，在操作 <a href="#算术电路-arithmetic-circuits">算术电路</a> 时，你在底层使用的就是 Mod 内置函数。</p>
<h2 id="它的结构是如何的"><a class="header" href="#它的结构是如何的">它的结构是如何的</a></h2>
<p>每个实例都从七个输入单元格开始。其中四个——<code>p0</code>、<code>p1</code>、<code>p2</code> 和 <code>p3</code>——将模数 <code>p</code> 定义为一个多字整数，通常为了 <code>UInt384</code> 兼容性而分成四个 96 位的块。然后，操作数和结果存储在 <code>values_ptr</code> 中，<code>offsets_ptr</code> 指向另一个表，告诉内置函数相对于 <code>values_ptr</code> 在哪里读取或写入这些值。最后，<code>n</code> 指定要执行多少次操作，它需要是批处理大小的倍数。</p>
<p>内置函数的核心技巧是推导。给它三元组的两个部分——比如 <code>a</code> 和 <code>b</code>——它会根据操作和模数计算出第三个部分 <code>c</code>。或者，如果你提供 <code>c</code> 和一个操作数，它可以求解另一个。它分批处理这些三元组（通常一次只处理一个），确保 <code>op(a, b) = c + k * p</code> 成立，其中 <code>k</code> 是特定范围内的商——加法较小，乘法较大。实际上，你是使用 <code>run_mod_p_circuit</code> 函数设置此项，该函数将所有内容联系在一起。值表通常与 <code>range_check96_ptr</code> 段重叠，以保持每个字在 <code>2^96</code> 以下，并且偏移量是使用 <code>dw</code> 指令定义为程序字面量的。</p>
<h2 id="投入使用模加法"><a class="header" href="#投入使用模加法">投入使用：模加法</a></h2>
<p>让我们通过一个使用 <code>AddMod</code> 内置函数计算两个 <code>UInt384</code> 值的 <code>x + y (mod p)</code> 的示例来演示。这段 Cairo Zero 代码展示了 Mod 内置函数如何融入实际程序。</p>
<pre><code class="language-cairo">from starkware.cairo.common.cairo_builtins import UInt384, ModBuiltin
from starkware.cairo.common.modulo import run_mod_p_circuit
from starkware.cairo.lang.compiler.lib.registers import get_fp_and_pc

func add{range_check96_ptr: felt*, add_mod_ptr: ModBuiltin*, mul_mod_ptr: ModBuiltin*}(
    x: UInt384*, y: UInt384*, p: UInt384*
) -&gt; UInt384* {
    let (_, pc) = get_fp_and_pc();

    // Define pointers to the offsets tables, which come later in the code
    pc_label:
    let add_mod_offsets_ptr = pc + (add_offsets - pc_label);
    let mul_mod_offsets_ptr = pc + (mul_offsets - pc_label);

    // Load x and y into the range_check96 segment, which doubles as our values table
    // x takes slots 0-3, y takes 4-7—each UInt384 is 4 words of 96 bits
    assert [range_check96_ptr + 0] = x.d0;
    assert [range_check96_ptr + 1] = x.d1;
    assert [range_check96_ptr + 2] = x.d2;
    assert [range_check96_ptr + 3] = x.d3;
    assert [range_check96_ptr + 4] = y.d0;
    assert [range_check96_ptr + 5] = y.d1;
    assert [range_check96_ptr + 6] = y.d2;
    assert [range_check96_ptr + 7] = y.d3;

    // Fire up the modular circuit: 1 addition, no multiplications
    // The builtin deduces c = x + y (mod p) and writes it to offsets 8-11
    run_mod_p_circuit(
        p=[p],
        values_ptr=cast(range_check96_ptr, UInt384*),
        add_mod_offsets_ptr=add_mod_offsets_ptr,
        add_mod_n=1,
        mul_mod_offsets_ptr=mul_mod_offsets_ptr,
        mul_mod_n=0,
    );

    // Bump the range_check96_ptr forward: 8 input words + 4 output words = 12 total
    let range_check96_ptr = range_check96_ptr + 12;

    // Return a pointer to the result, sitting in the last 4 words
    return cast(range_check96_ptr - 4, UInt384*);

    // Offsets for AddMod: point to x (0), y (4), and the result (8)
    add_offsets:
    dw 0;  // x starts at offset 0
    dw 4;  // y starts at offset 4
    dw 8;  // result c starts at offset 8

    // No offsets needed for MulMod here
    mul_offsets:
}
</code></pre>
<p>在这个函数中，我们获取两个 <code>UInt384</code> 值 <code>x</code> 和 <code>y</code>，以及一个模数 <code>p</code>。我们将 <code>x</code> 和 <code>y</code> 写入从 <code>range_check96_ptr</code> 开始的值表，然后使用偏移量——<code>[0, 4, 8]</code>——告诉内置函数 <code>x</code>、<code>y</code> 和结果 <code>c</code> 所在的位置。<code>run_mod_p_circuit</code> 调用触发 <code>AddMod</code> 内置函数计算 <code>x + y (mod p)</code> 并将结果存储在偏移量 8 处。调整指针后，我们返回指向该结果的指针。这是一个简单的设置，但内置函数为我们处理模归约，节省了大量的手动工作。</p>
<p>想象一个 <code>n_words = 1</code> 且 <code>batch_size = 1</code> 的简单情况。如果 <code>p = 5</code>，<code>x = 3</code>，且 <code>y = 4</code>，值表可能包含 <code>[3, 4, 2]</code>。偏移量 <code>[0, 1, 2]</code> 指向 <code>a = 3</code>，<code>b = 4</code>，和 <code>c = 2</code>。内置函数检查：<code>3 + 4 = 7</code>，且 <code>7 mod 5 = 2</code>，这与 <code>c</code> 匹配。一切都通过检查。</p>
<p>如果出现问题——比如说 <code>x</code> 缺少一个字——内置函数会标记 <code>MissingOperand</code> 错误。对于 <code>MulMod</code>，如果 <code>b</code> 和 <code>p</code> 互质且 <code>a</code> 未知，你会得到 <code>ZeroDivisor</code> 错误。如果任何字超过 <code>2^96</code>，范围检查将失败。这些保障措施保持操作可靠。</p>
<h2 id="幕后花絮"><a class="header" href="#幕后花絮">幕后花絮</a></h2>
<p>让我们仔细看看 Mod 内置函数是如何设计的，以及为什么它是这样构建的。这里的目标是效率——使模运算在 Cairo 虚拟机中快速可靠——同时保持其在现实世界使用中的实用性，如加密程序。为了理解这一点，我们将探索其结构的一些关键部分以及其背后的思想。</p>
<p>首先，为什么要将数字分成 96 位的块，对于 <code>UInt384</code> 来说通常是四个？这不是随意的选择。Cairo VM 已经有一个内置系统来检查数字是否在特定范围内，称为 <code>range_check96</code>，它处理 96 位的值。通过将 Mod 内置函数的字大小与该系统对齐，它可以依靠 VM 现有的机制来确保数字的每个块都保持在 <code>2^96</code> 以下。对于 <code>UInt384</code>，四个 96 位字加起来是 384 位，这对于大多数加密应用程序来说足够大了。</p>
<p>现在，考虑 <code>AddMod</code> 和 <code>MulMod</code> 之间的区别。当你将两个接近模数 <code>p</code> 的数字相加时，结果最多为 <code>2p - 2</code>。这就是为什么 <code>AddMod</code> 将其商 <code>k</code>——减去 <code>p</code> 以通过结果的次数——限制为仅 2。如果 <code>a + b</code> 是，比如说，<code>1.5p</code>，那么 <code>k = 1</code> 且 <code>c = a + b - p</code> 保持一切正常。这是一个严格的约束，因为加法不会产生非常大的数字。但是，乘法不同。使用 <code>MulMod</code>，<code>a * b</code> 可能是巨大的——想想 <code>p * p</code> 或更多——所以默认的商界限设置得更高，高达 <code>2^384</code>。这确保了它甚至可以处理最大的乘积，而不会耗尽调整空间。</p>
<p>真正的巧妙之处在于内置函数如何找出缺失的值，这个过程称为推导。它不是总是从头开始，而是利用内存中已有的内容。对于 <code>AddMod</code>，如果你给它 <code>a</code> 和 <code>b</code>，它会计算 <code>c = a + b (mod p)</code>。如果你给它 <code>c</code> 和 <code>b</code>，它会求解 <code>a + b = c + k * p</code> 来找到 <code>a</code>，测试 <code>k = 0</code> 或 <code>1</code>。</p>
<p>对于 <code>MulMod</code>，它更棘手——乘法不像加法那样直接可逆。在这里，它使用一种称为扩展 GCD 算法的数学工具来求解 <code>a * b = c (mod p)</code>。如果 <code>b</code> 和 <code>p</code> 有公因数（它们的最大公约数不是 1），则没有唯一解，它会标记 <code>ZeroDivisor</code> 错误。否则，它会找到适合的最小 <code>a</code>。</p>
<p>另一个设计选择是批处理大小，实际上通常仅为 1。内置函数可以一次处理多个操作——<code>batch_size</code> 个 <code>a</code>、<code>b</code> 和 <code>c</code> 的三元组——但在大多数情况下将其保持为 1 可以简化事情。这就像一次处理一个加法或乘法，这对于许多程序来说已经足够了，尽管如果你需要，扩展的选项就在那里。</p>
<p>为什么要将值表绑定到 <code>range_check96_ptr</code>？这又是关于效率。VM 的范围检查系统已经设置为监视该段，因此将其用于内置函数的值——如 <code>a</code>、<code>b</code> 和 <code>c</code>——意味着这些数字会自动得到验证。</p>
<h2 id="实现参考-8"><a class="header" href="#实现参考-8">实现参考</a></h2>
<p>以下是各种 Cairo VM 实现中 Mod 内置函数的实现参考：</p>
<ul>
<li><a href="https://github.com/starkware-libs/cairo-lang/blob/0e4dab8a6065d80d1c726394f5d9d23cb451706a/src/starkware/cairo/lang/builtins/modulo/mod_builtin_runner.py">Python Mod Builtin</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="segment-arena-内置函数"><a class="header" href="#segment-arena-内置函数">Segment Arena 内置函数</a></h1>
<p><em>Segment Arena</em> 内置函数通过跟踪段端点来扩展 Cairo VM 的内存处理。这种方法简化了需要分配和最终确定段的内存操作。</p>
<h2 id="单元格组织-5"><a class="header" href="#单元格组织-5">单元格组织</a></h2>
<p>每个 Segment Arena 内置函数实例使用 3 个单元格的块工作，这些块维护字典的状态：</p>
<ul>
<li>第一个单元格：包含信息指针的基地址</li>
<li>第二个单元格：包含当前分配的段数</li>
<li>第三个单元格：包含当前已压缩/最终确定的段数</li>
</ul>
<p>此结构与信息段密切配合，信息段也按 3 个单元格的块组织：</p>
<ul>
<li>第一个单元格：段的基地址</li>
<li>第二个单元格：段的结束地址（压缩时）</li>
<li>第三个单元格：当前已压缩段的数量（压缩索引）</li>
</ul>
<div align="center">
  <img src="segment-arena.png" alt="segment arena builtin segment" />
</div>

<div align="center">
  <span class="caption">Segment Arena 内置函数段</span>
</div>

<p>让我们看两个 Segment Arena 段的快照，这是在 Cairo VM 执行虚拟程序期间。</p>
<p>在第一个快照中，让我们看看分配字典时的第一种情况：</p>
<ul>
<li><code>info_ptr</code> 指向新的信息段</li>
<li><code>n_dicts</code> 增加到 1</li>
<li>创建具有三个单元格的信息段</li>
<li>字典获取新段 <code>&lt;3:0&gt;</code></li>
</ul>
<p>现在，在第二种情况下，又分配了一个字典：</p>
<ul>
<li>每个字典的信息段增加三个单元格</li>
<li>已压缩字典设置了结束地址</li>
<li>按顺序分配压缩索引</li>
<li>未完成的字典具有 <code>0</code> 结束地址</li>
</ul>
<div align="center">
  <img src="segment-arena-valid.png" alt="valid segment arena builtin segment" />
</div>

<div align="center">
  <span class="caption">快照 1 - 有效的 Segment Arena 内置函数段</span>
</div>

<p>第二个快照显示了两种错误情况。在第一种情况下，当 <code>info_ptr</code> 包含 <em>非可重定位</em> 值 <code>ABC</code> 时，会出现无效状态。访问信息段时会触发错误。在第二种情况下，当出现快照所示的不一致状态（<code>n_squashed</code> 大于 <code>n_segments</code>）时，会出现错误。</p>
<div align="center">
  <img src="segment-arena-error.png" alt="invalid segment arena builtin segment" />
</div>

<div align="center">
  <span class="caption">快照 2 - 无效的 Segment Arena 内置函数段</span>
</div>

<h3 id="关键验证规则"><a class="header" href="#关键验证规则">关键验证规则</a></h3>
<p>内置函数强制执行多项规则：</p>
<ul>
<li>每个段必须恰好分配和最终确定一次</li>
<li>所有单元格值必须是有效的 field 元素</li>
<li>段大小必须是非负的</li>
<li>压缩操作必须保持顺序</li>
<li>信息段条目必须对应于段分配</li>
</ul>
<h2 id="实现参考-9"><a class="header" href="#实现参考-9">实现参考</a></h2>
<p>这些 Segment Arena 内置函数的实现参考可能并不详尽。</p>
<ul>
<li><a href="https://github.com/kkrt-labs/cairo-vm-ts/blob/main/src/builtins/segmentArena.ts">TypeScript Segment Arena Builtin</a></li>
<li><a href="https://github.com/lambdaclass/cairo-vm/blob/41476335884bf600b62995f0c005be7d384eaec5/vm/src/vm/runners/builtin_runner/segment_arena.rs">Rust Segment Arena Builtin</a></li>
<li><a href="https://github.com/keep-starknet-strange/ziggy-starkdust/blob/55d83e61968336f6be93486d7acf8530ba868d7e/src/vm/builtins/builtin_runner/segment_arena.zig">Zig Segment Arena Builtin</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="提示-hints"><a class="header" href="#提示-hints">提示 (Hints)</a></h1>
<p>Cairo 支持非确定性编程，允许证明者在程序执行期间运行额外的代码来任意设置内存中的值。这种机制称为“提示 (hints)”。</p>
<p>实际上，提示主要用于加速某些操作，验证这些操作的成本比执行它们要低。例如，请记住我们的 ISA 主要由乘法和加法组成。仅使用 field 算术、加法和乘法计算 25 的平方根将非常昂贵。然而，要求证明者用期望的结果填充内存是很简单的，他可以用任何他想要的方式计算该结果，并且简单地 <em>约束</em> 结果是 25 的平方根。</p>
<p>这里重要的部分是 <em>约束</em>：当我们让证明者用随机值填充内存时，我们需要确保证明者在填充此内存单元时是诚实的。如果不这样做，将导致“欠约束程序 (underconstrained program)”，这是一个安全问题，因为证明不再可靠。在我们的平方根示例中，约束提供的结果在平方时等于 25 就足够了。</p>
<p>这种技术在 Cairo 标准库中广泛用于典型操作，并为证明系统提供了显着的优势。</p>
<p>提示不是被证明跟踪的一部分，因此从验证者的角度来看，它们所做的任何工作都是“免费”的。提示通常是用任何编程语言编写的，因为它们仅由证明者的运行器使用。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="运行器-runner"><a class="header" href="#运行器-runner">运行器 (Runner)</a></h1>
<p>Cairo 运行器是协调已编译 Cairo 程序执行的主要可执行程序。它是理论 Cairo 机器的实际实现，将内存模型、执行模型、内置函数和提示结合在一起。</p>
<p>其当前的实现是用 Rust 编写的，由 <a href="https://github.com/lambdaclass/cairo-vm">LambdaClass</a> 开发，它既可以作为独立二进制文件使用，也可以作为库使用。</p>
<h2 id="运行器模式"><a class="header" href="#运行器模式">运行器模式</a></h2>
<p>Cairo 运行器可以根据预期的执行目的在不同模式下运行。它获取已编译的 Cairo 字节码（加上提示）并生成执行跟踪和内存，为 STARK 证明者准备输入。</p>
<p>在 <strong>执行模式 (Execution Mode)</strong> 下，运行器只是运行程序直到完成，执行提示和 Cairo VM 的状态转换函数。此模式主要用于调试或测试程序逻辑，而没有证明生成的开销。它逐步完全执行程序，使用提示填充非确定性值，然后应用每条指令的转换来构建完整的状态跟踪和最终内存。输出包括跟踪、所选内存以及初始/最终寄存器状态（<code>pc</code>、<code>ap</code>、<code>fp</code>）。如果任何提示或指令检查失败，运行器将停止并报错。</p>
<p>在 <strong>证明模式 (Proof Mode)</strong> 下，运行器不仅执行程序，还准备证明生成所需的输入。这是生产使用的主要模式，即当人们想要生成执行证明时。当运行器执行程序时，它会记录每一步的 VM 状态，并构建“执行跟踪”和最终内存状态。执行完成后，可以提取内存转储和顺序寄存器状态，构成执行跟踪。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
